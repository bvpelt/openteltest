{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { AttributeHashMap } from './HashMap';\n/**\n * Internal interface.\n *\n * Allows synchronous collection of metrics. This processor should allow\n * allocation of new aggregation cells for metrics and convert cumulative\n * recording to delta data points.\n */\nvar DeltaMetricProcessor = /** @class */function () {\n  function DeltaMetricProcessor(_aggregator) {\n    this._aggregator = _aggregator;\n    this._activeCollectionStorage = new AttributeHashMap();\n    // TODO: find a reasonable mean to clean the memo;\n    // https://github.com/open-telemetry/opentelemetry-specification/pull/2208\n    this._cumulativeMemoStorage = new AttributeHashMap();\n  }\n  DeltaMetricProcessor.prototype.record = function (value, attributes, _context, collectionTime) {\n    var _this = this;\n    var accumulation = this._activeCollectionStorage.getOrDefault(attributes, function () {\n      return _this._aggregator.createAccumulation(collectionTime);\n    });\n    accumulation === null || accumulation === void 0 ? void 0 : accumulation.record(value);\n  };\n  DeltaMetricProcessor.prototype.batchCumulate = function (measurements, collectionTime) {\n    var _this = this;\n    Array.from(measurements.entries()).forEach(function (_a) {\n      var _b = __read(_a, 3),\n        attributes = _b[0],\n        value = _b[1],\n        hashCode = _b[2];\n      var accumulation = _this._aggregator.createAccumulation(collectionTime);\n      accumulation === null || accumulation === void 0 ? void 0 : accumulation.record(value);\n      var delta = accumulation;\n      // Diff with recorded cumulative memo.\n      if (_this._cumulativeMemoStorage.has(attributes, hashCode)) {\n        // has() returned true, previous is present.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        var previous = _this._cumulativeMemoStorage.get(attributes, hashCode);\n        delta = _this._aggregator.diff(previous, accumulation);\n      }\n      // Merge with uncollected active delta.\n      if (_this._activeCollectionStorage.has(attributes, hashCode)) {\n        // has() returned true, previous is present.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        var active = _this._activeCollectionStorage.get(attributes, hashCode);\n        delta = _this._aggregator.merge(active, delta);\n      }\n      // Save the current record and the delta record.\n      _this._cumulativeMemoStorage.set(attributes, accumulation, hashCode);\n      _this._activeCollectionStorage.set(attributes, delta, hashCode);\n    });\n  };\n  /**\n   * Returns a collection of delta metrics. Start time is the when first\n   * time event collected.\n   */\n  DeltaMetricProcessor.prototype.collect = function () {\n    var unreportedDelta = this._activeCollectionStorage;\n    this._activeCollectionStorage = new AttributeHashMap();\n    return unreportedDelta;\n  };\n  return DeltaMetricProcessor;\n}();\nexport { DeltaMetricProcessor };","map":{"version":3,"names":["__read","o","n","m","Symbol","iterator","i","call","r","ar","e","next","done","push","value","error","AttributeHashMap","DeltaMetricProcessor","_aggregator","_activeCollectionStorage","_cumulativeMemoStorage","prototype","record","attributes","_context","collectionTime","_this","accumulation","getOrDefault","createAccumulation","batchCumulate","measurements","Array","from","entries","forEach","_a","_b","hashCode","delta","has","previous","get","diff","active","merge","set","collect","unreportedDelta"],"sources":["/home/bvpelt/Develop/openteltest/node_modules/@opentelemetry/sdk-metrics/build/esm/state/DeltaMetricProcessor.js"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { AttributeHashMap } from './HashMap';\n/**\n * Internal interface.\n *\n * Allows synchronous collection of metrics. This processor should allow\n * allocation of new aggregation cells for metrics and convert cumulative\n * recording to delta data points.\n */\nvar DeltaMetricProcessor = /** @class */ (function () {\n    function DeltaMetricProcessor(_aggregator) {\n        this._aggregator = _aggregator;\n        this._activeCollectionStorage = new AttributeHashMap();\n        // TODO: find a reasonable mean to clean the memo;\n        // https://github.com/open-telemetry/opentelemetry-specification/pull/2208\n        this._cumulativeMemoStorage = new AttributeHashMap();\n    }\n    DeltaMetricProcessor.prototype.record = function (value, attributes, _context, collectionTime) {\n        var _this = this;\n        var accumulation = this._activeCollectionStorage.getOrDefault(attributes, function () { return _this._aggregator.createAccumulation(collectionTime); });\n        accumulation === null || accumulation === void 0 ? void 0 : accumulation.record(value);\n    };\n    DeltaMetricProcessor.prototype.batchCumulate = function (measurements, collectionTime) {\n        var _this = this;\n        Array.from(measurements.entries()).forEach(function (_a) {\n            var _b = __read(_a, 3), attributes = _b[0], value = _b[1], hashCode = _b[2];\n            var accumulation = _this._aggregator.createAccumulation(collectionTime);\n            accumulation === null || accumulation === void 0 ? void 0 : accumulation.record(value);\n            var delta = accumulation;\n            // Diff with recorded cumulative memo.\n            if (_this._cumulativeMemoStorage.has(attributes, hashCode)) {\n                // has() returned true, previous is present.\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                var previous = _this._cumulativeMemoStorage.get(attributes, hashCode);\n                delta = _this._aggregator.diff(previous, accumulation);\n            }\n            // Merge with uncollected active delta.\n            if (_this._activeCollectionStorage.has(attributes, hashCode)) {\n                // has() returned true, previous is present.\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                var active = _this._activeCollectionStorage.get(attributes, hashCode);\n                delta = _this._aggregator.merge(active, delta);\n            }\n            // Save the current record and the delta record.\n            _this._cumulativeMemoStorage.set(attributes, accumulation, hashCode);\n            _this._activeCollectionStorage.set(attributes, delta, hashCode);\n        });\n    };\n    /**\n     * Returns a collection of delta metrics. Start time is the when first\n     * time event collected.\n     */\n    DeltaMetricProcessor.prototype.collect = function () {\n        var unreportedDelta = this._activeCollectionStorage;\n        this._activeCollectionStorage = new AttributeHashMap();\n        return unreportedDelta;\n    };\n    return DeltaMetricProcessor;\n}());\nexport { DeltaMetricProcessor };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}