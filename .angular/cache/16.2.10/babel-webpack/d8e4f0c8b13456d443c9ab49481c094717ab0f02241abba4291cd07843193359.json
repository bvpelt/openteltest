{"ast":null,"code":"// Copyright (c) 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint max-statements:[0, 99] */\n'use strict';\n\nvar TYPE = require('./TYPE');\nvar bufrwErrors = require('bufrw/errors');\nvar errors = require('./errors');\nvar TMapHeaderRW = require('./tmap').TMapRW.prototype.headerRW;\nvar TListHeaderRW = require('./tlist').TListRW.prototype.headerRW;\nvar widths = Object.create(null);\nwidths[TYPE.VOID] = 0;\nwidths[TYPE.BOOL] = 1;\nwidths[TYPE.BYTE] = 1;\nwidths[TYPE.I8] = 1;\nwidths[TYPE.DOUBLE] = 8;\nwidths[TYPE.I16] = 2;\nwidths[TYPE.I32] = 4;\nwidths[TYPE.I64] = 8;\nvar skipVar = Object.create(null);\nskipVar[TYPE.STRUCT] = skipStruct;\nskipVar[TYPE.STRING] = skipString;\nskipVar[TYPE.MAP] = skipMap;\nskipVar[TYPE.SET] = skipList;\nskipVar[TYPE.LIST] = skipList;\nfunction skipField(destResult, buffer, offset) {\n  // istanbul ignore if\n  if (offset + 1 > buffer.length) {\n    return destResult.reset(bufrwErrors.ShortBuffer({\n      expected: offset + 1,\n      actual: buffer.length,\n      buffer: buffer,\n      offset: offset\n    }), offset);\n  }\n  var typeid = buffer.readInt8(offset, true);\n  offset += 1;\n  return skipType(destResult, buffer, offset, typeid);\n}\nfunction skipType(destResult, buffer, offset, typeid) {\n  var result;\n\n  // istanbul ignore else\n  if (skipVar[typeid] !== undefined) {\n    result = skipVar[typeid](destResult, buffer, offset);\n    // istanbul ignore if\n    if (result.err) {\n      return result;\n    }\n    offset = result.offset;\n  } else if (widths[typeid] !== undefined) {\n    var length = widths[typeid];\n    if (offset + length > buffer.length) {\n      return destResult.reset(bufrwErrors.ShortBuffer({\n        expected: offset + length,\n        actual: buffer.length,\n        buffer: buffer,\n        offset: offset\n      }), offset);\n    }\n    offset += length;\n  } else {\n    return destResult.reset(errors.InvalidTypeidError({\n      typeid: typeid,\n      what: 'field::type'\n    }), offset);\n  }\n  return destResult.reset(null, offset);\n}\nfunction skipStruct(destResult, buffer, offset) {\n  var result;\n  for (;;) {\n    // typeid\n    // istanbul ignore if\n    if (offset + 1 > buffer.length) {\n      return destResult.reset(bufrwErrors.ShortBuffer({\n        expected: offset + 1,\n        actual: buffer.length,\n        buffer: buffer,\n        offset: offset\n      }), offset);\n    }\n    var typeid = buffer.readInt8(offset, true);\n    offset += 1;\n    if (typeid === TYPE.STOP) {\n      return destResult.reset(null, offset);\n    }\n\n    // id\n    // istanbul ignore if\n    if (offset + 2 > buffer.length) {\n      return destResult.reset(bufrwErrors.ShortBuffer({\n        expected: offset + 2,\n        actual: buffer.length,\n        buffer: buffer,\n        offset: offset\n      }), offset);\n    }\n    offset += 2;\n    result = skipType(destResult, buffer, offset, typeid);\n    // istanbul ignore if\n    if (result.err) {\n      return result;\n    }\n    offset = result.offset;\n  }\n}\nfunction skipString(destResult, buffer, offset) {\n  // istanbul ignore if\n  if (offset + 4 > buffer.length) {\n    return destResult.reset(bufrwErrors.ShortBuffer({\n      expected: offset + 4,\n      actual: buffer.length,\n      buffer: buffer,\n      offset: offset\n    }), offset);\n  }\n  var length = buffer.readInt32BE(offset, true);\n  offset += 4;\n\n  // istanbul ignore if\n  if (offset + length > buffer.length) {\n    return destResult.reset(bufrwErrors.ShortBuffer({\n      expected: offset + length,\n      actual: buffer.length,\n      buffer: buffer,\n      offset: offset\n    }), offset);\n  }\n  offset += length;\n  return destResult.reset(null, offset);\n}\nfunction skipMap(destResult, buffer, offset) {\n  var result;\n\n  // map headers\n  result = TMapHeaderRW.poolReadFrom(destResult, buffer, offset);\n  // istanbul ignore if\n  if (result.err) {\n    return result;\n  }\n  offset = result.offset;\n  var header = result.value;\n  var ktypeid = header[0];\n  var vtypeid = header[1];\n  var length = header[2];\n\n  // each entry\n  for (var index = 0; index < length; index++) {\n    result = skipType(destResult, buffer, offset, ktypeid);\n    // istanbul ignore if\n    if (result.err) {\n      return result;\n    }\n    offset = result.offset;\n    result = skipType(destResult, buffer, offset, vtypeid);\n    // istanbul ignore if\n    if (result.err) {\n      return result;\n    }\n    offset = result.offset;\n  }\n  return destResult.reset(null, offset);\n}\nfunction skipList(destResult, buffer, offset) {\n  var result;\n\n  // list/set headers\n  result = TListHeaderRW.poolReadFrom(destResult, buffer, offset);\n  // istanbul ignore if\n  if (result.err) {\n    return result;\n  }\n  offset = result.offset;\n  var header = result.value;\n  var vtypeid = header[0];\n  var length = header[1];\n\n  // each value\n  for (var index = 0; index < length; index++) {\n    result = skipType(destResult, buffer, offset, vtypeid);\n    // istanbul ignore if\n    if (result.err) {\n      return result;\n    }\n    offset = result.offset;\n  }\n  return destResult.reset(null, offset);\n}\nmodule.exports.skipField = skipField;\nmodule.exports.skipType = skipType;","map":{"version":3,"names":["TYPE","require","bufrwErrors","errors","TMapHeaderRW","TMapRW","prototype","headerRW","TListHeaderRW","TListRW","widths","Object","create","VOID","BOOL","BYTE","I8","DOUBLE","I16","I32","I64","skipVar","STRUCT","skipStruct","STRING","skipString","MAP","skipMap","SET","skipList","LIST","skipField","destResult","buffer","offset","length","reset","ShortBuffer","expected","actual","typeid","readInt8","skipType","result","undefined","err","InvalidTypeidError","what","STOP","readInt32BE","poolReadFrom","header","value","ktypeid","vtypeid","index","module","exports"],"sources":["/home/bvpelt/Develop/openteltest/node_modules/thriftrw/skip.js"],"sourcesContent":["// Copyright (c) 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint max-statements:[0, 99] */\n'use strict';\n\nvar TYPE = require('./TYPE');\nvar bufrwErrors = require('bufrw/errors');\nvar errors = require('./errors');\nvar TMapHeaderRW = require('./tmap').TMapRW.prototype.headerRW;\nvar TListHeaderRW = require('./tlist').TListRW.prototype.headerRW;\n\nvar widths = Object.create(null);\nwidths[TYPE.VOID] = 0;\nwidths[TYPE.BOOL] = 1;\nwidths[TYPE.BYTE] = 1;\nwidths[TYPE.I8] = 1;\nwidths[TYPE.DOUBLE] = 8;\nwidths[TYPE.I16] = 2;\nwidths[TYPE.I32] = 4;\nwidths[TYPE.I64] = 8;\n\nvar skipVar = Object.create(null);\nskipVar[TYPE.STRUCT] = skipStruct;\nskipVar[TYPE.STRING] = skipString;\nskipVar[TYPE.MAP] = skipMap;\nskipVar[TYPE.SET] = skipList;\nskipVar[TYPE.LIST] = skipList;\n\nfunction skipField(destResult, buffer, offset) {\n\n    // istanbul ignore if\n    if (offset + 1 > buffer.length) {\n        return destResult.reset(bufrwErrors.ShortBuffer({\n            expected: offset + 1,\n            actual: buffer.length,\n            buffer: buffer,\n            offset: offset\n        }), offset);\n    }\n\n    var typeid = buffer.readInt8(offset, true);\n    offset += 1;\n\n    return skipType(destResult, buffer, offset, typeid);\n}\n\nfunction skipType(destResult, buffer, offset, typeid) {\n    var result;\n\n    // istanbul ignore else\n    if (skipVar[typeid] !== undefined) {\n        result = skipVar[typeid](destResult, buffer, offset);\n        // istanbul ignore if\n        if (result.err) {\n            return result;\n        }\n        offset = result.offset;\n\n    } else if (widths[typeid] !== undefined) {\n        var length = widths[typeid];\n        if (offset + length > buffer.length) {\n            return destResult.reset(bufrwErrors.ShortBuffer({\n                expected: offset + length,\n                actual: buffer.length,\n                buffer: buffer,\n                offset: offset\n            }), offset);\n        }\n        offset += length;\n\n    } else {\n        return destResult.reset(errors.InvalidTypeidError({\n            typeid: typeid,\n            what: 'field::type'\n        }), offset);\n    }\n\n    return destResult.reset(null, offset);\n}\n\nfunction skipStruct(destResult, buffer, offset) {\n    var result;\n    for (;;) {\n        // typeid\n        // istanbul ignore if\n        if (offset + 1 > buffer.length) {\n            return destResult.reset(bufrwErrors.ShortBuffer({\n                expected: offset + 1,\n                actual: buffer.length,\n                buffer: buffer,\n                offset: offset\n            }), offset);\n        }\n        var typeid = buffer.readInt8(offset, true);\n        offset += 1;\n\n        if (typeid === TYPE.STOP) {\n            return destResult.reset(null, offset);\n        }\n\n        // id\n        // istanbul ignore if\n        if (offset + 2 > buffer.length) {\n            return destResult.reset(bufrwErrors.ShortBuffer({\n                expected: offset + 2,\n                actual: buffer.length,\n                buffer: buffer,\n                offset: offset\n            }), offset);\n        }\n        offset += 2;\n\n        result = skipType(destResult, buffer, offset, typeid);\n        // istanbul ignore if\n        if (result.err) {\n            return result;\n        }\n        offset = result.offset;\n    }\n}\n\nfunction skipString(destResult, buffer, offset) {\n\n    // istanbul ignore if\n    if (offset + 4 > buffer.length) {\n        return destResult.reset(bufrwErrors.ShortBuffer({\n            expected: offset + 4,\n            actual: buffer.length,\n            buffer: buffer,\n            offset: offset\n        }), offset);\n    }\n\n    var length = buffer.readInt32BE(offset, true);\n    offset += 4;\n\n    // istanbul ignore if\n    if (offset + length > buffer.length) {\n        return destResult.reset(bufrwErrors.ShortBuffer({\n            expected: offset + length,\n            actual: buffer.length,\n            buffer: buffer,\n            offset: offset\n        }), offset);\n    }\n    offset += length;\n\n    return destResult.reset(null, offset);\n}\n\nfunction skipMap(destResult, buffer, offset) {\n    var result;\n\n    // map headers\n    result = TMapHeaderRW.poolReadFrom(destResult, buffer, offset);\n    // istanbul ignore if\n    if (result.err) {\n        return result;\n    }\n    offset = result.offset;\n\n    var header = result.value;\n    var ktypeid = header[0];\n    var vtypeid = header[1];\n    var length = header[2];\n\n    // each entry\n    for (var index = 0; index < length; index++) {\n        result = skipType(destResult, buffer, offset, ktypeid);\n        // istanbul ignore if\n        if (result.err) {\n            return result;\n        }\n        offset = result.offset;\n\n        result = skipType(destResult, buffer, offset, vtypeid);\n        // istanbul ignore if\n        if (result.err) {\n            return result;\n        }\n        offset = result.offset;\n    }\n\n    return destResult.reset(null, offset);\n}\n\nfunction skipList(destResult, buffer, offset) {\n    var result;\n\n    // list/set headers\n    result = TListHeaderRW.poolReadFrom(destResult, buffer, offset);\n    // istanbul ignore if\n    if (result.err) {\n        return result;\n    }\n    offset = result.offset;\n\n    var header = result.value;\n    var vtypeid = header[0];\n    var length = header[1];\n\n    // each value\n    for (var index = 0; index < length; index++) {\n        result = skipType(destResult, buffer, offset, vtypeid);\n        // istanbul ignore if\n        if (result.err) {\n            return result;\n        }\n        offset = result.offset;\n    }\n\n    return destResult.reset(null, offset);\n}\n\nmodule.exports.skipField = skipField;\nmodule.exports.skipType = skipType;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}