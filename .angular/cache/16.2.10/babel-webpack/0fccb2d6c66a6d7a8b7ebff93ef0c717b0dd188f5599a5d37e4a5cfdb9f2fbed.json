{"ast":null,"code":"//     Int64.js\n//\n//     Copyright (c) 2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n/**\n * Support for handling 64-bit int numbers in Javascript (node.js)\n *\n * JS Numbers are IEEE-754 binary double-precision floats, which limits the\n * range of values that can be represented with integer precision to:\n *\n * 2^^53 <= N <= 2^53\n *\n * Int64 objects wrap a node Buffer that holds the 8-bytes of int64 data.  These\n * objects operate directly on the buffer which means that if they are created\n * using an existing buffer then setting the value will modify the Buffer, and\n * vice-versa.\n *\n * Internal Representation\n *\n * The internal buffer format is Big Endian.  I.e. the most-significant byte is\n * at buffer[0], the least-significant at buffer[7].  For the purposes of\n * converting to/from JS native numbers, the value is assumed to be a signed\n * integer stored in 2's complement form.\n *\n * For details about IEEE-754 see:\n * http://en.wikipedia.org/wiki/Double_precision_floating-point_format\n */\n\n// Useful masks and values for bit twiddling\nvar MASK31 = 0x7fffffff,\n  VAL31 = 0x80000000;\nvar MASK32 = 0xffffffff,\n  VAL32 = 0x100000000;\n\n// Map for converting hex octets to strings\nvar _HEX = [];\nfor (var i = 0; i < 256; i++) {\n  _HEX[i] = (i > 0xF ? '' : '0') + i.toString(16);\n}\n\n//\n// Int64\n//\n\n/**\n * Constructor accepts any of the following argument types:\n *\n * new Int64(buffer[, offset=0]) - Existing Buffer with byte offset\n * new Int64(Uint8Array[, offset=0]) - Existing Uint8Array with a byte offset\n * new Int64(string)             - Hex string (throws if n is outside int64 range)\n * new Int64(number)             - Number (throws if n is outside int64 range)\n * new Int64(hi, lo)             - Raw bits as two 32-bit values\n */\nvar Int64 = module.exports = function (a1, a2) {\n  if (a1 instanceof Buffer) {\n    this.buffer = a1;\n    this.offset = a2 || 0;\n  } else if (Object.prototype.toString.call(a1) == '[object Uint8Array]') {\n    // Under Browserify, Buffers can extend Uint8Arrays rather than an\n    // instance of Buffer. We could assume the passed in Uint8Array is actually\n    // a buffer but that won't handle the case where a raw Uint8Array is passed\n    // in. We construct a new Buffer just in case.\n    this.buffer = new Buffer(a1);\n    this.offset = a2 || 0;\n  } else {\n    this.buffer = this.buffer || new Buffer(8);\n    this.offset = 0;\n    this.setValue.apply(this, arguments);\n  }\n};\n\n// Max integer value that JS can accurately represent\nInt64.MAX_INT = Math.pow(2, 53);\n\n// Min integer value that JS can accurately represent\nInt64.MIN_INT = -Math.pow(2, 53);\nInt64.prototype = {\n  constructor: Int64,\n  /**\n   * Do in-place 2's compliment.  See\n   * http://en.wikipedia.org/wiki/Two's_complement\n   */\n  _2scomp: function () {\n    var b = this.buffer,\n      o = this.offset,\n      carry = 1;\n    for (var i = o + 7; i >= o; i--) {\n      var v = (b[i] ^ 0xff) + carry;\n      b[i] = v & 0xff;\n      carry = v >> 8;\n    }\n  },\n  /**\n   * Set the value. Takes any of the following arguments:\n   *\n   * setValue(string) - A hexidecimal string\n   * setValue(number) - Number (throws if n is outside int64 range)\n   * setValue(hi, lo) - Raw bits as two 32-bit values\n   */\n  setValue: function (hi, lo) {\n    var negate = false;\n    if (arguments.length == 1) {\n      if (typeof hi == 'number') {\n        // Simplify bitfield retrieval by using abs() value.  We restore sign\n        // later\n        negate = hi < 0;\n        hi = Math.abs(hi);\n        lo = hi % VAL32;\n        hi = hi / VAL32;\n        if (hi > VAL32) throw new RangeError(hi + ' is outside Int64 range');\n        hi = hi | 0;\n      } else if (typeof hi == 'string') {\n        hi = (hi + '').replace(/^0x/, '');\n        lo = hi.substr(-8);\n        hi = hi.length > 8 ? hi.substr(0, hi.length - 8) : '';\n        hi = parseInt(hi, 16);\n        lo = parseInt(lo, 16);\n      } else {\n        throw new Error(hi + ' must be a Number or String');\n      }\n    }\n\n    // Technically we should throw if hi or lo is outside int32 range here, but\n    // it's not worth the effort. Anything past the 32'nd bit is ignored.\n\n    // Copy bytes to buffer\n    var b = this.buffer,\n      o = this.offset;\n    for (var i = 7; i >= 0; i--) {\n      b[o + i] = lo & 0xff;\n      lo = i == 4 ? hi : lo >>> 8;\n    }\n\n    // Restore sign of passed argument\n    if (negate) this._2scomp();\n  },\n  /**\n   * Convert to a native JS number.\n   *\n   * WARNING: Do not expect this value to be accurate to integer precision for\n   * large (positive or negative) numbers!\n   *\n   * @param allowImprecise If true, no check is performed to verify the\n   * returned value is accurate to integer precision.  If false, imprecise\n   * numbers (very large positive or negative numbers) will be forced to +/-\n   * Infinity.\n   */\n  toNumber: function (allowImprecise) {\n    var b = this.buffer,\n      o = this.offset;\n\n    // Running sum of octets, doing a 2's complement\n    var negate = b[o] & 0x80,\n      x = 0,\n      carry = 1;\n    for (var i = 7, m = 1; i >= 0; i--, m *= 256) {\n      var v = b[o + i];\n\n      // 2's complement for negative numbers\n      if (negate) {\n        v = (v ^ 0xff) + carry;\n        carry = v >> 8;\n        v = v & 0xff;\n      }\n      x += v * m;\n    }\n\n    // Return Infinity if we've lost integer precision\n    if (!allowImprecise && x >= Int64.MAX_INT) {\n      return negate ? -Infinity : Infinity;\n    }\n    return negate ? -x : x;\n  },\n  /**\n   * Convert to a JS Number. Returns +/-Infinity for values that can't be\n   * represented to integer precision.\n   */\n  valueOf: function () {\n    return this.toNumber(false);\n  },\n  /**\n   * Return string value\n   *\n   * @param radix Just like Number#toString()'s radix\n   */\n  toString: function (radix) {\n    return this.valueOf().toString(radix || 10);\n  },\n  /**\n   * Return a string showing the buffer octets, with MSB on the left.\n   *\n   * @param sep separator string. default is '' (empty string)\n   */\n  toOctetString: function (sep) {\n    var out = new Array(8);\n    var b = this.buffer,\n      o = this.offset;\n    for (var i = 0; i < 8; i++) {\n      out[i] = _HEX[b[o + i]];\n    }\n    return out.join(sep || '');\n  },\n  /**\n   * Returns the int64's 8 bytes in a buffer.\n   *\n   * @param {bool} [rawBuffer=false]  If no offset and this is true, return the internal buffer.  Should only be used if\n   *                                  you're discarding the Int64 afterwards, as it breaks encapsulation.\n   */\n  toBuffer: function (rawBuffer) {\n    if (rawBuffer && this.offset === 0) return this.buffer;\n    var out = new Buffer(8);\n    this.buffer.copy(out, 0, this.offset, this.offset + 8);\n    return out;\n  },\n  /**\n   * Copy 8 bytes of int64 into target buffer at target offset.\n   *\n   * @param {Buffer} targetBuffer       Buffer to copy into.\n   * @param {number} [targetOffset=0]   Offset into target buffer.\n   */\n  copy: function (targetBuffer, targetOffset) {\n    this.buffer.copy(targetBuffer, targetOffset || 0, this.offset, this.offset + 8);\n  },\n  /**\n   * Returns a number indicating whether this comes before or after or is the\n   * same as the other in sort order.\n   *\n   * @param {Int64} other  Other Int64 to compare.\n   */\n  compare: function (other) {\n    // If sign bits differ ...\n    if ((this.buffer[this.offset] & 0x80) != (other.buffer[other.offset] & 0x80)) {\n      return other.buffer[other.offset] - this.buffer[this.offset];\n    }\n\n    // otherwise, compare bytes lexicographically\n    for (var i = 0; i < 8; i++) {\n      if (this.buffer[this.offset + i] !== other.buffer[other.offset + i]) {\n        return this.buffer[this.offset + i] - other.buffer[other.offset + i];\n      }\n    }\n    return 0;\n  },\n  /**\n   * Returns a boolean indicating if this integer is equal to other.\n   *\n   * @param {Int64} other  Other Int64 to compare.\n   */\n  equals: function (other) {\n    return this.compare(other) === 0;\n  },\n  /**\n   * Pretty output in console.log\n   */\n  inspect: function () {\n    return '[Int64 value:' + this + ' octets:' + this.toOctetString(' ') + ']';\n  }\n};","map":{"version":3,"names":["MASK31","VAL31","MASK32","VAL32","_HEX","i","toString","Int64","module","exports","a1","a2","Buffer","buffer","offset","Object","prototype","call","setValue","apply","arguments","MAX_INT","Math","pow","MIN_INT","constructor","_2scomp","b","o","carry","v","hi","lo","negate","length","abs","RangeError","replace","substr","parseInt","Error","toNumber","allowImprecise","x","m","Infinity","valueOf","radix","toOctetString","sep","out","Array","join","toBuffer","rawBuffer","copy","targetBuffer","targetOffset","compare","other","equals","inspect"],"sources":["/home/bvpelt/Develop/openteltest/node_modules/node-int64/Int64.js"],"sourcesContent":["//     Int64.js\n//\n//     Copyright (c) 2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n/**\n * Support for handling 64-bit int numbers in Javascript (node.js)\n *\n * JS Numbers are IEEE-754 binary double-precision floats, which limits the\n * range of values that can be represented with integer precision to:\n *\n * 2^^53 <= N <= 2^53\n *\n * Int64 objects wrap a node Buffer that holds the 8-bytes of int64 data.  These\n * objects operate directly on the buffer which means that if they are created\n * using an existing buffer then setting the value will modify the Buffer, and\n * vice-versa.\n *\n * Internal Representation\n *\n * The internal buffer format is Big Endian.  I.e. the most-significant byte is\n * at buffer[0], the least-significant at buffer[7].  For the purposes of\n * converting to/from JS native numbers, the value is assumed to be a signed\n * integer stored in 2's complement form.\n *\n * For details about IEEE-754 see:\n * http://en.wikipedia.org/wiki/Double_precision_floating-point_format\n */\n\n// Useful masks and values for bit twiddling\nvar MASK31 =  0x7fffffff, VAL31 = 0x80000000;\nvar MASK32 =  0xffffffff, VAL32 = 0x100000000;\n\n// Map for converting hex octets to strings\nvar _HEX = [];\nfor (var i = 0; i < 256; i++) {\n  _HEX[i] = (i > 0xF ? '' : '0') + i.toString(16);\n}\n\n//\n// Int64\n//\n\n/**\n * Constructor accepts any of the following argument types:\n *\n * new Int64(buffer[, offset=0]) - Existing Buffer with byte offset\n * new Int64(Uint8Array[, offset=0]) - Existing Uint8Array with a byte offset\n * new Int64(string)             - Hex string (throws if n is outside int64 range)\n * new Int64(number)             - Number (throws if n is outside int64 range)\n * new Int64(hi, lo)             - Raw bits as two 32-bit values\n */\nvar Int64 = module.exports = function(a1, a2) {\n  if (a1 instanceof Buffer) {\n    this.buffer = a1;\n    this.offset = a2 || 0;\n  } else if (Object.prototype.toString.call(a1) == '[object Uint8Array]') {\n    // Under Browserify, Buffers can extend Uint8Arrays rather than an\n    // instance of Buffer. We could assume the passed in Uint8Array is actually\n    // a buffer but that won't handle the case where a raw Uint8Array is passed\n    // in. We construct a new Buffer just in case.\n    this.buffer = new Buffer(a1);\n    this.offset = a2 || 0;\n  } else {\n    this.buffer = this.buffer || new Buffer(8);\n    this.offset = 0;\n    this.setValue.apply(this, arguments);\n  }\n};\n\n\n// Max integer value that JS can accurately represent\nInt64.MAX_INT = Math.pow(2, 53);\n\n// Min integer value that JS can accurately represent\nInt64.MIN_INT = -Math.pow(2, 53);\n\nInt64.prototype = {\n\n  constructor: Int64,\n\n  /**\n   * Do in-place 2's compliment.  See\n   * http://en.wikipedia.org/wiki/Two's_complement\n   */\n  _2scomp: function() {\n    var b = this.buffer, o = this.offset, carry = 1;\n    for (var i = o + 7; i >= o; i--) {\n      var v = (b[i] ^ 0xff) + carry;\n      b[i] = v & 0xff;\n      carry = v >> 8;\n    }\n  },\n\n  /**\n   * Set the value. Takes any of the following arguments:\n   *\n   * setValue(string) - A hexidecimal string\n   * setValue(number) - Number (throws if n is outside int64 range)\n   * setValue(hi, lo) - Raw bits as two 32-bit values\n   */\n  setValue: function(hi, lo) {\n    var negate = false;\n    if (arguments.length == 1) {\n      if (typeof(hi) == 'number') {\n        // Simplify bitfield retrieval by using abs() value.  We restore sign\n        // later\n        negate = hi < 0;\n        hi = Math.abs(hi);\n        lo = hi % VAL32;\n        hi = hi / VAL32;\n        if (hi > VAL32) throw new RangeError(hi  + ' is outside Int64 range');\n        hi = hi | 0;\n      } else if (typeof(hi) == 'string') {\n        hi = (hi + '').replace(/^0x/, '');\n        lo = hi.substr(-8);\n        hi = hi.length > 8 ? hi.substr(0, hi.length - 8) : '';\n        hi = parseInt(hi, 16);\n        lo = parseInt(lo, 16);\n      } else {\n        throw new Error(hi + ' must be a Number or String');\n      }\n    }\n\n    // Technically we should throw if hi or lo is outside int32 range here, but\n    // it's not worth the effort. Anything past the 32'nd bit is ignored.\n\n    // Copy bytes to buffer\n    var b = this.buffer, o = this.offset;\n    for (var i = 7; i >= 0; i--) {\n      b[o+i] = lo & 0xff;\n      lo = i == 4 ? hi : lo >>> 8;\n    }\n\n    // Restore sign of passed argument\n    if (negate) this._2scomp();\n  },\n\n  /**\n   * Convert to a native JS number.\n   *\n   * WARNING: Do not expect this value to be accurate to integer precision for\n   * large (positive or negative) numbers!\n   *\n   * @param allowImprecise If true, no check is performed to verify the\n   * returned value is accurate to integer precision.  If false, imprecise\n   * numbers (very large positive or negative numbers) will be forced to +/-\n   * Infinity.\n   */\n  toNumber: function(allowImprecise) {\n    var b = this.buffer, o = this.offset;\n\n    // Running sum of octets, doing a 2's complement\n    var negate = b[o] & 0x80, x = 0, carry = 1;\n    for (var i = 7, m = 1; i >= 0; i--, m *= 256) {\n      var v = b[o+i];\n\n      // 2's complement for negative numbers\n      if (negate) {\n        v = (v ^ 0xff) + carry;\n        carry = v >> 8;\n        v = v & 0xff;\n      }\n\n      x += v * m;\n    }\n\n    // Return Infinity if we've lost integer precision\n    if (!allowImprecise && x >= Int64.MAX_INT) {\n      return negate ? -Infinity : Infinity;\n    }\n\n    return negate ? -x : x;\n  },\n\n  /**\n   * Convert to a JS Number. Returns +/-Infinity for values that can't be\n   * represented to integer precision.\n   */\n  valueOf: function() {\n    return this.toNumber(false);\n  },\n\n  /**\n   * Return string value\n   *\n   * @param radix Just like Number#toString()'s radix\n   */\n  toString: function(radix) {\n    return this.valueOf().toString(radix || 10);\n  },\n\n  /**\n   * Return a string showing the buffer octets, with MSB on the left.\n   *\n   * @param sep separator string. default is '' (empty string)\n   */\n  toOctetString: function(sep) {\n    var out = new Array(8);\n    var b = this.buffer, o = this.offset;\n    for (var i = 0; i < 8; i++) {\n      out[i] = _HEX[b[o+i]];\n    }\n    return out.join(sep || '');\n  },\n\n  /**\n   * Returns the int64's 8 bytes in a buffer.\n   *\n   * @param {bool} [rawBuffer=false]  If no offset and this is true, return the internal buffer.  Should only be used if\n   *                                  you're discarding the Int64 afterwards, as it breaks encapsulation.\n   */\n  toBuffer: function(rawBuffer) {\n    if (rawBuffer && this.offset === 0) return this.buffer;\n\n    var out = new Buffer(8);\n    this.buffer.copy(out, 0, this.offset, this.offset + 8);\n    return out;\n  },\n\n  /**\n   * Copy 8 bytes of int64 into target buffer at target offset.\n   *\n   * @param {Buffer} targetBuffer       Buffer to copy into.\n   * @param {number} [targetOffset=0]   Offset into target buffer.\n   */\n  copy: function(targetBuffer, targetOffset) {\n    this.buffer.copy(targetBuffer, targetOffset || 0, this.offset, this.offset + 8);\n  },\n\n  /**\n   * Returns a number indicating whether this comes before or after or is the\n   * same as the other in sort order.\n   *\n   * @param {Int64} other  Other Int64 to compare.\n   */\n  compare: function(other) {\n\n    // If sign bits differ ...\n    if ((this.buffer[this.offset] & 0x80) != (other.buffer[other.offset] & 0x80)) {\n      return other.buffer[other.offset] - this.buffer[this.offset];\n    }\n\n    // otherwise, compare bytes lexicographically\n    for (var i = 0; i < 8; i++) {\n      if (this.buffer[this.offset+i] !== other.buffer[other.offset+i]) {\n        return this.buffer[this.offset+i] - other.buffer[other.offset+i];\n      }\n    }\n    return 0;\n  },\n\n  /**\n   * Returns a boolean indicating if this integer is equal to other.\n   *\n   * @param {Int64} other  Other Int64 to compare.\n   */\n  equals: function(other) {\n    return this.compare(other) === 0;\n  },\n\n  /**\n   * Pretty output in console.log\n   */\n  inspect: function() {\n    return '[Int64 value:' + this + ' octets:' + this.toOctetString(' ') + ']';\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}