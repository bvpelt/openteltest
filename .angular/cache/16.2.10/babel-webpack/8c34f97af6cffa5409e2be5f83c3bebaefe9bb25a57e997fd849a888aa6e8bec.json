{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as api from '@opentelemetry/api';\nimport { sanitizeAttributes, isTracingSuppressed } from '@opentelemetry/core';\nimport { Span } from './Span';\nimport { mergeConfig } from './utility';\nimport { RandomIdGenerator } from './platform';\n/**\n * This class represents a basic tracer.\n */\nvar Tracer = /** @class */function () {\n  /**\n   * Constructs a new Tracer instance.\n   */\n  function Tracer(instrumentationLibrary, config, _tracerProvider) {\n    this._tracerProvider = _tracerProvider;\n    var localConfig = mergeConfig(config);\n    this._sampler = localConfig.sampler;\n    this._generalLimits = localConfig.generalLimits;\n    this._spanLimits = localConfig.spanLimits;\n    this._idGenerator = config.idGenerator || new RandomIdGenerator();\n    this.resource = _tracerProvider.resource;\n    this.instrumentationLibrary = instrumentationLibrary;\n  }\n  /**\n   * Starts a new Span or returns the default NoopSpan based on the sampling\n   * decision.\n   */\n  Tracer.prototype.startSpan = function (name, options, context) {\n    var _a, _b, _c;\n    if (options === void 0) {\n      options = {};\n    }\n    if (context === void 0) {\n      context = api.context.active();\n    }\n    // remove span from context in case a root span is requested via options\n    if (options.root) {\n      context = api.trace.deleteSpan(context);\n    }\n    var parentSpan = api.trace.getSpan(context);\n    if (isTracingSuppressed(context)) {\n      api.diag.debug('Instrumentation suppressed, returning Noop Span');\n      var nonRecordingSpan = api.trace.wrapSpanContext(api.INVALID_SPAN_CONTEXT);\n      return nonRecordingSpan;\n    }\n    var parentSpanContext = parentSpan === null || parentSpan === void 0 ? void 0 : parentSpan.spanContext();\n    var spanId = this._idGenerator.generateSpanId();\n    var traceId;\n    var traceState;\n    var parentSpanId;\n    if (!parentSpanContext || !api.trace.isSpanContextValid(parentSpanContext)) {\n      // New root span.\n      traceId = this._idGenerator.generateTraceId();\n    } else {\n      // New child span.\n      traceId = parentSpanContext.traceId;\n      traceState = parentSpanContext.traceState;\n      parentSpanId = parentSpanContext.spanId;\n    }\n    var spanKind = (_a = options.kind) !== null && _a !== void 0 ? _a : api.SpanKind.INTERNAL;\n    var links = ((_b = options.links) !== null && _b !== void 0 ? _b : []).map(function (link) {\n      return {\n        context: link.context,\n        attributes: sanitizeAttributes(link.attributes)\n      };\n    });\n    var attributes = sanitizeAttributes(options.attributes);\n    // make sampling decision\n    var samplingResult = this._sampler.shouldSample(context, traceId, name, spanKind, attributes, links);\n    traceState = (_c = samplingResult.traceState) !== null && _c !== void 0 ? _c : traceState;\n    var traceFlags = samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE;\n    var spanContext = {\n      traceId: traceId,\n      spanId: spanId,\n      traceFlags: traceFlags,\n      traceState: traceState\n    };\n    if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) {\n      api.diag.debug('Recording is off, propagating context in a non-recording span');\n      var nonRecordingSpan = api.trace.wrapSpanContext(spanContext);\n      return nonRecordingSpan;\n    }\n    var span = new Span(this, context, name, spanContext, spanKind, parentSpanId, links, options.startTime);\n    // Set initial span attributes. The attributes object may have been mutated\n    // by the sampler, so we sanitize the merged attributes before setting them.\n    var initAttributes = sanitizeAttributes(Object.assign(attributes, samplingResult.attributes));\n    span.setAttributes(initAttributes);\n    return span;\n  };\n  Tracer.prototype.startActiveSpan = function (name, arg2, arg3, arg4) {\n    var opts;\n    var ctx;\n    var fn;\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2;\n    } else if (arguments.length === 3) {\n      opts = arg2;\n      fn = arg3;\n    } else {\n      opts = arg2;\n      ctx = arg3;\n      fn = arg4;\n    }\n    var parentContext = ctx !== null && ctx !== void 0 ? ctx : api.context.active();\n    var span = this.startSpan(name, opts, parentContext);\n    var contextWithSpanSet = api.trace.setSpan(parentContext, span);\n    return api.context.with(contextWithSpanSet, fn, undefined, span);\n  };\n  /** Returns the active {@link GeneralLimits}. */\n  Tracer.prototype.getGeneralLimits = function () {\n    return this._generalLimits;\n  };\n  /** Returns the active {@link SpanLimits}. */\n  Tracer.prototype.getSpanLimits = function () {\n    return this._spanLimits;\n  };\n  Tracer.prototype.getActiveSpanProcessor = function () {\n    return this._tracerProvider.getActiveSpanProcessor();\n  };\n  return Tracer;\n}();\nexport { Tracer };","map":{"version":3,"names":["api","sanitizeAttributes","isTracingSuppressed","Span","mergeConfig","RandomIdGenerator","Tracer","instrumentationLibrary","config","_tracerProvider","localConfig","_sampler","sampler","_generalLimits","generalLimits","_spanLimits","spanLimits","_idGenerator","idGenerator","resource","prototype","startSpan","name","options","context","_a","_b","_c","active","root","trace","deleteSpan","parentSpan","getSpan","diag","debug","nonRecordingSpan","wrapSpanContext","INVALID_SPAN_CONTEXT","parentSpanContext","spanContext","spanId","generateSpanId","traceId","traceState","parentSpanId","isSpanContextValid","generateTraceId","spanKind","kind","SpanKind","INTERNAL","links","map","link","attributes","samplingResult","shouldSample","traceFlags","decision","SamplingDecision","RECORD_AND_SAMPLED","TraceFlags","SAMPLED","NONE","NOT_RECORD","span","startTime","initAttributes","Object","assign","setAttributes","startActiveSpan","arg2","arg3","arg4","opts","ctx","fn","arguments","length","parentContext","contextWithSpanSet","setSpan","with","undefined","getGeneralLimits","getSpanLimits","getActiveSpanProcessor"],"sources":["/home/bvpelt/Develop/openteltest/node_modules/@opentelemetry/sdk-trace-base/build/esm/Tracer.js"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as api from '@opentelemetry/api';\nimport { sanitizeAttributes, isTracingSuppressed, } from '@opentelemetry/core';\nimport { Span } from './Span';\nimport { mergeConfig } from './utility';\nimport { RandomIdGenerator } from './platform';\n/**\n * This class represents a basic tracer.\n */\nvar Tracer = /** @class */ (function () {\n    /**\n     * Constructs a new Tracer instance.\n     */\n    function Tracer(instrumentationLibrary, config, _tracerProvider) {\n        this._tracerProvider = _tracerProvider;\n        var localConfig = mergeConfig(config);\n        this._sampler = localConfig.sampler;\n        this._generalLimits = localConfig.generalLimits;\n        this._spanLimits = localConfig.spanLimits;\n        this._idGenerator = config.idGenerator || new RandomIdGenerator();\n        this.resource = _tracerProvider.resource;\n        this.instrumentationLibrary = instrumentationLibrary;\n    }\n    /**\n     * Starts a new Span or returns the default NoopSpan based on the sampling\n     * decision.\n     */\n    Tracer.prototype.startSpan = function (name, options, context) {\n        var _a, _b, _c;\n        if (options === void 0) { options = {}; }\n        if (context === void 0) { context = api.context.active(); }\n        // remove span from context in case a root span is requested via options\n        if (options.root) {\n            context = api.trace.deleteSpan(context);\n        }\n        var parentSpan = api.trace.getSpan(context);\n        if (isTracingSuppressed(context)) {\n            api.diag.debug('Instrumentation suppressed, returning Noop Span');\n            var nonRecordingSpan = api.trace.wrapSpanContext(api.INVALID_SPAN_CONTEXT);\n            return nonRecordingSpan;\n        }\n        var parentSpanContext = parentSpan === null || parentSpan === void 0 ? void 0 : parentSpan.spanContext();\n        var spanId = this._idGenerator.generateSpanId();\n        var traceId;\n        var traceState;\n        var parentSpanId;\n        if (!parentSpanContext ||\n            !api.trace.isSpanContextValid(parentSpanContext)) {\n            // New root span.\n            traceId = this._idGenerator.generateTraceId();\n        }\n        else {\n            // New child span.\n            traceId = parentSpanContext.traceId;\n            traceState = parentSpanContext.traceState;\n            parentSpanId = parentSpanContext.spanId;\n        }\n        var spanKind = (_a = options.kind) !== null && _a !== void 0 ? _a : api.SpanKind.INTERNAL;\n        var links = ((_b = options.links) !== null && _b !== void 0 ? _b : []).map(function (link) {\n            return {\n                context: link.context,\n                attributes: sanitizeAttributes(link.attributes),\n            };\n        });\n        var attributes = sanitizeAttributes(options.attributes);\n        // make sampling decision\n        var samplingResult = this._sampler.shouldSample(context, traceId, name, spanKind, attributes, links);\n        traceState = (_c = samplingResult.traceState) !== null && _c !== void 0 ? _c : traceState;\n        var traceFlags = samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED\n            ? api.TraceFlags.SAMPLED\n            : api.TraceFlags.NONE;\n        var spanContext = { traceId: traceId, spanId: spanId, traceFlags: traceFlags, traceState: traceState };\n        if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) {\n            api.diag.debug('Recording is off, propagating context in a non-recording span');\n            var nonRecordingSpan = api.trace.wrapSpanContext(spanContext);\n            return nonRecordingSpan;\n        }\n        var span = new Span(this, context, name, spanContext, spanKind, parentSpanId, links, options.startTime);\n        // Set initial span attributes. The attributes object may have been mutated\n        // by the sampler, so we sanitize the merged attributes before setting them.\n        var initAttributes = sanitizeAttributes(Object.assign(attributes, samplingResult.attributes));\n        span.setAttributes(initAttributes);\n        return span;\n    };\n    Tracer.prototype.startActiveSpan = function (name, arg2, arg3, arg4) {\n        var opts;\n        var ctx;\n        var fn;\n        if (arguments.length < 2) {\n            return;\n        }\n        else if (arguments.length === 2) {\n            fn = arg2;\n        }\n        else if (arguments.length === 3) {\n            opts = arg2;\n            fn = arg3;\n        }\n        else {\n            opts = arg2;\n            ctx = arg3;\n            fn = arg4;\n        }\n        var parentContext = ctx !== null && ctx !== void 0 ? ctx : api.context.active();\n        var span = this.startSpan(name, opts, parentContext);\n        var contextWithSpanSet = api.trace.setSpan(parentContext, span);\n        return api.context.with(contextWithSpanSet, fn, undefined, span);\n    };\n    /** Returns the active {@link GeneralLimits}. */\n    Tracer.prototype.getGeneralLimits = function () {\n        return this._generalLimits;\n    };\n    /** Returns the active {@link SpanLimits}. */\n    Tracer.prototype.getSpanLimits = function () {\n        return this._spanLimits;\n    };\n    Tracer.prototype.getActiveSpanProcessor = function () {\n        return this._tracerProvider.getActiveSpanProcessor();\n    };\n    return Tracer;\n}());\nexport { Tracer };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}