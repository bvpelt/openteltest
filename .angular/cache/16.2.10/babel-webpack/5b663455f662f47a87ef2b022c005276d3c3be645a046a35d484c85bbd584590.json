{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { AggregatorKind } from './types';\nimport { DataPointType } from '../export/MetricData';\nimport { diag } from '@opentelemetry/api';\nimport { InstrumentType } from '../InstrumentDescriptor';\nimport { Buckets } from './exponential-histogram/Buckets';\nimport { getMapping } from './exponential-histogram/mapping/getMapping';\nimport { nextGreaterSquare } from './exponential-histogram/util';\n// HighLow is a utility class used for computing a common scale for\n// two exponential histogram accumulations\nvar HighLow = /** @class */function () {\n  function HighLow(low, high) {\n    this.low = low;\n    this.high = high;\n  }\n  HighLow.combine = function (h1, h2) {\n    return new HighLow(Math.min(h1.low, h2.low), Math.max(h1.high, h2.high));\n  };\n  return HighLow;\n}();\nvar MAX_SCALE = 20;\nvar DEFAULT_MAX_SIZE = 160;\nvar MIN_MAX_SIZE = 2;\nvar ExponentialHistogramAccumulation = /** @class */function () {\n  function ExponentialHistogramAccumulation(startTime, _maxSize, _recordMinMax, _sum, _count, _zeroCount, _min, _max, _positive, _negative, _mapping) {\n    if (startTime === void 0) {\n      startTime = startTime;\n    }\n    if (_maxSize === void 0) {\n      _maxSize = DEFAULT_MAX_SIZE;\n    }\n    if (_recordMinMax === void 0) {\n      _recordMinMax = true;\n    }\n    if (_sum === void 0) {\n      _sum = 0;\n    }\n    if (_count === void 0) {\n      _count = 0;\n    }\n    if (_zeroCount === void 0) {\n      _zeroCount = 0;\n    }\n    if (_min === void 0) {\n      _min = Number.POSITIVE_INFINITY;\n    }\n    if (_max === void 0) {\n      _max = Number.NEGATIVE_INFINITY;\n    }\n    if (_positive === void 0) {\n      _positive = new Buckets();\n    }\n    if (_negative === void 0) {\n      _negative = new Buckets();\n    }\n    if (_mapping === void 0) {\n      _mapping = getMapping(MAX_SCALE);\n    }\n    this.startTime = startTime;\n    this._maxSize = _maxSize;\n    this._recordMinMax = _recordMinMax;\n    this._sum = _sum;\n    this._count = _count;\n    this._zeroCount = _zeroCount;\n    this._min = _min;\n    this._max = _max;\n    this._positive = _positive;\n    this._negative = _negative;\n    this._mapping = _mapping;\n    if (this._maxSize < MIN_MAX_SIZE) {\n      diag.warn(\"Exponential Histogram Max Size set to \" + this._maxSize + \",                 changing to the minimum size of: \" + MIN_MAX_SIZE);\n      this._maxSize = MIN_MAX_SIZE;\n    }\n  }\n  /**\n   * record updates a histogram with a single count\n   * @param {Number} value\n   */\n  ExponentialHistogramAccumulation.prototype.record = function (value) {\n    this.updateByIncrement(value, 1);\n  };\n  /**\n   * Sets the start time for this accumulation\n   * @param {HrTime} startTime\n   */\n  ExponentialHistogramAccumulation.prototype.setStartTime = function (startTime) {\n    this.startTime = startTime;\n  };\n  /**\n   * Returns the datapoint representation of this accumulation\n   * @param {HrTime} startTime\n   */\n  ExponentialHistogramAccumulation.prototype.toPointValue = function () {\n    return {\n      hasMinMax: this._recordMinMax,\n      min: this.min,\n      max: this.max,\n      sum: this.sum,\n      positive: {\n        offset: this.positive.offset,\n        bucketCounts: this.positive.counts()\n      },\n      negative: {\n        offset: this.negative.offset,\n        bucketCounts: this.negative.counts()\n      },\n      count: this.count,\n      scale: this.scale,\n      zeroCount: this.zeroCount\n    };\n  };\n  Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"sum\", {\n    /**\n     * @returns {Number} The sum of values recorded by this accumulation\n     */\n    get: function () {\n      return this._sum;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"min\", {\n    /**\n     * @returns {Number} The minimum value recorded by this accumulation\n     */\n    get: function () {\n      return this._min;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"max\", {\n    /**\n     * @returns {Number} The maximum value recorded by this accumulation\n     */\n    get: function () {\n      return this._max;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"count\", {\n    /**\n     * @returns {Number} The count of values recorded by this accumulation\n     */\n    get: function () {\n      return this._count;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"zeroCount\", {\n    /**\n     * @returns {Number} The number of 0 values recorded by this accumulation\n     */\n    get: function () {\n      return this._zeroCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"scale\", {\n    /**\n     * @returns {Number} The scale used by thie accumulation\n     */\n    get: function () {\n      if (this._count === this._zeroCount) {\n        // all zeros! scale doesn't matter, use zero\n        return 0;\n      }\n      return this._mapping.scale;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"positive\", {\n    /**\n     * positive holds the postive values\n     * @returns {Buckets}\n     */\n    get: function () {\n      return this._positive;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"negative\", {\n    /**\n     * negative holds the negative values by their absolute value\n     * @returns {Buckets}\n     */\n    get: function () {\n      return this._negative;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * uppdateByIncr supports updating a histogram with a non-negative\n   * increment.\n   * @param value\n   * @param increment\n   */\n  ExponentialHistogramAccumulation.prototype.updateByIncrement = function (value, increment) {\n    if (value > this._max) {\n      this._max = value;\n    }\n    if (value < this._min) {\n      this._min = value;\n    }\n    this._count += increment;\n    if (value === 0) {\n      this._zeroCount += increment;\n      return;\n    }\n    this._sum += value * increment;\n    if (value > 0) {\n      this._updateBuckets(this._positive, value, increment);\n    } else {\n      this._updateBuckets(this._negative, -value, increment);\n    }\n  };\n  /**\n   * merge combines data from previous value into self\n   * @param {ExponentialHistogramAccumulation} previous\n   */\n  ExponentialHistogramAccumulation.prototype.merge = function (previous) {\n    if (this._count === 0) {\n      this._min = previous.min;\n      this._max = previous.max;\n    } else if (previous.count !== 0) {\n      if (previous.min < this.min) {\n        this._min = previous.min;\n      }\n      if (previous.max > this.max) {\n        this._max = previous.max;\n      }\n    }\n    this.startTime = previous.startTime;\n    this._sum += previous.sum;\n    this._count += previous.count;\n    this._zeroCount += previous.zeroCount;\n    var minScale = this._minScale(previous);\n    this._downscale(this.scale - minScale);\n    this._mergeBuckets(this.positive, previous, previous.positive, minScale);\n    this._mergeBuckets(this.negative, previous, previous.negative, minScale);\n  };\n  /**\n   * diff substracts other from self\n   * @param {ExponentialHistogramAccumulation} other\n   */\n  ExponentialHistogramAccumulation.prototype.diff = function (other) {\n    this._min = Infinity;\n    this._max = -Infinity;\n    this._sum -= other.sum;\n    this._count -= other.count;\n    this._zeroCount -= other.zeroCount;\n    var minScale = this._minScale(other);\n    this._downscale(this.scale - minScale);\n    this._diffBuckets(this.positive, other, other.positive, minScale);\n    this._diffBuckets(this.negative, other, other.negative, minScale);\n  };\n  /**\n   * clone returns a deep copy of self\n   * @returns {ExponentialHistogramAccumulation}\n   */\n  ExponentialHistogramAccumulation.prototype.clone = function () {\n    return new ExponentialHistogramAccumulation(this.startTime, this._maxSize, this._recordMinMax, this._sum, this._count, this._zeroCount, this._min, this._max, this.positive.clone(), this.negative.clone(), this._mapping);\n  };\n  /**\n   * _updateBuckets maps the incoming value to a bucket index for the current\n   * scale. If the bucket index is outside of the range of the backing array,\n   * it will rescale the backing array and update the mapping for the new scale.\n   */\n  ExponentialHistogramAccumulation.prototype._updateBuckets = function (buckets, value, increment) {\n    var index = this._mapping.mapToIndex(value);\n    // rescale the mapping if needed\n    var rescalingNeeded = false;\n    var high = 0;\n    var low = 0;\n    if (buckets.length === 0) {\n      buckets.indexStart = index;\n      buckets.indexEnd = buckets.indexStart;\n      buckets.indexBase = buckets.indexStart;\n    } else if (index < buckets.indexStart && buckets.indexEnd - index >= this._maxSize) {\n      rescalingNeeded = true;\n      low = index;\n      high = buckets.indexEnd;\n    } else if (index > buckets.indexEnd && index - buckets.indexStart >= this._maxSize) {\n      rescalingNeeded = true;\n      low = buckets.indexStart;\n      high = index;\n    }\n    // rescale and compute index at new scale\n    if (rescalingNeeded) {\n      var change = this._changeScale(high, low);\n      this._downscale(change);\n      index = this._mapping.mapToIndex(value);\n    }\n    this._incrementIndexBy(buckets, index, increment);\n  };\n  /**\n   * _incrementIndexBy increments the count of the bucket specified by `index`.\n   * If the index is outside of the range [buckets.indexStart, buckets.indexEnd]\n   * the boundaries of the backing array will be adjusted and more buckets will\n   * be added if needed.\n   */\n  ExponentialHistogramAccumulation.prototype._incrementIndexBy = function (buckets, index, increment) {\n    if (increment === 0) {\n      // nothing to do for a zero increment, can happen during a merge operation\n      return;\n    }\n    if (index < buckets.indexStart) {\n      var span = buckets.indexEnd - index;\n      if (span >= buckets.backing.length) {\n        this._grow(buckets, span + 1);\n      }\n      buckets.indexStart = index;\n    } else if (index > buckets.indexEnd) {\n      var span = index - buckets.indexStart;\n      if (span >= buckets.backing.length) {\n        this._grow(buckets, span + 1);\n      }\n      buckets.indexEnd = index;\n    }\n    var bucketIndex = index - buckets.indexBase;\n    if (bucketIndex < 0) {\n      bucketIndex += buckets.backing.length;\n    }\n    buckets.incrementBucket(bucketIndex, increment);\n  };\n  /**\n   * grow resizes the backing array by doubling in size up to maxSize.\n   * This extends the array with a bunch of zeros and copies the\n   * existing counts to the same position.\n   */\n  ExponentialHistogramAccumulation.prototype._grow = function (buckets, needed) {\n    var size = buckets.backing.length;\n    var bias = buckets.indexBase - buckets.indexStart;\n    var oldPositiveLimit = size - bias;\n    var newSize = nextGreaterSquare(needed);\n    if (newSize > this._maxSize) {\n      newSize = this._maxSize;\n    }\n    var newPositiveLimit = newSize - bias;\n    buckets.backing.growTo(newSize, oldPositiveLimit, newPositiveLimit);\n  };\n  /**\n   * _changeScale computes how much downscaling is needed by shifting the\n   * high and low values until they are separated by no more than size.\n   */\n  ExponentialHistogramAccumulation.prototype._changeScale = function (high, low) {\n    var change = 0;\n    while (high - low >= this._maxSize) {\n      high >>= 1;\n      low >>= 1;\n      change++;\n    }\n    return change;\n  };\n  /**\n   * _downscale subtracts `change` from the current mapping scale.\n   */\n  ExponentialHistogramAccumulation.prototype._downscale = function (change) {\n    if (change === 0) {\n      return;\n    }\n    if (change < 0) {\n      // Note: this should be impossible. If we get here it's because\n      // there is a bug in the implementation.\n      throw new Error(\"impossible change of scale: \" + this.scale);\n    }\n    var newScale = this._mapping.scale - change;\n    this._positive.downscale(change);\n    this._negative.downscale(change);\n    this._mapping = getMapping(newScale);\n  };\n  /**\n   * _minScale is used by diff and merge to compute an ideal combined scale\n   */\n  ExponentialHistogramAccumulation.prototype._minScale = function (other) {\n    var minScale = Math.min(this.scale, other.scale);\n    var highLowPos = HighLow.combine(this._highLowAtScale(this.positive, this.scale, minScale), this._highLowAtScale(other.positive, other.scale, minScale));\n    var highLowNeg = HighLow.combine(this._highLowAtScale(this.negative, this.scale, minScale), this._highLowAtScale(other.negative, other.scale, minScale));\n    return Math.min(minScale - this._changeScale(highLowPos.high, highLowPos.low), minScale - this._changeScale(highLowNeg.high, highLowNeg.low));\n  };\n  /**\n   * _highLowAtScale is used by diff and merge to compute an ideal combined scale.\n   */\n  ExponentialHistogramAccumulation.prototype._highLowAtScale = function (buckets, currentScale, newScale) {\n    if (buckets.length === 0) {\n      return new HighLow(0, -1);\n    }\n    var shift = currentScale - newScale;\n    return new HighLow(buckets.indexStart >> shift, buckets.indexEnd >> shift);\n  };\n  /**\n   * _mergeBuckets translates index values from another histogram and\n   * adds the values into the corresponding buckets of this histogram.\n   */\n  ExponentialHistogramAccumulation.prototype._mergeBuckets = function (ours, other, theirs, scale) {\n    var theirOffset = theirs.offset;\n    var theirChange = other.scale - scale;\n    for (var i = 0; i < theirs.length; i++) {\n      this._incrementIndexBy(ours, theirOffset + i >> theirChange, theirs.at(i));\n    }\n  };\n  /**\n   * _diffBuckets translates index values from another histogram and\n   * subtracts the values in the corresponding buckets of this histogram.\n   */\n  ExponentialHistogramAccumulation.prototype._diffBuckets = function (ours, other, theirs, scale) {\n    var theirOffset = theirs.offset;\n    var theirChange = other.scale - scale;\n    for (var i = 0; i < theirs.length; i++) {\n      var ourIndex = theirOffset + i >> theirChange;\n      var bucketIndex = ourIndex - ours.indexBase;\n      if (bucketIndex < 0) {\n        bucketIndex += ours.backing.length;\n      }\n      ours.decrementBucket(bucketIndex, theirs.at(i));\n    }\n    ours.trim();\n  };\n  return ExponentialHistogramAccumulation;\n}();\nexport { ExponentialHistogramAccumulation };\n/**\n * Aggregator for ExponentialHistogramAccumlations\n */\nvar ExponentialHistogramAggregator = /** @class */function () {\n  /**\n   * @param _maxSize Maximum number of buckets for each of the positive\n   *    and negative ranges, exclusive of the zero-bucket.\n   * @param _recordMinMax If set to true, min and max will be recorded.\n   *    Otherwise, min and max will not be recorded.\n   */\n  function ExponentialHistogramAggregator(_maxSize, _recordMinMax) {\n    this._maxSize = _maxSize;\n    this._recordMinMax = _recordMinMax;\n    this.kind = AggregatorKind.EXPONENTIAL_HISTOGRAM;\n  }\n  ExponentialHistogramAggregator.prototype.createAccumulation = function (startTime) {\n    return new ExponentialHistogramAccumulation(startTime, this._maxSize, this._recordMinMax);\n  };\n  /**\n   * Return the result of the merge of two exponential histogram accumulations.\n   */\n  ExponentialHistogramAggregator.prototype.merge = function (previous, delta) {\n    var result = delta.clone();\n    result.merge(previous);\n    return result;\n  };\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  ExponentialHistogramAggregator.prototype.diff = function (previous, current) {\n    var result = current.clone();\n    result.diff(previous);\n    return result;\n  };\n  ExponentialHistogramAggregator.prototype.toMetricData = function (descriptor, aggregationTemporality, accumulationByAttributes, endTime) {\n    return {\n      descriptor: descriptor,\n      aggregationTemporality: aggregationTemporality,\n      dataPointType: DataPointType.EXPONENTIAL_HISTOGRAM,\n      dataPoints: accumulationByAttributes.map(function (_a) {\n        var _b = __read(_a, 2),\n          attributes = _b[0],\n          accumulation = _b[1];\n        var pointValue = accumulation.toPointValue();\n        // determine if instrument allows negative values.\n        var allowsNegativeValues = descriptor.type === InstrumentType.UP_DOWN_COUNTER || descriptor.type === InstrumentType.OBSERVABLE_GAUGE || descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;\n        return {\n          attributes: attributes,\n          startTime: accumulation.startTime,\n          endTime: endTime,\n          value: {\n            min: pointValue.hasMinMax ? pointValue.min : undefined,\n            max: pointValue.hasMinMax ? pointValue.max : undefined,\n            sum: !allowsNegativeValues ? pointValue.sum : undefined,\n            positive: {\n              offset: pointValue.positive.offset,\n              bucketCounts: pointValue.positive.bucketCounts\n            },\n            negative: {\n              offset: pointValue.negative.offset,\n              bucketCounts: pointValue.negative.bucketCounts\n            },\n            count: pointValue.count,\n            scale: pointValue.scale,\n            zeroCount: pointValue.zeroCount\n          }\n        };\n      })\n    };\n  };\n  return ExponentialHistogramAggregator;\n}();\nexport { ExponentialHistogramAggregator };","map":{"version":3,"names":["__read","o","n","m","Symbol","iterator","i","call","r","ar","e","next","done","push","value","error","AggregatorKind","DataPointType","diag","InstrumentType","Buckets","getMapping","nextGreaterSquare","HighLow","low","high","combine","h1","h2","Math","min","max","MAX_SCALE","DEFAULT_MAX_SIZE","MIN_MAX_SIZE","ExponentialHistogramAccumulation","startTime","_maxSize","_recordMinMax","_sum","_count","_zeroCount","_min","_max","_positive","_negative","_mapping","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","warn","prototype","record","updateByIncrement","setStartTime","toPointValue","hasMinMax","sum","positive","offset","bucketCounts","counts","negative","count","scale","zeroCount","Object","defineProperty","get","enumerable","configurable","increment","_updateBuckets","merge","previous","minScale","_minScale","_downscale","_mergeBuckets","diff","other","Infinity","_diffBuckets","clone","buckets","index","mapToIndex","rescalingNeeded","length","indexStart","indexEnd","indexBase","change","_changeScale","_incrementIndexBy","span","backing","_grow","bucketIndex","incrementBucket","needed","size","bias","oldPositiveLimit","newSize","newPositiveLimit","growTo","Error","newScale","downscale","highLowPos","_highLowAtScale","highLowNeg","currentScale","shift","ours","theirs","theirOffset","theirChange","at","ourIndex","decrementBucket","trim","ExponentialHistogramAggregator","kind","EXPONENTIAL_HISTOGRAM","createAccumulation","delta","result","current","toMetricData","descriptor","aggregationTemporality","accumulationByAttributes","endTime","dataPointType","dataPoints","map","_a","_b","attributes","accumulation","pointValue","allowsNegativeValues","type","UP_DOWN_COUNTER","OBSERVABLE_GAUGE","OBSERVABLE_UP_DOWN_COUNTER","undefined"],"sources":["/home/bvpelt/Develop/openteltest/node_modules/@opentelemetry/sdk-metrics/build/esm/aggregator/ExponentialHistogram.js"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { AggregatorKind, } from './types';\nimport { DataPointType, } from '../export/MetricData';\nimport { diag } from '@opentelemetry/api';\nimport { InstrumentType } from '../InstrumentDescriptor';\nimport { Buckets } from './exponential-histogram/Buckets';\nimport { getMapping } from './exponential-histogram/mapping/getMapping';\nimport { nextGreaterSquare } from './exponential-histogram/util';\n// HighLow is a utility class used for computing a common scale for\n// two exponential histogram accumulations\nvar HighLow = /** @class */ (function () {\n    function HighLow(low, high) {\n        this.low = low;\n        this.high = high;\n    }\n    HighLow.combine = function (h1, h2) {\n        return new HighLow(Math.min(h1.low, h2.low), Math.max(h1.high, h2.high));\n    };\n    return HighLow;\n}());\nvar MAX_SCALE = 20;\nvar DEFAULT_MAX_SIZE = 160;\nvar MIN_MAX_SIZE = 2;\nvar ExponentialHistogramAccumulation = /** @class */ (function () {\n    function ExponentialHistogramAccumulation(startTime, _maxSize, _recordMinMax, _sum, _count, _zeroCount, _min, _max, _positive, _negative, _mapping) {\n        if (startTime === void 0) { startTime = startTime; }\n        if (_maxSize === void 0) { _maxSize = DEFAULT_MAX_SIZE; }\n        if (_recordMinMax === void 0) { _recordMinMax = true; }\n        if (_sum === void 0) { _sum = 0; }\n        if (_count === void 0) { _count = 0; }\n        if (_zeroCount === void 0) { _zeroCount = 0; }\n        if (_min === void 0) { _min = Number.POSITIVE_INFINITY; }\n        if (_max === void 0) { _max = Number.NEGATIVE_INFINITY; }\n        if (_positive === void 0) { _positive = new Buckets(); }\n        if (_negative === void 0) { _negative = new Buckets(); }\n        if (_mapping === void 0) { _mapping = getMapping(MAX_SCALE); }\n        this.startTime = startTime;\n        this._maxSize = _maxSize;\n        this._recordMinMax = _recordMinMax;\n        this._sum = _sum;\n        this._count = _count;\n        this._zeroCount = _zeroCount;\n        this._min = _min;\n        this._max = _max;\n        this._positive = _positive;\n        this._negative = _negative;\n        this._mapping = _mapping;\n        if (this._maxSize < MIN_MAX_SIZE) {\n            diag.warn(\"Exponential Histogram Max Size set to \" + this._maxSize + \",                 changing to the minimum size of: \" + MIN_MAX_SIZE);\n            this._maxSize = MIN_MAX_SIZE;\n        }\n    }\n    /**\n     * record updates a histogram with a single count\n     * @param {Number} value\n     */\n    ExponentialHistogramAccumulation.prototype.record = function (value) {\n        this.updateByIncrement(value, 1);\n    };\n    /**\n     * Sets the start time for this accumulation\n     * @param {HrTime} startTime\n     */\n    ExponentialHistogramAccumulation.prototype.setStartTime = function (startTime) {\n        this.startTime = startTime;\n    };\n    /**\n     * Returns the datapoint representation of this accumulation\n     * @param {HrTime} startTime\n     */\n    ExponentialHistogramAccumulation.prototype.toPointValue = function () {\n        return {\n            hasMinMax: this._recordMinMax,\n            min: this.min,\n            max: this.max,\n            sum: this.sum,\n            positive: {\n                offset: this.positive.offset,\n                bucketCounts: this.positive.counts(),\n            },\n            negative: {\n                offset: this.negative.offset,\n                bucketCounts: this.negative.counts(),\n            },\n            count: this.count,\n            scale: this.scale,\n            zeroCount: this.zeroCount,\n        };\n    };\n    Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"sum\", {\n        /**\n         * @returns {Number} The sum of values recorded by this accumulation\n         */\n        get: function () {\n            return this._sum;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"min\", {\n        /**\n         * @returns {Number} The minimum value recorded by this accumulation\n         */\n        get: function () {\n            return this._min;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"max\", {\n        /**\n         * @returns {Number} The maximum value recorded by this accumulation\n         */\n        get: function () {\n            return this._max;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"count\", {\n        /**\n         * @returns {Number} The count of values recorded by this accumulation\n         */\n        get: function () {\n            return this._count;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"zeroCount\", {\n        /**\n         * @returns {Number} The number of 0 values recorded by this accumulation\n         */\n        get: function () {\n            return this._zeroCount;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"scale\", {\n        /**\n         * @returns {Number} The scale used by thie accumulation\n         */\n        get: function () {\n            if (this._count === this._zeroCount) {\n                // all zeros! scale doesn't matter, use zero\n                return 0;\n            }\n            return this._mapping.scale;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"positive\", {\n        /**\n         * positive holds the postive values\n         * @returns {Buckets}\n         */\n        get: function () {\n            return this._positive;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ExponentialHistogramAccumulation.prototype, \"negative\", {\n        /**\n         * negative holds the negative values by their absolute value\n         * @returns {Buckets}\n         */\n        get: function () {\n            return this._negative;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * uppdateByIncr supports updating a histogram with a non-negative\n     * increment.\n     * @param value\n     * @param increment\n     */\n    ExponentialHistogramAccumulation.prototype.updateByIncrement = function (value, increment) {\n        if (value > this._max) {\n            this._max = value;\n        }\n        if (value < this._min) {\n            this._min = value;\n        }\n        this._count += increment;\n        if (value === 0) {\n            this._zeroCount += increment;\n            return;\n        }\n        this._sum += value * increment;\n        if (value > 0) {\n            this._updateBuckets(this._positive, value, increment);\n        }\n        else {\n            this._updateBuckets(this._negative, -value, increment);\n        }\n    };\n    /**\n     * merge combines data from previous value into self\n     * @param {ExponentialHistogramAccumulation} previous\n     */\n    ExponentialHistogramAccumulation.prototype.merge = function (previous) {\n        if (this._count === 0) {\n            this._min = previous.min;\n            this._max = previous.max;\n        }\n        else if (previous.count !== 0) {\n            if (previous.min < this.min) {\n                this._min = previous.min;\n            }\n            if (previous.max > this.max) {\n                this._max = previous.max;\n            }\n        }\n        this.startTime = previous.startTime;\n        this._sum += previous.sum;\n        this._count += previous.count;\n        this._zeroCount += previous.zeroCount;\n        var minScale = this._minScale(previous);\n        this._downscale(this.scale - minScale);\n        this._mergeBuckets(this.positive, previous, previous.positive, minScale);\n        this._mergeBuckets(this.negative, previous, previous.negative, minScale);\n    };\n    /**\n     * diff substracts other from self\n     * @param {ExponentialHistogramAccumulation} other\n     */\n    ExponentialHistogramAccumulation.prototype.diff = function (other) {\n        this._min = Infinity;\n        this._max = -Infinity;\n        this._sum -= other.sum;\n        this._count -= other.count;\n        this._zeroCount -= other.zeroCount;\n        var minScale = this._minScale(other);\n        this._downscale(this.scale - minScale);\n        this._diffBuckets(this.positive, other, other.positive, minScale);\n        this._diffBuckets(this.negative, other, other.negative, minScale);\n    };\n    /**\n     * clone returns a deep copy of self\n     * @returns {ExponentialHistogramAccumulation}\n     */\n    ExponentialHistogramAccumulation.prototype.clone = function () {\n        return new ExponentialHistogramAccumulation(this.startTime, this._maxSize, this._recordMinMax, this._sum, this._count, this._zeroCount, this._min, this._max, this.positive.clone(), this.negative.clone(), this._mapping);\n    };\n    /**\n     * _updateBuckets maps the incoming value to a bucket index for the current\n     * scale. If the bucket index is outside of the range of the backing array,\n     * it will rescale the backing array and update the mapping for the new scale.\n     */\n    ExponentialHistogramAccumulation.prototype._updateBuckets = function (buckets, value, increment) {\n        var index = this._mapping.mapToIndex(value);\n        // rescale the mapping if needed\n        var rescalingNeeded = false;\n        var high = 0;\n        var low = 0;\n        if (buckets.length === 0) {\n            buckets.indexStart = index;\n            buckets.indexEnd = buckets.indexStart;\n            buckets.indexBase = buckets.indexStart;\n        }\n        else if (index < buckets.indexStart &&\n            buckets.indexEnd - index >= this._maxSize) {\n            rescalingNeeded = true;\n            low = index;\n            high = buckets.indexEnd;\n        }\n        else if (index > buckets.indexEnd &&\n            index - buckets.indexStart >= this._maxSize) {\n            rescalingNeeded = true;\n            low = buckets.indexStart;\n            high = index;\n        }\n        // rescale and compute index at new scale\n        if (rescalingNeeded) {\n            var change = this._changeScale(high, low);\n            this._downscale(change);\n            index = this._mapping.mapToIndex(value);\n        }\n        this._incrementIndexBy(buckets, index, increment);\n    };\n    /**\n     * _incrementIndexBy increments the count of the bucket specified by `index`.\n     * If the index is outside of the range [buckets.indexStart, buckets.indexEnd]\n     * the boundaries of the backing array will be adjusted and more buckets will\n     * be added if needed.\n     */\n    ExponentialHistogramAccumulation.prototype._incrementIndexBy = function (buckets, index, increment) {\n        if (increment === 0) {\n            // nothing to do for a zero increment, can happen during a merge operation\n            return;\n        }\n        if (index < buckets.indexStart) {\n            var span = buckets.indexEnd - index;\n            if (span >= buckets.backing.length) {\n                this._grow(buckets, span + 1);\n            }\n            buckets.indexStart = index;\n        }\n        else if (index > buckets.indexEnd) {\n            var span = index - buckets.indexStart;\n            if (span >= buckets.backing.length) {\n                this._grow(buckets, span + 1);\n            }\n            buckets.indexEnd = index;\n        }\n        var bucketIndex = index - buckets.indexBase;\n        if (bucketIndex < 0) {\n            bucketIndex += buckets.backing.length;\n        }\n        buckets.incrementBucket(bucketIndex, increment);\n    };\n    /**\n     * grow resizes the backing array by doubling in size up to maxSize.\n     * This extends the array with a bunch of zeros and copies the\n     * existing counts to the same position.\n     */\n    ExponentialHistogramAccumulation.prototype._grow = function (buckets, needed) {\n        var size = buckets.backing.length;\n        var bias = buckets.indexBase - buckets.indexStart;\n        var oldPositiveLimit = size - bias;\n        var newSize = nextGreaterSquare(needed);\n        if (newSize > this._maxSize) {\n            newSize = this._maxSize;\n        }\n        var newPositiveLimit = newSize - bias;\n        buckets.backing.growTo(newSize, oldPositiveLimit, newPositiveLimit);\n    };\n    /**\n     * _changeScale computes how much downscaling is needed by shifting the\n     * high and low values until they are separated by no more than size.\n     */\n    ExponentialHistogramAccumulation.prototype._changeScale = function (high, low) {\n        var change = 0;\n        while (high - low >= this._maxSize) {\n            high >>= 1;\n            low >>= 1;\n            change++;\n        }\n        return change;\n    };\n    /**\n     * _downscale subtracts `change` from the current mapping scale.\n     */\n    ExponentialHistogramAccumulation.prototype._downscale = function (change) {\n        if (change === 0) {\n            return;\n        }\n        if (change < 0) {\n            // Note: this should be impossible. If we get here it's because\n            // there is a bug in the implementation.\n            throw new Error(\"impossible change of scale: \" + this.scale);\n        }\n        var newScale = this._mapping.scale - change;\n        this._positive.downscale(change);\n        this._negative.downscale(change);\n        this._mapping = getMapping(newScale);\n    };\n    /**\n     * _minScale is used by diff and merge to compute an ideal combined scale\n     */\n    ExponentialHistogramAccumulation.prototype._minScale = function (other) {\n        var minScale = Math.min(this.scale, other.scale);\n        var highLowPos = HighLow.combine(this._highLowAtScale(this.positive, this.scale, minScale), this._highLowAtScale(other.positive, other.scale, minScale));\n        var highLowNeg = HighLow.combine(this._highLowAtScale(this.negative, this.scale, minScale), this._highLowAtScale(other.negative, other.scale, minScale));\n        return Math.min(minScale - this._changeScale(highLowPos.high, highLowPos.low), minScale - this._changeScale(highLowNeg.high, highLowNeg.low));\n    };\n    /**\n     * _highLowAtScale is used by diff and merge to compute an ideal combined scale.\n     */\n    ExponentialHistogramAccumulation.prototype._highLowAtScale = function (buckets, currentScale, newScale) {\n        if (buckets.length === 0) {\n            return new HighLow(0, -1);\n        }\n        var shift = currentScale - newScale;\n        return new HighLow(buckets.indexStart >> shift, buckets.indexEnd >> shift);\n    };\n    /**\n     * _mergeBuckets translates index values from another histogram and\n     * adds the values into the corresponding buckets of this histogram.\n     */\n    ExponentialHistogramAccumulation.prototype._mergeBuckets = function (ours, other, theirs, scale) {\n        var theirOffset = theirs.offset;\n        var theirChange = other.scale - scale;\n        for (var i = 0; i < theirs.length; i++) {\n            this._incrementIndexBy(ours, (theirOffset + i) >> theirChange, theirs.at(i));\n        }\n    };\n    /**\n     * _diffBuckets translates index values from another histogram and\n     * subtracts the values in the corresponding buckets of this histogram.\n     */\n    ExponentialHistogramAccumulation.prototype._diffBuckets = function (ours, other, theirs, scale) {\n        var theirOffset = theirs.offset;\n        var theirChange = other.scale - scale;\n        for (var i = 0; i < theirs.length; i++) {\n            var ourIndex = (theirOffset + i) >> theirChange;\n            var bucketIndex = ourIndex - ours.indexBase;\n            if (bucketIndex < 0) {\n                bucketIndex += ours.backing.length;\n            }\n            ours.decrementBucket(bucketIndex, theirs.at(i));\n        }\n        ours.trim();\n    };\n    return ExponentialHistogramAccumulation;\n}());\nexport { ExponentialHistogramAccumulation };\n/**\n * Aggregator for ExponentialHistogramAccumlations\n */\nvar ExponentialHistogramAggregator = /** @class */ (function () {\n    /**\n     * @param _maxSize Maximum number of buckets for each of the positive\n     *    and negative ranges, exclusive of the zero-bucket.\n     * @param _recordMinMax If set to true, min and max will be recorded.\n     *    Otherwise, min and max will not be recorded.\n     */\n    function ExponentialHistogramAggregator(_maxSize, _recordMinMax) {\n        this._maxSize = _maxSize;\n        this._recordMinMax = _recordMinMax;\n        this.kind = AggregatorKind.EXPONENTIAL_HISTOGRAM;\n    }\n    ExponentialHistogramAggregator.prototype.createAccumulation = function (startTime) {\n        return new ExponentialHistogramAccumulation(startTime, this._maxSize, this._recordMinMax);\n    };\n    /**\n     * Return the result of the merge of two exponential histogram accumulations.\n     */\n    ExponentialHistogramAggregator.prototype.merge = function (previous, delta) {\n        var result = delta.clone();\n        result.merge(previous);\n        return result;\n    };\n    /**\n     * Returns a new DELTA aggregation by comparing two cumulative measurements.\n     */\n    ExponentialHistogramAggregator.prototype.diff = function (previous, current) {\n        var result = current.clone();\n        result.diff(previous);\n        return result;\n    };\n    ExponentialHistogramAggregator.prototype.toMetricData = function (descriptor, aggregationTemporality, accumulationByAttributes, endTime) {\n        return {\n            descriptor: descriptor,\n            aggregationTemporality: aggregationTemporality,\n            dataPointType: DataPointType.EXPONENTIAL_HISTOGRAM,\n            dataPoints: accumulationByAttributes.map(function (_a) {\n                var _b = __read(_a, 2), attributes = _b[0], accumulation = _b[1];\n                var pointValue = accumulation.toPointValue();\n                // determine if instrument allows negative values.\n                var allowsNegativeValues = descriptor.type === InstrumentType.UP_DOWN_COUNTER ||\n                    descriptor.type === InstrumentType.OBSERVABLE_GAUGE ||\n                    descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;\n                return {\n                    attributes: attributes,\n                    startTime: accumulation.startTime,\n                    endTime: endTime,\n                    value: {\n                        min: pointValue.hasMinMax ? pointValue.min : undefined,\n                        max: pointValue.hasMinMax ? pointValue.max : undefined,\n                        sum: !allowsNegativeValues ? pointValue.sum : undefined,\n                        positive: {\n                            offset: pointValue.positive.offset,\n                            bucketCounts: pointValue.positive.bucketCounts,\n                        },\n                        negative: {\n                            offset: pointValue.negative.offset,\n                            bucketCounts: pointValue.negative.bucketCounts,\n                        },\n                        count: pointValue.count,\n                        scale: pointValue.scale,\n                        zeroCount: pointValue.zeroCount,\n                    },\n                };\n            }),\n        };\n    };\n    return ExponentialHistogramAggregator;\n}());\nexport { ExponentialHistogramAggregator };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}