{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { AggregatorKind } from './types';\nimport { millisToHrTime, hrTimeToMicroseconds } from '@opentelemetry/core';\nimport { DataPointType } from '../export/MetricData';\nvar LastValueAccumulation = /** @class */function () {\n  function LastValueAccumulation(startTime, _current, sampleTime) {\n    if (_current === void 0) {\n      _current = 0;\n    }\n    if (sampleTime === void 0) {\n      sampleTime = [0, 0];\n    }\n    this.startTime = startTime;\n    this._current = _current;\n    this.sampleTime = sampleTime;\n  }\n  LastValueAccumulation.prototype.record = function (value) {\n    this._current = value;\n    this.sampleTime = millisToHrTime(Date.now());\n  };\n  LastValueAccumulation.prototype.setStartTime = function (startTime) {\n    this.startTime = startTime;\n  };\n  LastValueAccumulation.prototype.toPointValue = function () {\n    return this._current;\n  };\n  return LastValueAccumulation;\n}();\nexport { LastValueAccumulation };\n/** Basic aggregator which calculates a LastValue from individual measurements. */\nvar LastValueAggregator = /** @class */function () {\n  function LastValueAggregator() {\n    this.kind = AggregatorKind.LAST_VALUE;\n  }\n  LastValueAggregator.prototype.createAccumulation = function (startTime) {\n    return new LastValueAccumulation(startTime);\n  };\n  /**\n   * Returns the result of the merge of the given accumulations.\n   *\n   * Return the newly captured (delta) accumulation for LastValueAggregator.\n   */\n  LastValueAggregator.prototype.merge = function (previous, delta) {\n    // nanoseconds may lose precisions.\n    var latestAccumulation = hrTimeToMicroseconds(delta.sampleTime) >= hrTimeToMicroseconds(previous.sampleTime) ? delta : previous;\n    return new LastValueAccumulation(previous.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);\n  };\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   *\n   * A delta aggregation is not meaningful to LastValueAggregator, just return\n   * the newly captured (delta) accumulation for LastValueAggregator.\n   */\n  LastValueAggregator.prototype.diff = function (previous, current) {\n    // nanoseconds may lose precisions.\n    var latestAccumulation = hrTimeToMicroseconds(current.sampleTime) >= hrTimeToMicroseconds(previous.sampleTime) ? current : previous;\n    return new LastValueAccumulation(current.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);\n  };\n  LastValueAggregator.prototype.toMetricData = function (descriptor, aggregationTemporality, accumulationByAttributes, endTime) {\n    return {\n      descriptor: descriptor,\n      aggregationTemporality: aggregationTemporality,\n      dataPointType: DataPointType.GAUGE,\n      dataPoints: accumulationByAttributes.map(function (_a) {\n        var _b = __read(_a, 2),\n          attributes = _b[0],\n          accumulation = _b[1];\n        return {\n          attributes: attributes,\n          startTime: accumulation.startTime,\n          endTime: endTime,\n          value: accumulation.toPointValue()\n        };\n      })\n    };\n  };\n  return LastValueAggregator;\n}();\nexport { LastValueAggregator };","map":{"version":3,"names":["__read","o","n","m","Symbol","iterator","i","call","r","ar","e","next","done","push","value","error","AggregatorKind","millisToHrTime","hrTimeToMicroseconds","DataPointType","LastValueAccumulation","startTime","_current","sampleTime","prototype","record","Date","now","setStartTime","toPointValue","LastValueAggregator","kind","LAST_VALUE","createAccumulation","merge","previous","delta","latestAccumulation","diff","current","toMetricData","descriptor","aggregationTemporality","accumulationByAttributes","endTime","dataPointType","GAUGE","dataPoints","map","_a","_b","attributes","accumulation"],"sources":["/home/bvpelt/Develop/openteltest/node_modules/@opentelemetry/sdk-metrics/build/esm/aggregator/LastValue.js"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { AggregatorKind, } from './types';\nimport { millisToHrTime, hrTimeToMicroseconds } from '@opentelemetry/core';\nimport { DataPointType, } from '../export/MetricData';\nvar LastValueAccumulation = /** @class */ (function () {\n    function LastValueAccumulation(startTime, _current, sampleTime) {\n        if (_current === void 0) { _current = 0; }\n        if (sampleTime === void 0) { sampleTime = [0, 0]; }\n        this.startTime = startTime;\n        this._current = _current;\n        this.sampleTime = sampleTime;\n    }\n    LastValueAccumulation.prototype.record = function (value) {\n        this._current = value;\n        this.sampleTime = millisToHrTime(Date.now());\n    };\n    LastValueAccumulation.prototype.setStartTime = function (startTime) {\n        this.startTime = startTime;\n    };\n    LastValueAccumulation.prototype.toPointValue = function () {\n        return this._current;\n    };\n    return LastValueAccumulation;\n}());\nexport { LastValueAccumulation };\n/** Basic aggregator which calculates a LastValue from individual measurements. */\nvar LastValueAggregator = /** @class */ (function () {\n    function LastValueAggregator() {\n        this.kind = AggregatorKind.LAST_VALUE;\n    }\n    LastValueAggregator.prototype.createAccumulation = function (startTime) {\n        return new LastValueAccumulation(startTime);\n    };\n    /**\n     * Returns the result of the merge of the given accumulations.\n     *\n     * Return the newly captured (delta) accumulation for LastValueAggregator.\n     */\n    LastValueAggregator.prototype.merge = function (previous, delta) {\n        // nanoseconds may lose precisions.\n        var latestAccumulation = hrTimeToMicroseconds(delta.sampleTime) >=\n            hrTimeToMicroseconds(previous.sampleTime)\n            ? delta\n            : previous;\n        return new LastValueAccumulation(previous.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);\n    };\n    /**\n     * Returns a new DELTA aggregation by comparing two cumulative measurements.\n     *\n     * A delta aggregation is not meaningful to LastValueAggregator, just return\n     * the newly captured (delta) accumulation for LastValueAggregator.\n     */\n    LastValueAggregator.prototype.diff = function (previous, current) {\n        // nanoseconds may lose precisions.\n        var latestAccumulation = hrTimeToMicroseconds(current.sampleTime) >=\n            hrTimeToMicroseconds(previous.sampleTime)\n            ? current\n            : previous;\n        return new LastValueAccumulation(current.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);\n    };\n    LastValueAggregator.prototype.toMetricData = function (descriptor, aggregationTemporality, accumulationByAttributes, endTime) {\n        return {\n            descriptor: descriptor,\n            aggregationTemporality: aggregationTemporality,\n            dataPointType: DataPointType.GAUGE,\n            dataPoints: accumulationByAttributes.map(function (_a) {\n                var _b = __read(_a, 2), attributes = _b[0], accumulation = _b[1];\n                return {\n                    attributes: attributes,\n                    startTime: accumulation.startTime,\n                    endTime: endTime,\n                    value: accumulation.toPointValue(),\n                };\n            }),\n        };\n    };\n    return LastValueAggregator;\n}());\nexport { LastValueAggregator };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}