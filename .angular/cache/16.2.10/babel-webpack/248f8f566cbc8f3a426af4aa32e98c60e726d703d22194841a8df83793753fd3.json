{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Functions = require(\"./functions\");\nvar Noop = require(\"./noop\");\nvar span_1 = require(\"./span\");\n/**\n * Tracer is the entry-point between the instrumentation API and the tracing\n * implementation.\n *\n * The default object acts as a no-op implementation.\n *\n * Note to implementators: derived classes can choose to directly implement the\n * methods in the \"OpenTracing API methods\" section, or optionally the subset of\n * underscore-prefixed methods to pick up the argument checking and handling\n * automatically from the base class.\n */\nvar Tracer = /** @class */function () {\n  function Tracer() {}\n  // ---------------------------------------------------------------------- //\n  // OpenTracing API methods\n  // ---------------------------------------------------------------------- //\n  /**\n   * Starts and returns a new Span representing a logical unit of work.\n   *\n   * For example:\n   *\n   *     // Start a new (parentless) root Span:\n   *     var parent = Tracer.startSpan('DoWork');\n   *\n   *     // Start a new (child) Span:\n   *     var child = Tracer.startSpan('load-from-db', {\n   *         childOf: parent.context(),\n   *     });\n   *\n   *     // Start a new async (FollowsFrom) Span:\n   *     var child = Tracer.startSpan('async-cache-write', {\n   *         references: [\n   *             opentracing.followsFrom(parent.context())\n   *         ],\n   *     });\n   *\n   * @param {string} name - the name of the operation (REQUIRED).\n   * @param {SpanOptions} [options] - options for the newly created span.\n   * @return {Span} - a new Span object.\n   */\n  Tracer.prototype.startSpan = function (name, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    // Convert options.childOf to fields.references as needed.\n    if (options.childOf) {\n      // Convert from a Span or a SpanContext into a Reference.\n      var childOf = Functions.childOf(options.childOf);\n      if (options.references) {\n        options.references.push(childOf);\n      } else {\n        options.references = [childOf];\n      }\n      delete options.childOf;\n    }\n    return this._startSpan(name, options);\n  };\n  /**\n   * Injects the given SpanContext instance for cross-process propagation\n   * within `carrier`. The expected type of `carrier` depends on the value of\n   * `format.\n   *\n   * OpenTracing defines a common set of `format` values (see\n   * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n   * an expected carrier type.\n   *\n   * Consider this pseudocode example:\n   *\n   *     var clientSpan = ...;\n   *     ...\n   *     // Inject clientSpan into a text carrier.\n   *     var headersCarrier = {};\n   *     Tracer.inject(clientSpan.context(), Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n   *     // Incorporate the textCarrier into the outbound HTTP request header\n   *     // map.\n   *     Object.assign(outboundHTTPReq.headers, headersCarrier);\n   *     // ... send the httpReq\n   *\n   * @param  {SpanContext} spanContext - the SpanContext to inject into the\n   *         carrier object. As a convenience, a Span instance may be passed\n   *         in instead (in which case its .context() is used for the\n   *         inject()).\n   * @param  {string} format - the format of the carrier.\n   * @param  {any} carrier - see the documentation for the chosen `format`\n   *         for a description of the carrier object.\n   */\n  Tracer.prototype.inject = function (spanContext, format, carrier) {\n    // Allow the user to pass a Span instead of a SpanContext\n    if (spanContext instanceof span_1.default) {\n      spanContext = spanContext.context();\n    }\n    return this._inject(spanContext, format, carrier);\n  };\n  /**\n   * Returns a SpanContext instance extracted from `carrier` in the given\n   * `format`.\n   *\n   * OpenTracing defines a common set of `format` values (see\n   * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n   * an expected carrier type.\n   *\n   * Consider this pseudocode example:\n   *\n   *     // Use the inbound HTTP request's headers as a text map carrier.\n   *     var headersCarrier = inboundHTTPReq.headers;\n   *     var wireCtx = Tracer.extract(Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n   *     var serverSpan = Tracer.startSpan('...', { childOf : wireCtx });\n   *\n   * @param  {string} format - the format of the carrier.\n   * @param  {any} carrier - the type of the carrier object is determined by\n   *         the format.\n   * @return {SpanContext}\n   *         The extracted SpanContext, or null if no such SpanContext could\n   *         be found in `carrier`\n   */\n  Tracer.prototype.extract = function (format, carrier) {\n    return this._extract(format, carrier);\n  };\n  // ---------------------------------------------------------------------- //\n  // Derived classes can choose to implement the below\n  // ---------------------------------------------------------------------- //\n  // NOTE: the input to this method is *always* an associative array. The\n  // public-facing startSpan() method normalizes the arguments so that\n  // all N implementations do not need to worry about variations in the call\n  // signature.\n  //\n  // The default behavior returns a no-op span.\n  Tracer.prototype._startSpan = function (name, fields) {\n    return Noop.span;\n  };\n  // The default behavior is a no-op.\n  Tracer.prototype._inject = function (spanContext, format, carrier) {};\n  // The default behavior is to return a no-op SpanContext.\n  Tracer.prototype._extract = function (format, carrier) {\n    return Noop.spanContext;\n  };\n  return Tracer;\n}();\nexports.Tracer = Tracer;\nexports.default = Tracer;","map":{"version":3,"names":["Object","defineProperty","exports","value","Functions","require","Noop","span_1","Tracer","prototype","startSpan","name","options","childOf","references","push","_startSpan","inject","spanContext","format","carrier","default","context","_inject","extract","_extract","fields","span"],"sources":["/home/bvpelt/Develop/openteltest/node_modules/opentracing/lib/tracer.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Functions = require(\"./functions\");\nvar Noop = require(\"./noop\");\nvar span_1 = require(\"./span\");\n/**\n * Tracer is the entry-point between the instrumentation API and the tracing\n * implementation.\n *\n * The default object acts as a no-op implementation.\n *\n * Note to implementators: derived classes can choose to directly implement the\n * methods in the \"OpenTracing API methods\" section, or optionally the subset of\n * underscore-prefixed methods to pick up the argument checking and handling\n * automatically from the base class.\n */\nvar Tracer = /** @class */ (function () {\n    function Tracer() {\n    }\n    // ---------------------------------------------------------------------- //\n    // OpenTracing API methods\n    // ---------------------------------------------------------------------- //\n    /**\n     * Starts and returns a new Span representing a logical unit of work.\n     *\n     * For example:\n     *\n     *     // Start a new (parentless) root Span:\n     *     var parent = Tracer.startSpan('DoWork');\n     *\n     *     // Start a new (child) Span:\n     *     var child = Tracer.startSpan('load-from-db', {\n     *         childOf: parent.context(),\n     *     });\n     *\n     *     // Start a new async (FollowsFrom) Span:\n     *     var child = Tracer.startSpan('async-cache-write', {\n     *         references: [\n     *             opentracing.followsFrom(parent.context())\n     *         ],\n     *     });\n     *\n     * @param {string} name - the name of the operation (REQUIRED).\n     * @param {SpanOptions} [options] - options for the newly created span.\n     * @return {Span} - a new Span object.\n     */\n    Tracer.prototype.startSpan = function (name, options) {\n        if (options === void 0) { options = {}; }\n        // Convert options.childOf to fields.references as needed.\n        if (options.childOf) {\n            // Convert from a Span or a SpanContext into a Reference.\n            var childOf = Functions.childOf(options.childOf);\n            if (options.references) {\n                options.references.push(childOf);\n            }\n            else {\n                options.references = [childOf];\n            }\n            delete (options.childOf);\n        }\n        return this._startSpan(name, options);\n    };\n    /**\n     * Injects the given SpanContext instance for cross-process propagation\n     * within `carrier`. The expected type of `carrier` depends on the value of\n     * `format.\n     *\n     * OpenTracing defines a common set of `format` values (see\n     * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n     * an expected carrier type.\n     *\n     * Consider this pseudocode example:\n     *\n     *     var clientSpan = ...;\n     *     ...\n     *     // Inject clientSpan into a text carrier.\n     *     var headersCarrier = {};\n     *     Tracer.inject(clientSpan.context(), Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n     *     // Incorporate the textCarrier into the outbound HTTP request header\n     *     // map.\n     *     Object.assign(outboundHTTPReq.headers, headersCarrier);\n     *     // ... send the httpReq\n     *\n     * @param  {SpanContext} spanContext - the SpanContext to inject into the\n     *         carrier object. As a convenience, a Span instance may be passed\n     *         in instead (in which case its .context() is used for the\n     *         inject()).\n     * @param  {string} format - the format of the carrier.\n     * @param  {any} carrier - see the documentation for the chosen `format`\n     *         for a description of the carrier object.\n     */\n    Tracer.prototype.inject = function (spanContext, format, carrier) {\n        // Allow the user to pass a Span instead of a SpanContext\n        if (spanContext instanceof span_1.default) {\n            spanContext = spanContext.context();\n        }\n        return this._inject(spanContext, format, carrier);\n    };\n    /**\n     * Returns a SpanContext instance extracted from `carrier` in the given\n     * `format`.\n     *\n     * OpenTracing defines a common set of `format` values (see\n     * FORMAT_TEXT_MAP, FORMAT_HTTP_HEADERS, and FORMAT_BINARY), and each has\n     * an expected carrier type.\n     *\n     * Consider this pseudocode example:\n     *\n     *     // Use the inbound HTTP request's headers as a text map carrier.\n     *     var headersCarrier = inboundHTTPReq.headers;\n     *     var wireCtx = Tracer.extract(Tracer.FORMAT_HTTP_HEADERS, headersCarrier);\n     *     var serverSpan = Tracer.startSpan('...', { childOf : wireCtx });\n     *\n     * @param  {string} format - the format of the carrier.\n     * @param  {any} carrier - the type of the carrier object is determined by\n     *         the format.\n     * @return {SpanContext}\n     *         The extracted SpanContext, or null if no such SpanContext could\n     *         be found in `carrier`\n     */\n    Tracer.prototype.extract = function (format, carrier) {\n        return this._extract(format, carrier);\n    };\n    // ---------------------------------------------------------------------- //\n    // Derived classes can choose to implement the below\n    // ---------------------------------------------------------------------- //\n    // NOTE: the input to this method is *always* an associative array. The\n    // public-facing startSpan() method normalizes the arguments so that\n    // all N implementations do not need to worry about variations in the call\n    // signature.\n    //\n    // The default behavior returns a no-op span.\n    Tracer.prototype._startSpan = function (name, fields) {\n        return Noop.span;\n    };\n    // The default behavior is a no-op.\n    Tracer.prototype._inject = function (spanContext, format, carrier) {\n    };\n    // The default behavior is to return a no-op SpanContext.\n    Tracer.prototype._extract = function (format, carrier) {\n        return Noop.spanContext;\n    };\n    return Tracer;\n}());\nexports.Tracer = Tracer;\nexports.default = Tracer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}