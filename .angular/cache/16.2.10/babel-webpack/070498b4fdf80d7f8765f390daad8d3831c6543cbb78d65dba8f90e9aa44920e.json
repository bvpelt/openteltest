{"ast":null,"code":"// Copyright (c) 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint max-statements:[0, 99] */\n'use strict';\n\nvar TYPE = require('./TYPE');\nvar bufrwErrors = require('bufrw/errors');\nvar bufrw = require('bufrw');\nvar errors = require('./errors');\nvar TMapHeaderRW = require('./tmap').TMapRW.prototype.headerRW;\nvar TListHeaderRW = require('./tlist').TListRW.prototype.headerRW;\nvar StringRW = require('./string').StringRW;\nvar BooleanRW = require('./boolean').BooleanRW;\nvar widths = Object.create(null);\nwidths[TYPE.VOID] = 0;\nvar readVar = Object.create(null);\nreadVar[TYPE.BOOL] = readBool;\nreadVar[TYPE.BYTE] = readI8;\nreadVar[TYPE.DOUBLE] = readDouble;\nreadVar[TYPE.I8] = readI8;\nreadVar[TYPE.I16] = readI16;\nreadVar[TYPE.I32] = readI32;\nreadVar[TYPE.I64] = readI64;\nreadVar[TYPE.STRING] = readString;\nreadVar[TYPE.STRUCT] = readStruct;\nreadVar[TYPE.MAP] = readMap;\nreadVar[TYPE.SET] = readList;\nreadVar[TYPE.LIST] = readList;\nfunction readType(destResult, buffer, offset, typeid) {\n  var result;\n\n  // istanbul ignore else\n  if (readVar[typeid] !== undefined) {\n    result = readVar[typeid](destResult, buffer, offset);\n    // istanbul ignore if\n    if (result.err) {\n      return result;\n    }\n    offset = result.offset;\n  } else if (widths[typeid] !== undefined) {\n    var length = widths[typeid];\n    if (offset + length > buffer.length) {\n      return destResult.reset(bufrwErrors.ShortBuffer({\n        expected: offset + length,\n        actual: buffer.length,\n        buffer: buffer,\n        offset: offset\n      }), offset);\n    }\n    offset += length;\n  } else {\n    return destResult.reset(errors.InvalidTypeidError({\n      typeid: typeid,\n      what: 'field::type'\n    }), offset);\n  }\n  return destResult.reset(null, offset, result && result.value);\n}\nfunction readBool(destResult, buffer, offset) {\n  return BooleanRW.poolReadFrom(destResult, buffer, offset);\n}\nfunction readDouble(destResult, buffer, offset) {\n  return bufrw.DoubleBE.poolReadFrom(destResult, buffer, offset);\n}\nfunction readI8(destResult, buffer, offset) {\n  return bufrw.Int8.poolReadFrom(destResult, buffer, offset);\n}\nfunction readI16(destResult, buffer, offset) {\n  return bufrw.Int16BE.poolReadFrom(destResult, buffer, offset);\n}\nfunction readI32(destResult, buffer, offset) {\n  return bufrw.Int32BE.poolReadFrom(destResult, buffer, offset);\n}\nvar fix8 = bufrw.FixedWidth(8);\nfunction readI64(destResult, buffer, offset) {\n  return fix8.poolReadFrom(destResult, buffer, offset);\n}\nfunction readString(destResult, buffer, offset) {\n  return StringRW.poolReadFrom(destResult, buffer, offset);\n}\nfunction readStruct(destResult, buffer, offset) {\n  var result;\n  var struct = {};\n  for (;;) {\n    result = bufrw.Int8.poolReadFrom(destResult, buffer, offset);\n    // istanbul ignore if\n    if (result.err) {\n      return result;\n    }\n    offset = result.offset;\n    var typeid = result.value;\n    if (typeid === TYPE.STOP) {\n      return destResult.reset(null, offset, struct);\n    }\n    result = bufrw.Int16BE.poolReadFrom(destResult, buffer, offset);\n    // istanbul ignore if\n    if (result.err) {\n      return result;\n    }\n    offset = result.offset;\n    var id = result.value;\n    result = readType(destResult, buffer, offset, typeid);\n    struct[id] = result.value;\n    // istanbul ignore if\n    if (result.err) {\n      return result;\n    }\n    offset = result.offset;\n  }\n}\nfunction readMap(destResult, buffer, offset) {\n  var result;\n  var map = {};\n  var key;\n\n  // map headers\n  result = TMapHeaderRW.poolReadFrom(destResult, buffer, offset);\n  // istanbul ignore if\n  if (result.err) {\n    return result;\n  }\n  offset = result.offset;\n  var header = result.value;\n  var ktypeid = header[0];\n  var vtypeid = header[1];\n  var length = header[2];\n\n  // each entry\n  for (var index = 0; index < length; index++) {\n    result = readType(destResult, buffer, offset, ktypeid);\n    // istanbul ignore if\n    if (result.err) {\n      return result;\n    }\n    offset = result.offset;\n    key = result.value;\n    result = readType(destResult, buffer, offset, vtypeid);\n    // istanbul ignore if\n    if (result.err) {\n      return result;\n    }\n    offset = result.offset;\n    map[key] = result.value;\n  }\n  return destResult.reset(null, offset, map);\n}\nfunction readList(destResult, buffer, offset) {\n  var result;\n  var list = [];\n  // list/set headers\n  result = TListHeaderRW.poolReadFrom(destResult, buffer, offset);\n  // istanbul ignore if\n  if (result.err) {\n    return result;\n  }\n  offset = result.offset;\n  var header = result.value;\n  var vtypeid = header[0];\n  var length = header[1];\n\n  // each value\n  for (var index = 0; index < length; index++) {\n    result = readType(destResult, buffer, offset, vtypeid);\n    // istanbul ignore if\n    if (result.err) {\n      return result;\n    }\n    offset = result.offset;\n    list.push(result.value);\n  }\n  return destResult.reset(null, offset, list);\n}\nmodule.exports.readType = readType;","map":{"version":3,"names":["TYPE","require","bufrwErrors","bufrw","errors","TMapHeaderRW","TMapRW","prototype","headerRW","TListHeaderRW","TListRW","StringRW","BooleanRW","widths","Object","create","VOID","readVar","BOOL","readBool","BYTE","readI8","DOUBLE","readDouble","I8","I16","readI16","I32","readI32","I64","readI64","STRING","readString","STRUCT","readStruct","MAP","readMap","SET","readList","LIST","readType","destResult","buffer","offset","typeid","result","undefined","err","length","reset","ShortBuffer","expected","actual","InvalidTypeidError","what","value","poolReadFrom","DoubleBE","Int8","Int16BE","Int32BE","fix8","FixedWidth","struct","STOP","id","map","key","header","ktypeid","vtypeid","index","list","push","module","exports"],"sources":["/home/bvpelt/Develop/openteltest/node_modules/thriftrw/read.js"],"sourcesContent":["// Copyright (c) 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint max-statements:[0, 99] */\n'use strict';\n\nvar TYPE = require('./TYPE');\nvar bufrwErrors = require('bufrw/errors');\nvar bufrw = require('bufrw');\nvar errors = require('./errors');\nvar TMapHeaderRW = require('./tmap').TMapRW.prototype.headerRW;\nvar TListHeaderRW = require('./tlist').TListRW.prototype.headerRW;\nvar StringRW = require('./string').StringRW;\nvar BooleanRW = require('./boolean').BooleanRW;\n\nvar widths = Object.create(null);\nwidths[TYPE.VOID] = 0;\n\nvar readVar = Object.create(null);\nreadVar[TYPE.BOOL] = readBool;\nreadVar[TYPE.BYTE] = readI8;\nreadVar[TYPE.DOUBLE] = readDouble;\nreadVar[TYPE.I8] = readI8;\nreadVar[TYPE.I16] = readI16;\nreadVar[TYPE.I32] = readI32;\nreadVar[TYPE.I64] = readI64;\nreadVar[TYPE.STRING] = readString;\nreadVar[TYPE.STRUCT] = readStruct;\nreadVar[TYPE.MAP] = readMap;\nreadVar[TYPE.SET] = readList;\nreadVar[TYPE.LIST] = readList;\n\nfunction readType(destResult, buffer, offset, typeid) {\n    var result;\n\n    // istanbul ignore else\n    if (readVar[typeid] !== undefined) {\n        result = readVar[typeid](destResult, buffer, offset);\n        // istanbul ignore if\n        if (result.err) {\n            return result;\n        }\n        offset = result.offset;\n\n    } else if (widths[typeid] !== undefined) {\n        var length = widths[typeid];\n        if (offset + length > buffer.length) {\n            return destResult.reset(bufrwErrors.ShortBuffer({\n                expected: offset + length,\n                actual: buffer.length,\n                buffer: buffer,\n                offset: offset\n            }), offset);\n        }\n        offset += length;\n\n    } else {\n        return destResult.reset(errors.InvalidTypeidError({\n            typeid: typeid,\n            what: 'field::type'\n        }), offset);\n    }\n\n    return destResult.reset(null, offset, result && result.value);\n}\n\nfunction readBool(destResult, buffer, offset) {\n    return BooleanRW.poolReadFrom(destResult, buffer, offset);\n}\n\nfunction readDouble(destResult, buffer, offset) {\n    return bufrw.DoubleBE.poolReadFrom(destResult, buffer, offset);\n}\n\nfunction readI8(destResult, buffer, offset) {\n    return bufrw.Int8.poolReadFrom(destResult, buffer, offset);\n}\n\nfunction readI16(destResult, buffer, offset) {\n    return bufrw.Int16BE.poolReadFrom(destResult, buffer, offset);\n}\n\nfunction readI32(destResult, buffer, offset) {\n    return bufrw.Int32BE.poolReadFrom(destResult, buffer, offset);\n}\n\nvar fix8 = bufrw.FixedWidth(8);\nfunction readI64(destResult, buffer, offset) {\n    return fix8.poolReadFrom(destResult, buffer, offset);\n}\n\nfunction readString(destResult, buffer, offset) {\n    return StringRW.poolReadFrom(destResult, buffer, offset);\n}\n\nfunction readStruct(destResult, buffer, offset) {\n    var result;\n    var struct = {};\n    for (;;) {\n        result = bufrw.Int8.poolReadFrom(destResult, buffer, offset);\n        // istanbul ignore if\n        if (result.err) {\n            return result;\n        }\n        offset = result.offset;\n        var typeid = result.value;\n\n        if (typeid === TYPE.STOP) {\n            return destResult.reset(null, offset, struct);\n        }\n\n        result = bufrw.Int16BE.poolReadFrom(destResult, buffer, offset);\n        // istanbul ignore if\n        if (result.err) {\n            return result;\n        }\n        offset = result.offset;\n        var id = result.value;\n\n        result = readType(destResult, buffer, offset, typeid);\n        struct[id] = result.value;\n        // istanbul ignore if\n        if (result.err) {\n            return result;\n        }\n        offset = result.offset;\n    }\n}\n\nfunction readMap(destResult, buffer, offset) {\n    var result;\n    var map = {};\n    var key;\n\n    // map headers\n    result = TMapHeaderRW.poolReadFrom(destResult, buffer, offset);\n    // istanbul ignore if\n    if (result.err) {\n        return result;\n    }\n    offset = result.offset;\n\n    var header = result.value;\n    var ktypeid = header[0];\n    var vtypeid = header[1];\n    var length = header[2];\n\n    // each entry\n    for (var index = 0; index < length; index++) {\n        result = readType(destResult, buffer, offset, ktypeid);\n        // istanbul ignore if\n        if (result.err) {\n            return result;\n        }\n        offset = result.offset;\n        key = result.value;\n\n        result = readType(destResult, buffer, offset, vtypeid);\n        // istanbul ignore if\n        if (result.err) {\n            return result;\n        }\n        offset = result.offset;\n        map[key] = result.value;\n    }\n\n    return destResult.reset(null, offset, map);\n}\n\nfunction readList(destResult, buffer, offset) {\n    var result;\n    var list = [];\n    // list/set headers\n    result = TListHeaderRW.poolReadFrom(destResult, buffer, offset);\n    // istanbul ignore if\n    if (result.err) {\n        return result;\n    }\n    offset = result.offset;\n\n    var header = result.value;\n    var vtypeid = header[0];\n    var length = header[1];\n\n    // each value\n    for (var index = 0; index < length; index++) {\n        result = readType(destResult, buffer, offset, vtypeid);\n        // istanbul ignore if\n        if (result.err) {\n            return result;\n        }\n        offset = result.offset;\n        list.push(result.value);\n    }\n\n    return destResult.reset(null, offset, list);\n}\n\nmodule.exports.readType = readType;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}