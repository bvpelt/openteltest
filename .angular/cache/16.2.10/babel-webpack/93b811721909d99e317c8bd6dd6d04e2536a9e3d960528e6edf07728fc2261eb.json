{"ast":null,"code":"// Copyright (c) 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint max-len:[0, 120] */\n/* eslint max-statements:[0, 99] */\n/* eslint complexity:[0, 16] */\n'use strict';\n\nvar assert = require('assert');\nvar bufrw = require('bufrw');\nvar RW = require('./rw');\nvar TYPE = require('./TYPE');\nvar NAMES = require('./names');\nvar errors = require('./errors');\nvar skipType = require('./skip').skipType;\nvar util = require('util');\nvar ThriftUnrecognizedException = require('./unrecognized-exception').ThriftUnrecognizedException;\nvar readType = require('./read').readType;\nfunction ThriftField(def, struct) {\n  assert(def.isResult || def.id.value > 0, 'field identifier must be greater than 0' + ' for ' + JSON.stringify(def.name) + ' on ' + JSON.stringify(struct.name) + ' at ' + def.id.line + ':' + def.id.column);\n  this.id = def.id.value;\n  this.name = def.name;\n  this.required = def.required;\n  this.optional = def.optional;\n  this.valueDefinition = def.valueType;\n  this.valueType = null;\n  this.defaultValueDefinition = def.defaultValue || struct.defaultValueDefinition;\n  this.defaultValue = null;\n  this.annotations = def.annotations;\n}\nThriftField.prototype.link = function link(model) {\n  this.valueType = model.resolve(this.valueDefinition);\n  assert(this.valueType, 'value type was defined, as returned by resolve');\n};\nThriftField.prototype.linkValue = function linkValue(model) {\n  this.defaultValue = model.resolveValue(this.defaultValueDefinition);\n};\nfunction ThriftStruct(options) {\n  options = options || {};\n  this.name = null;\n  // Strict mode is on by default. Because we have strict opinions about Thrift.\n  this.strict = options.strict !== undefined ? options.strict : true;\n  this.defaultValueDefinition = options.defaultValueDefinition;\n  // TODO bring in serviceName\n  this.fields = [];\n  this.fieldNames = [];\n  this.fieldsById = {};\n  this.fieldsByName = {};\n  this.isArgument = null;\n  this.isResult = null;\n  this.isException = options.isException || false;\n  this.Constructor = null;\n  this.surface = null;\n  this.rw = new this.RW(this);\n  this.thrift = null;\n  this.linked = false;\n  this.annotations = null;\n}\nThriftStruct.prototype.name = 'struct';\nThriftStruct.prototype.typeid = TYPE.STRUCT;\nThriftStruct.prototype.RW = StructRW;\nThriftStruct.prototype.isUnion = false;\nThriftStruct.prototype.models = 'type';\nThriftStruct.prototype.toBuffer = function toBuffer(struct) {\n  return bufrw.toBuffer(this.rw, struct);\n};\nThriftStruct.prototype.toBufferResult = function toBufferResult(struct) {\n  return bufrw.toBufferResult(this.rw, struct);\n};\nThriftStruct.prototype.fromBuffer = function fromBuffer(buffer, offset) {\n  return bufrw.fromBuffer(this.rw, buffer, offset);\n};\nThriftStruct.prototype.fromBufferResult = function fromBufferResult(buffer) {\n  return bufrw.fromBufferResult(this.rw, buffer);\n};\nThriftStruct.prototype.compile = function compile(def, thrift) {\n  // Struct names must be valid JavaScript. If the Thrift name is not valid\n  // in JavaScript, it can be overridden with the js.name annotation.\n  this.name = def.annotations && def.annotations['js.name'] || def.id.name;\n  this.fullName = def.id.as || this.name;\n  this.isArgument = def.isArgument || false;\n  this.isResult = def.isResult || false;\n  this.thrift = thrift;\n  var fields = def.fields;\n  for (var index = 0; index < fields.length; index++) {\n    var fieldDef = fields[index];\n    var field = new ThriftField(fieldDef, this);\n\n    // Field names must be valid JavaScript. If the Thrift name is not\n    // valid in JavaScript, it can be overridden with the js.name\n    // annotation.\n    field.name = field.annotations && field.annotations['js.name'] || field.name;\n    this.fieldsById[field.id] = field;\n    this.fieldsByName[field.name] = field;\n    this.fieldNames[index] = field.name;\n    this.fields.push(field);\n  }\n  this.annotations = def.annotations;\n};\nThriftStruct.prototype.link = function link(model) {\n  if (this.linked) {\n    return this;\n  }\n  this.linked = true;\n  var index;\n\n  // Link default values first since they're used by the constructor\n  for (index = 0; index < this.fields.length; index++) {\n    var field = this.fields[index];\n    field.linkValue(model);\n\n    // Evidently with Apache Thrift, arguments are always optional,\n    // regardless of how they are marked.\n    // They are optional in Go by virtue of defaulting to the zero value\n    // for their type, and it is not possible to distinguish a missing\n    // field from the zero value.\n    if (this.isArgument) {\n      if (this.thrift.allowOptionalArguments) {\n        // Once this flag is enabled, all ThriftRW language\n        // implementations agree that fields are optional unless marked\n        // required.  If they are marked required, that contract is\n        // respected for both inbound and outbound messages.\n        if (!field.required && !field.optional && field.defaultValue === undefined) {\n          field.optional = true;\n        }\n      } else if (field.optional) {\n        // Until version 3.4.3, when we introduced the\n        // allowOptionalArguments opt-in, all arguments were always\n        // required.  RPC handlers were written to depend on all\n        // argument fields being implicitly required.\n        assert.ok(false, 'no field of an argument struct may be marked ' + 'optional including ' + field.name + ' of ' + this.name + '; ' + 'consider new Thrift({allowOptionalArguments: true}).');\n      } else {\n        field.required = true;\n      }\n    }\n\n    // Validate field\n    if (this.strict) {\n      assert(field.required || field.optional || field.defaultValue !== null && field.defaultValue !== undefined || this.isArgument || this.isResult || this.isUnion, 'every field must be marked optional, required, or have a default value on ' + this.name + ' including \"' + field.name + '\" in strict mode');\n    }\n  }\n  this.Constructor = this.createConstructor(this.name, this.fields);\n  this.Constructor.rw = this.rw;\n  this.Constructor.fromBuffer = this.fromBuffer;\n  this.Constructor.fromBufferResult = this.fromBufferResult;\n  this.Constructor.toBuffer = this.toBuffer;\n  this.Constructor.toBufferResult = this.toBufferResult;\n  this.surface = this.Constructor;\n\n  // Link field types later since they may depend on the constructor existing\n  // first.\n  for (index = 0; index < this.fields.length; index++) {\n    this.fields[index].link(model);\n  }\n  if (this.isUnion) {\n    model.unions[this.name] = this.Constructor;\n  } else if (this.isException) {\n    model.exceptions[this.name] = this.Constructor;\n  } else {\n    model.structs[this.name] = this.Constructor;\n  }\n\n  // Alias if first character is not lower-case\n  if (!/^[a-z]/.test(this.name)) {\n    model[this.name] = this.Constructor;\n  }\n  return this;\n};\nThriftStruct.prototype.validateStruct = function validateStruct(struct) {\n  // Validate required fields\n  for (var index = 0; index < this.fields.length; index++) {\n    var field = this.fields[index];\n    if (!field.required || field.defaultValue != null) {\n      continue;\n    }\n    var value = struct && struct[field.name];\n    var available = value !== null && value !== undefined;\n    if (!available) {\n      return errors.FieldRequiredError({\n        name: field.name,\n        id: field.id,\n        structName: this.name\n      });\n    }\n  }\n  return null;\n};\n\n// The following methods have alternate implementations for Exception and Union.\n\nThriftStruct.prototype.createConstructor = function createConstructor(name, fields) {\n  var source;\n  source = '(function thriftrw_' + name + '(options) {\\n';\n  for (var index = 0; index < fields.length; index++) {\n    var field = fields[index];\n    source += '    if (options && typeof options.' + field.name + ' !== \"undefined\") ' + '{ this.' + field.name + ' = options.' + field.name + '; }\\n';\n    source += '    else { this.' + field.name + ' = ' + JSON.stringify(field.defaultValue) + '; }\\n';\n  }\n  source += '})\\n';\n  // eval is an operator that captures the lexical scope of the calling\n  // function and deoptimizes the lexical scope.\n  // By using eval in an expression context, it loses this second-class\n  // capability and becomes a first-class function.\n  // (0, eval) is one way to use eval in an expression context.\n  return (0, eval)(source);\n};\nThriftStruct.prototype.create = function create() {\n  return new this.Constructor();\n};\nThriftStruct.prototype.set = function set(struct, key, value) {\n  struct[key] = value;\n};\nThriftStruct.prototype.finalize = function finalize(struct) {\n  return struct;\n};\nfunction StructRW(model) {\n  assert(model, 'model required');\n  this.model = model;\n  RW.call(this);\n}\nutil.inherits(StructRW, RW);\nStructRW.prototype.poolByteLength = function poolByteLength(destResult, struct) {\n  var length = 1; // stop:1\n  var result;\n  for (var index = 0; index < this.model.fields.length; index++) {\n    var field = this.model.fields[index];\n    var value = struct && struct[field.name];\n    var available = value !== null && value !== undefined;\n    if (!available && field.required) {\n      return destResult.reset(errors.FieldRequiredError({\n        name: field.name,\n        id: field.id,\n        structName: this.model.name,\n        what: struct\n      }));\n    }\n    if (!available) {\n      continue;\n    }\n\n    // TODO maybe suppress defaultValue on the wire\n\n    // typeid:1\n    // field.id:2\n    length += 3;\n    result = field.valueType.rw.poolByteLength(destResult, value);\n    // istanbul ignore if\n    if (result.err) {\n      return result;\n    }\n    length += result.length;\n  }\n  return destResult.reset(null, length);\n};\nStructRW.prototype.poolWriteInto = function poolWriteInto(destResult, struct, buffer, offset) {\n  var result;\n  for (var index = 0; index < this.model.fields.length; index++) {\n    var field = this.model.fields[index];\n    var value = struct && struct[field.name];\n    var available = value !== null && value !== undefined;\n    if (!available && field.required) {\n      return destResult.reset(errors.FieldRequiredError({\n        name: field.name,\n        id: field.id,\n        structName: this.model.name,\n        what: struct\n      }));\n    }\n    if (!available) {\n      continue;\n    }\n\n    // TODO maybe suppress defaultValue on the wire\n\n    result = bufrw.Int8.poolWriteInto(destResult, field.valueType.typeid, buffer, offset);\n    // istanbul ignore if\n    if (result.err) {\n      return result;\n    }\n    offset = result.offset;\n    result = bufrw.Int16BE.poolWriteInto(destResult, field.id, buffer, offset);\n    // istanbul ignore if\n    if (result.err) {\n      return result;\n    }\n    offset = result.offset;\n    result = field.valueType.rw.poolWriteInto(destResult, value, buffer, offset);\n    // istanbul ignore if\n    if (result.err) {\n      return result;\n    }\n    offset = result.offset;\n  }\n  result = bufrw.Int8.poolWriteInto(destResult, TYPE.STOP, buffer, offset);\n  // istanbul ignore if\n  if (result.err) {\n    return result;\n  }\n  offset = result.offset;\n  return destResult.reset(null, offset);\n};\nStructRW.prototype.poolReadFrom = function poolReadFrom(destResult, buffer, offset) {\n  var struct = this.model.create();\n  var result;\n  for (;;) {\n    result = bufrw.Int8.poolReadFrom(destResult, buffer, offset);\n    // istanbul ignore if\n    if (result.err) {\n      return result;\n    }\n    offset = result.offset;\n    var typeid = result.value;\n    if (typeid === TYPE.STOP) {\n      break;\n    }\n    result = bufrw.Int16BE.poolReadFrom(destResult, buffer, offset);\n    // istanbul ignore if\n    if (result.err) {\n      return result;\n    }\n    offset = result.offset;\n    var id = result.value;\n\n    // keep unrecognized files from the future if it could be an\n    // unrecognized exception.\n    if (!this.model.fieldsById[id] && this.model.isResult) {\n      result = readType(destResult, buffer, offset, typeid);\n      // result = skipType(buffer, offset, typeid);\n      // istanbul ignore if\n      if (result.err) {\n        return result;\n      }\n      offset = result.offset;\n      this.model.set(struct, 'failure', new ThriftUnrecognizedException(result.value));\n      continue;\n    }\n\n    // skip unrecognized fields from THE FUTURE\n    if (!this.model.fieldsById[id]) {\n      result = skipType(destResult, buffer, offset, typeid);\n      // istanbul ignore if\n      if (result.err) {\n        return result;\n      }\n      offset = result.offset;\n      continue;\n    }\n    var field = this.model.fieldsById[id];\n    if (field.valueType.typeid !== typeid && field.valueType.altTypeid !== typeid // deprecated, see set.js\n    ) {\n      return destResult.reset(errors.UnexpectedFieldValueTypeidError({\n        fieldId: id,\n        fieldName: field.name,\n        structName: this.model.name,\n        typeid: typeid,\n        typeName: NAMES[typeid],\n        expectedTypeid: field.valueType.typeid,\n        expectedTypeName: NAMES[field.valueType.typeid]\n      }), offset);\n    }\n    result = field.valueType.rw.poolReadFrom(destResult, buffer, offset);\n    // istanbul ignore if\n    if (result.err) {\n      return destResult.reset(result.err, offset);\n    }\n    offset = result.offset;\n    // TODO promote return error of set to a ReadResult error\n    this.model.set(struct, field.name, result.value);\n  }\n\n  // Validate required fields\n  var err = this.model.validateStruct(struct);\n  if (err) {\n    return destResult.reset(err, offset);\n  }\n  return destResult.reset(null, offset, this.model.finalize(struct));\n};\nmodule.exports.ThriftField = ThriftField;\nmodule.exports.ThriftStruct = ThriftStruct;\nmodule.exports.StructRW = StructRW;","map":{"version":3,"names":["assert","require","bufrw","RW","TYPE","NAMES","errors","skipType","util","ThriftUnrecognizedException","readType","ThriftField","def","struct","isResult","id","value","JSON","stringify","name","line","column","required","optional","valueDefinition","valueType","defaultValueDefinition","defaultValue","annotations","prototype","link","model","resolve","linkValue","resolveValue","ThriftStruct","options","strict","undefined","fields","fieldNames","fieldsById","fieldsByName","isArgument","isException","Constructor","surface","rw","thrift","linked","typeid","STRUCT","StructRW","isUnion","models","toBuffer","toBufferResult","fromBuffer","buffer","offset","fromBufferResult","compile","fullName","as","index","length","fieldDef","field","push","allowOptionalArguments","ok","createConstructor","unions","exceptions","structs","test","validateStruct","available","FieldRequiredError","structName","source","eval","create","set","key","finalize","call","inherits","poolByteLength","destResult","result","reset","what","err","poolWriteInto","Int8","Int16BE","STOP","poolReadFrom","altTypeid","UnexpectedFieldValueTypeidError","fieldId","fieldName","typeName","expectedTypeid","expectedTypeName","module","exports"],"sources":["/home/bvpelt/Develop/openteltest/node_modules/thriftrw/struct.js"],"sourcesContent":["// Copyright (c) 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint max-len:[0, 120] */\n/* eslint max-statements:[0, 99] */\n/* eslint complexity:[0, 16] */\n'use strict';\n\nvar assert = require('assert');\nvar bufrw = require('bufrw');\nvar RW = require('./rw');\nvar TYPE = require('./TYPE');\nvar NAMES = require('./names');\nvar errors = require('./errors');\nvar skipType = require('./skip').skipType;\nvar util = require('util');\nvar ThriftUnrecognizedException = require('./unrecognized-exception')\n    .ThriftUnrecognizedException;\n\nvar readType = require('./read').readType;\n\nfunction ThriftField(def, struct) {\n    assert(def.isResult || def.id.value > 0,\n        'field identifier must be greater than 0' +\n        ' for ' + JSON.stringify(def.name) +\n        ' on ' + JSON.stringify(struct.name) +\n        ' at ' + def.id.line + ':' + def.id.column\n    );\n    this.id = def.id.value;\n    this.name = def.name;\n    this.required = def.required;\n    this.optional = def.optional;\n    this.valueDefinition = def.valueType;\n    this.valueType = null;\n    this.defaultValueDefinition = def.defaultValue || struct.defaultValueDefinition;\n    this.defaultValue = null;\n    this.annotations = def.annotations;\n}\n\nThriftField.prototype.link = function link(model) {\n    this.valueType = model.resolve(this.valueDefinition);\n    assert(this.valueType, 'value type was defined, as returned by resolve');\n};\n\nThriftField.prototype.linkValue = function linkValue(model) {\n    this.defaultValue = model.resolveValue(this.defaultValueDefinition);\n};\n\nfunction ThriftStruct(options) {\n    options = options || {};\n\n    this.name = null;\n    // Strict mode is on by default. Because we have strict opinions about Thrift.\n    this.strict = options.strict !== undefined ? options.strict : true;\n    this.defaultValueDefinition = options.defaultValueDefinition;\n    // TODO bring in serviceName\n    this.fields = [];\n    this.fieldNames = [];\n    this.fieldsById = {};\n    this.fieldsByName = {};\n    this.isArgument = null;\n    this.isResult = null;\n    this.isException = options.isException || false;\n    this.Constructor = null;\n    this.surface = null;\n    this.rw = new this.RW(this);\n    this.thrift = null;\n    this.linked = false;\n    this.annotations = null;\n}\n\nThriftStruct.prototype.name = 'struct';\nThriftStruct.prototype.typeid = TYPE.STRUCT;\nThriftStruct.prototype.RW = StructRW;\nThriftStruct.prototype.isUnion = false;\nThriftStruct.prototype.models = 'type';\n\nThriftStruct.prototype.toBuffer = function toBuffer(struct) {\n    return bufrw.toBuffer(this.rw, struct);\n};\n\nThriftStruct.prototype.toBufferResult = function toBufferResult(struct) {\n    return bufrw.toBufferResult(this.rw, struct);\n};\n\nThriftStruct.prototype.fromBuffer = function fromBuffer(buffer, offset) {\n    return bufrw.fromBuffer(this.rw, buffer, offset);\n};\n\nThriftStruct.prototype.fromBufferResult = function fromBufferResult(buffer) {\n    return bufrw.fromBufferResult(this.rw, buffer);\n};\n\nThriftStruct.prototype.compile = function compile(def, thrift) {\n    // Struct names must be valid JavaScript. If the Thrift name is not valid\n    // in JavaScript, it can be overridden with the js.name annotation.\n    this.name = def.annotations && def.annotations['js.name'] || def.id.name;\n    this.fullName = def.id.as || this.name;\n    this.isArgument = def.isArgument || false;\n    this.isResult = def.isResult || false;\n    this.thrift = thrift;\n    var fields = def.fields;\n    for (var index = 0; index < fields.length; index++) {\n        var fieldDef = fields[index];\n        var field = new ThriftField(fieldDef, this);\n\n        // Field names must be valid JavaScript. If the Thrift name is not\n        // valid in JavaScript, it can be overridden with the js.name\n        // annotation.\n        field.name = field.annotations && field.annotations['js.name'] || field.name;\n        this.fieldsById[field.id] = field;\n        this.fieldsByName[field.name] = field;\n        this.fieldNames[index] = field.name;\n        this.fields.push(field);\n    }\n    this.annotations = def.annotations;\n};\n\nThriftStruct.prototype.link = function link(model) {\n    if (this.linked) {\n        return this;\n    }\n    this.linked = true;\n\n    var index;\n\n    // Link default values first since they're used by the constructor\n    for (index = 0; index < this.fields.length; index++) {\n        var field = this.fields[index];\n        field.linkValue(model);\n\n        // Evidently with Apache Thrift, arguments are always optional,\n        // regardless of how they are marked.\n        // They are optional in Go by virtue of defaulting to the zero value\n        // for their type, and it is not possible to distinguish a missing\n        // field from the zero value.\n        if (this.isArgument) {\n            if (this.thrift.allowOptionalArguments) {\n                // Once this flag is enabled, all ThriftRW language\n                // implementations agree that fields are optional unless marked\n                // required.  If they are marked required, that contract is\n                // respected for both inbound and outbound messages.\n                if (!field.required && !field.optional && field.defaultValue === undefined) {\n                    field.optional = true;\n                }\n            } else if (field.optional) {\n                // Until version 3.4.3, when we introduced the\n                // allowOptionalArguments opt-in, all arguments were always\n                // required.  RPC handlers were written to depend on all\n                // argument fields being implicitly required.\n                assert.ok(false, 'no field of an argument struct may be marked ' +\n                    'optional including ' + field.name + ' of ' + this.name + '; ' +\n                    'consider new Thrift({allowOptionalArguments: true}).');\n            } else {\n                field.required = true;\n            }\n        }\n\n        // Validate field\n        if (this.strict) {\n            assert(\n                field.required || field.optional ||\n                field.defaultValue !== null && field.defaultValue !== undefined ||\n                this.isArgument || this.isResult || this.isUnion,\n                'every field must be marked optional, required, or have a default value on ' +\n                    this.name + ' including \"' + field.name + '\" in strict mode'\n            );\n        }\n    }\n\n    this.Constructor = this.createConstructor(this.name, this.fields);\n    this.Constructor.rw = this.rw;\n\n    this.Constructor.fromBuffer = this.fromBuffer;\n    this.Constructor.fromBufferResult = this.fromBufferResult;\n\n    this.Constructor.toBuffer = this.toBuffer;\n    this.Constructor.toBufferResult = this.toBufferResult;\n\n    this.surface = this.Constructor;\n\n    // Link field types later since they may depend on the constructor existing\n    // first.\n    for (index = 0; index < this.fields.length; index++) {\n        this.fields[index].link(model);\n    }\n\n    if (this.isUnion) {\n        model.unions[this.name] = this.Constructor;\n    } else if (this.isException) {\n        model.exceptions[this.name] = this.Constructor;\n    } else {\n        model.structs[this.name] = this.Constructor;\n    }\n\n    // Alias if first character is not lower-case\n    if (!/^[a-z]/.test(this.name)) {\n        model[this.name] = this.Constructor;\n    }\n\n    return this;\n};\n\nThriftStruct.prototype.validateStruct = function validateStruct(struct) {\n    // Validate required fields\n    for (var index = 0; index < this.fields.length; index++) {\n        var field = this.fields[index];\n        if (!field.required || field.defaultValue != null) {\n            continue;\n        }\n        var value = struct && struct[field.name];\n        var available = value !== null && value !== undefined;\n        if (!available) {\n            return errors.FieldRequiredError({\n                name: field.name,\n                id: field.id,\n                structName: this.name\n            });\n        }\n    }\n\n    return null;\n};\n\n// The following methods have alternate implementations for Exception and Union.\n\nThriftStruct.prototype.createConstructor = function createConstructor(name, fields) {\n    var source;\n    source = '(function thriftrw_' + name + '(options) {\\n';\n    for (var index = 0; index < fields.length; index++) {\n        var field = fields[index];\n        source += '    if (options && typeof options.' + field.name + ' !== \"undefined\") ' +\n            '{ this.' + field.name + ' = options.' + field.name + '; }\\n';\n        source += '    else { this.' + field.name +\n            ' = ' + JSON.stringify(field.defaultValue) + '; }\\n';\n    }\n    source += '})\\n';\n    // eval is an operator that captures the lexical scope of the calling\n    // function and deoptimizes the lexical scope.\n    // By using eval in an expression context, it loses this second-class\n    // capability and becomes a first-class function.\n    // (0, eval) is one way to use eval in an expression context.\n    return (0, eval)(source);\n};\n\nThriftStruct.prototype.create = function create() {\n    return new this.Constructor();\n};\n\nThriftStruct.prototype.set = function set(struct, key, value) {\n    struct[key] = value;\n};\n\nThriftStruct.prototype.finalize = function finalize(struct) {\n    return struct;\n};\n\nfunction StructRW(model) {\n    assert(model, 'model required');\n    this.model = model;\n\n    RW.call(this);\n}\n\nutil.inherits(StructRW, RW);\n\nStructRW.prototype.poolByteLength = function poolByteLength(destResult, struct) {\n    var length = 1; // stop:1\n    var result;\n    for (var index = 0; index < this.model.fields.length; index++) {\n        var field = this.model.fields[index];\n        var value = struct && struct[field.name];\n\n        var available = value !== null && value !== undefined;\n\n        if (!available && field.required) {\n            return destResult.reset(errors.FieldRequiredError({\n                name: field.name,\n                id: field.id,\n                structName: this.model.name,\n                what: struct\n            }));\n        }\n        if (!available) {\n            continue;\n        }\n\n        // TODO maybe suppress defaultValue on the wire\n\n        // typeid:1\n        // field.id:2\n        length += 3;\n\n        result = field.valueType.rw.poolByteLength(destResult, value);\n        // istanbul ignore if\n        if (result.err) {\n            return result;\n        }\n        length += result.length;\n    }\n    return destResult.reset(null, length);\n};\n\nStructRW.prototype.poolWriteInto = function poolWriteInto(destResult, struct, buffer, offset) {\n    var result;\n    for (var index = 0; index < this.model.fields.length; index++) {\n        var field = this.model.fields[index];\n        var value = struct && struct[field.name];\n        var available = value !== null && value !== undefined;\n\n        if (!available && field.required) {\n            return destResult.reset(errors.FieldRequiredError({\n                name: field.name,\n                id: field.id,\n                structName: this.model.name,\n                what: struct\n            }));\n        }\n        if (!available) {\n            continue;\n        }\n\n        // TODO maybe suppress defaultValue on the wire\n\n        result = bufrw.Int8.poolWriteInto(destResult, field.valueType.typeid, buffer, offset);\n        // istanbul ignore if\n        if (result.err) {\n            return result;\n        }\n        offset = result.offset;\n\n        result = bufrw.Int16BE.poolWriteInto(destResult, field.id, buffer, offset);\n        // istanbul ignore if\n        if (result.err) {\n            return result;\n        }\n        offset = result.offset;\n\n        result = field.valueType.rw.poolWriteInto(destResult, value, buffer, offset);\n        // istanbul ignore if\n        if (result.err) {\n            return result;\n        }\n        offset = result.offset;\n    }\n\n    result = bufrw.Int8.poolWriteInto(destResult, TYPE.STOP, buffer, offset);\n    // istanbul ignore if\n    if (result.err) {\n        return result;\n    }\n    offset = result.offset;\n    return destResult.reset(null, offset);\n};\n\nStructRW.prototype.poolReadFrom = function poolReadFrom(destResult, buffer, offset) {\n    var struct = this.model.create();\n    var result;\n\n    for (;;) {\n        result = bufrw.Int8.poolReadFrom(destResult, buffer, offset);\n        // istanbul ignore if\n        if (result.err) {\n            return result;\n        }\n        offset = result.offset;\n        var typeid = result.value;\n\n        if (typeid === TYPE.STOP) {\n            break;\n        }\n\n        result = bufrw.Int16BE.poolReadFrom(destResult, buffer, offset);\n        // istanbul ignore if\n        if (result.err) {\n            return result;\n        }\n        offset = result.offset;\n        var id = result.value;\n\n        // keep unrecognized files from the future if it could be an\n        // unrecognized exception.\n        if (!this.model.fieldsById[id] && this.model.isResult) {\n            result = readType(destResult, buffer, offset, typeid);\n            // result = skipType(buffer, offset, typeid);\n            // istanbul ignore if\n            if (result.err) {\n                return result;\n            }\n            offset = result.offset;\n            this.model.set(\n                struct,\n                'failure',\n                new ThriftUnrecognizedException(result.value)\n            );\n            continue;\n        }\n\n        // skip unrecognized fields from THE FUTURE\n        if (!this.model.fieldsById[id]) {\n            result = skipType(destResult, buffer, offset, typeid);\n            // istanbul ignore if\n            if (result.err) {\n                return result;\n            }\n            offset = result.offset;\n            continue;\n        }\n\n        var field = this.model.fieldsById[id];\n        if (\n            field.valueType.typeid !== typeid &&\n            field.valueType.altTypeid !== typeid // deprecated, see set.js\n        ) {\n            return destResult.reset(errors.UnexpectedFieldValueTypeidError({\n                fieldId: id,\n                fieldName: field.name,\n                structName: this.model.name,\n                typeid: typeid,\n                typeName: NAMES[typeid],\n                expectedTypeid: field.valueType.typeid,\n                expectedTypeName: NAMES[field.valueType.typeid]\n            }), offset);\n        }\n\n        result = field.valueType.rw.poolReadFrom(destResult, buffer, offset);\n        // istanbul ignore if\n        if (result.err) {\n            return destResult.reset(result.err, offset);\n        }\n        offset = result.offset;\n        // TODO promote return error of set to a ReadResult error\n        this.model.set(struct, field.name, result.value);\n    }\n\n    // Validate required fields\n    var err = this.model.validateStruct(struct);\n    if (err) {\n        return destResult.reset(err, offset);\n    }\n\n    return destResult.reset(null, offset, this.model.finalize(struct));\n};\n\nmodule.exports.ThriftField = ThriftField;\nmodule.exports.ThriftStruct = ThriftStruct;\nmodule.exports.StructRW = StructRW;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}