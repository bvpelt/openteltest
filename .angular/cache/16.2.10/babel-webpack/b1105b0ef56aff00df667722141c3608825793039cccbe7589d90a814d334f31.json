{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Buckets = /** @class */function () {\n  /**\n   * The term index refers to the number of the exponential histogram bucket\n   * used to determine its boundaries. The lower boundary of a bucket is\n   * determined by base ** index and the upper boundary of a bucket is\n   * determined by base ** (index + 1). index values are signed to account\n   * for values less than or equal to 1.\n   *\n   * indexBase is the index of the 0th position in the\n   * backing array, i.e., backing[0] is the count\n   * in the bucket with index `indexBase`.\n   *\n   * indexStart is the smallest index value represented\n   * in the backing array.\n   *\n   * indexEnd is the largest index value represented in\n   * the backing array.\n   */\n  function Buckets(backing, indexBase, indexStart, indexEnd) {\n    if (backing === void 0) {\n      backing = new BucketsBacking();\n    }\n    if (indexBase === void 0) {\n      indexBase = 0;\n    }\n    if (indexStart === void 0) {\n      indexStart = 0;\n    }\n    if (indexEnd === void 0) {\n      indexEnd = 0;\n    }\n    this.backing = backing;\n    this.indexBase = indexBase;\n    this.indexStart = indexStart;\n    this.indexEnd = indexEnd;\n  }\n  Object.defineProperty(Buckets.prototype, \"offset\", {\n    /**\n     * Offset is the bucket index of the smallest entry in the counts array\n     * @returns {number}\n     */\n    get: function () {\n      return this.indexStart;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Buckets.prototype, \"length\", {\n    /**\n     * Buckets is a view into the backing array.\n     * @returns {number}\n     */\n    get: function () {\n      if (this.backing.length === 0) {\n        return 0;\n      }\n      if (this.indexEnd === this.indexStart && this.at(0) === 0) {\n        return 0;\n      }\n      return this.indexEnd - this.indexStart + 1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * An array of counts, where count[i] carries the count\n   * of the bucket at index (offset+i).  count[i] is the count of\n   * values greater than base^(offset+i) and less than or equal to\n   * base^(offset+i+1).\n   * @returns {number} The logical counts based on the backing array\n   */\n  Buckets.prototype.counts = function () {\n    var _this = this;\n    return Array.from({\n      length: this.length\n    }, function (_, i) {\n      return _this.at(i);\n    });\n  };\n  /**\n   * At returns the count of the bucket at a position in the logical\n   * array of counts.\n   * @param position\n   * @returns {number}\n   */\n  Buckets.prototype.at = function (position) {\n    var bias = this.indexBase - this.indexStart;\n    if (position < bias) {\n      position += this.backing.length;\n    }\n    position -= bias;\n    return this.backing.countAt(position);\n  };\n  /**\n   * incrementBucket increments the backing array index by `increment`\n   * @param bucketIndex\n   * @param increment\n   */\n  Buckets.prototype.incrementBucket = function (bucketIndex, increment) {\n    this.backing.increment(bucketIndex, increment);\n  };\n  /**\n   * decrementBucket decrements the backing array index by `decrement`\n   * if decrement is greater than the current value, it's set to 0.\n   * @param bucketIndex\n   * @param decrement\n   */\n  Buckets.prototype.decrementBucket = function (bucketIndex, decrement) {\n    this.backing.decrement(bucketIndex, decrement);\n  };\n  /**\n   * trim removes leading and / or trailing zero buckets (which can occur\n   * after diffing two histos) and rotates the backing array so that the\n   * smallest non-zero index is in the 0th position of the backing array\n   */\n  Buckets.prototype.trim = function () {\n    for (var i = 0; i < this.length; i++) {\n      if (this.at(i) !== 0) {\n        this.indexStart += i;\n        break;\n      } else if (i === this.length - 1) {\n        //the entire array is zeroed out\n        this.indexStart = this.indexEnd = this.indexBase = 0;\n        return;\n      }\n    }\n    for (var i = this.length - 1; i >= 0; i--) {\n      if (this.at(i) !== 0) {\n        this.indexEnd -= this.length - i - 1;\n        break;\n      }\n    }\n    this._rotate();\n  };\n  /**\n   * downscale first rotates, then collapses 2**`by`-to-1 buckets.\n   * @param by\n   */\n  Buckets.prototype.downscale = function (by) {\n    this._rotate();\n    var size = 1 + this.indexEnd - this.indexStart;\n    var each = 1 << by;\n    var inpos = 0;\n    var outpos = 0;\n    for (var pos = this.indexStart; pos <= this.indexEnd;) {\n      var mod = pos % each;\n      if (mod < 0) {\n        mod += each;\n      }\n      for (var i = mod; i < each && inpos < size; i++) {\n        this._relocateBucket(outpos, inpos);\n        inpos++;\n        pos++;\n      }\n      outpos++;\n    }\n    this.indexStart >>= by;\n    this.indexEnd >>= by;\n    this.indexBase = this.indexStart;\n  };\n  /**\n   * Clone returns a deep copy of Buckets\n   * @returns {Buckets}\n   */\n  Buckets.prototype.clone = function () {\n    return new Buckets(this.backing.clone(), this.indexBase, this.indexStart, this.indexEnd);\n  };\n  /**\n   * _rotate shifts the backing array contents so that indexStart ==\n   * indexBase to simplify the downscale logic.\n   */\n  Buckets.prototype._rotate = function () {\n    var bias = this.indexBase - this.indexStart;\n    if (bias === 0) {\n      return;\n    } else if (bias > 0) {\n      this.backing.reverse(0, this.backing.length);\n      this.backing.reverse(0, bias);\n      this.backing.reverse(bias, this.backing.length);\n    } else {\n      // negative bias, this can happen when diffing two histograms\n      this.backing.reverse(0, this.backing.length);\n      this.backing.reverse(0, this.backing.length + bias);\n    }\n    this.indexBase = this.indexStart;\n  };\n  /**\n   * _relocateBucket adds the count in counts[src] to counts[dest] and\n   * resets count[src] to zero.\n   */\n  Buckets.prototype._relocateBucket = function (dest, src) {\n    if (dest === src) {\n      return;\n    }\n    this.incrementBucket(dest, this.backing.emptyBucket(src));\n  };\n  return Buckets;\n}();\nexport { Buckets };\n/**\n * BucketsBacking holds the raw buckets and some utility methods to\n * manage them.\n */\nvar BucketsBacking = /** @class */function () {\n  function BucketsBacking(_counts) {\n    if (_counts === void 0) {\n      _counts = [0];\n    }\n    this._counts = _counts;\n  }\n  Object.defineProperty(BucketsBacking.prototype, \"length\", {\n    /**\n     * length returns the physical size of the backing array, which\n     * is >= buckets.length()\n     */\n    get: function () {\n      return this._counts.length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * countAt returns the count in a specific bucket\n   */\n  BucketsBacking.prototype.countAt = function (pos) {\n    return this._counts[pos];\n  };\n  /**\n   * growTo grows a backing array and copies old entries\n   * into their correct new positions.\n   */\n  BucketsBacking.prototype.growTo = function (newSize, oldPositiveLimit, newPositiveLimit) {\n    var tmp = new Array(newSize).fill(0);\n    tmp.splice.apply(tmp, __spreadArray([newPositiveLimit, this._counts.length - oldPositiveLimit], __read(this._counts.slice(oldPositiveLimit)), false));\n    tmp.splice.apply(tmp, __spreadArray([0, oldPositiveLimit], __read(this._counts.slice(0, oldPositiveLimit)), false));\n    this._counts = tmp;\n  };\n  /**\n   * reverse the items in the backing array in the range [from, limit).\n   */\n  BucketsBacking.prototype.reverse = function (from, limit) {\n    var num = Math.floor((from + limit) / 2) - from;\n    for (var i = 0; i < num; i++) {\n      var tmp = this._counts[from + i];\n      this._counts[from + i] = this._counts[limit - i - 1];\n      this._counts[limit - i - 1] = tmp;\n    }\n  };\n  /**\n   * emptyBucket empties the count from a bucket, for\n   * moving into another.\n   */\n  BucketsBacking.prototype.emptyBucket = function (src) {\n    var tmp = this._counts[src];\n    this._counts[src] = 0;\n    return tmp;\n  };\n  /**\n   * increments a bucket by `increment`\n   */\n  BucketsBacking.prototype.increment = function (bucketIndex, increment) {\n    this._counts[bucketIndex] += increment;\n  };\n  /**\n   * decrements a bucket by `decrement`\n   */\n  BucketsBacking.prototype.decrement = function (bucketIndex, decrement) {\n    if (this._counts[bucketIndex] >= decrement) {\n      this._counts[bucketIndex] -= decrement;\n    } else {\n      // this should not happen, but we're being defensive against\n      // negative counts.\n      this._counts[bucketIndex] = 0;\n    }\n  };\n  /**\n   * clone returns a deep copy of BucketsBacking\n   */\n  BucketsBacking.prototype.clone = function () {\n    return new BucketsBacking(__spreadArray([], __read(this._counts), false));\n  };\n  return BucketsBacking;\n}();","map":{"version":3,"names":["__read","o","n","m","Symbol","iterator","i","call","r","ar","e","next","done","push","value","error","__spreadArray","to","from","pack","arguments","length","l","Array","prototype","slice","concat","Buckets","backing","indexBase","indexStart","indexEnd","BucketsBacking","Object","defineProperty","get","enumerable","configurable","at","counts","_this","_","position","bias","countAt","incrementBucket","bucketIndex","increment","decrementBucket","decrement","trim","_rotate","downscale","by","size","each","inpos","outpos","pos","mod","_relocateBucket","clone","reverse","dest","src","emptyBucket","_counts","growTo","newSize","oldPositiveLimit","newPositiveLimit","tmp","fill","splice","apply","limit","num","Math","floor"],"sources":["/home/bvpelt/Develop/openteltest/node_modules/@opentelemetry/sdk-metrics/build/esm/aggregator/exponential-histogram/Buckets.js"],"sourcesContent":["var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Buckets = /** @class */ (function () {\n    /**\n     * The term index refers to the number of the exponential histogram bucket\n     * used to determine its boundaries. The lower boundary of a bucket is\n     * determined by base ** index and the upper boundary of a bucket is\n     * determined by base ** (index + 1). index values are signed to account\n     * for values less than or equal to 1.\n     *\n     * indexBase is the index of the 0th position in the\n     * backing array, i.e., backing[0] is the count\n     * in the bucket with index `indexBase`.\n     *\n     * indexStart is the smallest index value represented\n     * in the backing array.\n     *\n     * indexEnd is the largest index value represented in\n     * the backing array.\n     */\n    function Buckets(backing, indexBase, indexStart, indexEnd) {\n        if (backing === void 0) { backing = new BucketsBacking(); }\n        if (indexBase === void 0) { indexBase = 0; }\n        if (indexStart === void 0) { indexStart = 0; }\n        if (indexEnd === void 0) { indexEnd = 0; }\n        this.backing = backing;\n        this.indexBase = indexBase;\n        this.indexStart = indexStart;\n        this.indexEnd = indexEnd;\n    }\n    Object.defineProperty(Buckets.prototype, \"offset\", {\n        /**\n         * Offset is the bucket index of the smallest entry in the counts array\n         * @returns {number}\n         */\n        get: function () {\n            return this.indexStart;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Buckets.prototype, \"length\", {\n        /**\n         * Buckets is a view into the backing array.\n         * @returns {number}\n         */\n        get: function () {\n            if (this.backing.length === 0) {\n                return 0;\n            }\n            if (this.indexEnd === this.indexStart && this.at(0) === 0) {\n                return 0;\n            }\n            return this.indexEnd - this.indexStart + 1;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * An array of counts, where count[i] carries the count\n     * of the bucket at index (offset+i).  count[i] is the count of\n     * values greater than base^(offset+i) and less than or equal to\n     * base^(offset+i+1).\n     * @returns {number} The logical counts based on the backing array\n     */\n    Buckets.prototype.counts = function () {\n        var _this = this;\n        return Array.from({ length: this.length }, function (_, i) { return _this.at(i); });\n    };\n    /**\n     * At returns the count of the bucket at a position in the logical\n     * array of counts.\n     * @param position\n     * @returns {number}\n     */\n    Buckets.prototype.at = function (position) {\n        var bias = this.indexBase - this.indexStart;\n        if (position < bias) {\n            position += this.backing.length;\n        }\n        position -= bias;\n        return this.backing.countAt(position);\n    };\n    /**\n     * incrementBucket increments the backing array index by `increment`\n     * @param bucketIndex\n     * @param increment\n     */\n    Buckets.prototype.incrementBucket = function (bucketIndex, increment) {\n        this.backing.increment(bucketIndex, increment);\n    };\n    /**\n     * decrementBucket decrements the backing array index by `decrement`\n     * if decrement is greater than the current value, it's set to 0.\n     * @param bucketIndex\n     * @param decrement\n     */\n    Buckets.prototype.decrementBucket = function (bucketIndex, decrement) {\n        this.backing.decrement(bucketIndex, decrement);\n    };\n    /**\n     * trim removes leading and / or trailing zero buckets (which can occur\n     * after diffing two histos) and rotates the backing array so that the\n     * smallest non-zero index is in the 0th position of the backing array\n     */\n    Buckets.prototype.trim = function () {\n        for (var i = 0; i < this.length; i++) {\n            if (this.at(i) !== 0) {\n                this.indexStart += i;\n                break;\n            }\n            else if (i === this.length - 1) {\n                //the entire array is zeroed out\n                this.indexStart = this.indexEnd = this.indexBase = 0;\n                return;\n            }\n        }\n        for (var i = this.length - 1; i >= 0; i--) {\n            if (this.at(i) !== 0) {\n                this.indexEnd -= this.length - i - 1;\n                break;\n            }\n        }\n        this._rotate();\n    };\n    /**\n     * downscale first rotates, then collapses 2**`by`-to-1 buckets.\n     * @param by\n     */\n    Buckets.prototype.downscale = function (by) {\n        this._rotate();\n        var size = 1 + this.indexEnd - this.indexStart;\n        var each = 1 << by;\n        var inpos = 0;\n        var outpos = 0;\n        for (var pos = this.indexStart; pos <= this.indexEnd;) {\n            var mod = pos % each;\n            if (mod < 0) {\n                mod += each;\n            }\n            for (var i = mod; i < each && inpos < size; i++) {\n                this._relocateBucket(outpos, inpos);\n                inpos++;\n                pos++;\n            }\n            outpos++;\n        }\n        this.indexStart >>= by;\n        this.indexEnd >>= by;\n        this.indexBase = this.indexStart;\n    };\n    /**\n     * Clone returns a deep copy of Buckets\n     * @returns {Buckets}\n     */\n    Buckets.prototype.clone = function () {\n        return new Buckets(this.backing.clone(), this.indexBase, this.indexStart, this.indexEnd);\n    };\n    /**\n     * _rotate shifts the backing array contents so that indexStart ==\n     * indexBase to simplify the downscale logic.\n     */\n    Buckets.prototype._rotate = function () {\n        var bias = this.indexBase - this.indexStart;\n        if (bias === 0) {\n            return;\n        }\n        else if (bias > 0) {\n            this.backing.reverse(0, this.backing.length);\n            this.backing.reverse(0, bias);\n            this.backing.reverse(bias, this.backing.length);\n        }\n        else {\n            // negative bias, this can happen when diffing two histograms\n            this.backing.reverse(0, this.backing.length);\n            this.backing.reverse(0, this.backing.length + bias);\n        }\n        this.indexBase = this.indexStart;\n    };\n    /**\n     * _relocateBucket adds the count in counts[src] to counts[dest] and\n     * resets count[src] to zero.\n     */\n    Buckets.prototype._relocateBucket = function (dest, src) {\n        if (dest === src) {\n            return;\n        }\n        this.incrementBucket(dest, this.backing.emptyBucket(src));\n    };\n    return Buckets;\n}());\nexport { Buckets };\n/**\n * BucketsBacking holds the raw buckets and some utility methods to\n * manage them.\n */\nvar BucketsBacking = /** @class */ (function () {\n    function BucketsBacking(_counts) {\n        if (_counts === void 0) { _counts = [0]; }\n        this._counts = _counts;\n    }\n    Object.defineProperty(BucketsBacking.prototype, \"length\", {\n        /**\n         * length returns the physical size of the backing array, which\n         * is >= buckets.length()\n         */\n        get: function () {\n            return this._counts.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * countAt returns the count in a specific bucket\n     */\n    BucketsBacking.prototype.countAt = function (pos) {\n        return this._counts[pos];\n    };\n    /**\n     * growTo grows a backing array and copies old entries\n     * into their correct new positions.\n     */\n    BucketsBacking.prototype.growTo = function (newSize, oldPositiveLimit, newPositiveLimit) {\n        var tmp = new Array(newSize).fill(0);\n        tmp.splice.apply(tmp, __spreadArray([newPositiveLimit,\n            this._counts.length - oldPositiveLimit], __read(this._counts.slice(oldPositiveLimit)), false));\n        tmp.splice.apply(tmp, __spreadArray([0, oldPositiveLimit], __read(this._counts.slice(0, oldPositiveLimit)), false));\n        this._counts = tmp;\n    };\n    /**\n     * reverse the items in the backing array in the range [from, limit).\n     */\n    BucketsBacking.prototype.reverse = function (from, limit) {\n        var num = Math.floor((from + limit) / 2) - from;\n        for (var i = 0; i < num; i++) {\n            var tmp = this._counts[from + i];\n            this._counts[from + i] = this._counts[limit - i - 1];\n            this._counts[limit - i - 1] = tmp;\n        }\n    };\n    /**\n     * emptyBucket empties the count from a bucket, for\n     * moving into another.\n     */\n    BucketsBacking.prototype.emptyBucket = function (src) {\n        var tmp = this._counts[src];\n        this._counts[src] = 0;\n        return tmp;\n    };\n    /**\n     * increments a bucket by `increment`\n     */\n    BucketsBacking.prototype.increment = function (bucketIndex, increment) {\n        this._counts[bucketIndex] += increment;\n    };\n    /**\n     * decrements a bucket by `decrement`\n     */\n    BucketsBacking.prototype.decrement = function (bucketIndex, decrement) {\n        if (this._counts[bucketIndex] >= decrement) {\n            this._counts[bucketIndex] -= decrement;\n        }\n        else {\n            // this should not happen, but we're being defensive against\n            // negative counts.\n            this._counts[bucketIndex] = 0;\n        }\n    };\n    /**\n     * clone returns a deep copy of BucketsBacking\n     */\n    BucketsBacking.prototype.clone = function () {\n        return new BucketsBacking(__spreadArray([], __read(this._counts), false));\n    };\n    return BucketsBacking;\n}());\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}