{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { context, diag, TraceFlags } from '@opentelemetry/api';\nimport { BindOnceFuture, ExportResultCode, getEnv, globalErrorHandler, suppressTracing, unrefTimer } from '@opentelemetry/core';\n/**\n * Implementation of the {@link SpanProcessor} that batches spans exported by\n * the SDK then pushes them to the exporter pipeline.\n */\nvar BatchSpanProcessorBase = /** @class */function () {\n  function BatchSpanProcessorBase(_exporter, config) {\n    this._exporter = _exporter;\n    this._isExporting = false;\n    this._finishedSpans = [];\n    this._droppedSpansCount = 0;\n    var env = getEnv();\n    this._maxExportBatchSize = typeof (config === null || config === void 0 ? void 0 : config.maxExportBatchSize) === 'number' ? config.maxExportBatchSize : env.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;\n    this._maxQueueSize = typeof (config === null || config === void 0 ? void 0 : config.maxQueueSize) === 'number' ? config.maxQueueSize : env.OTEL_BSP_MAX_QUEUE_SIZE;\n    this._scheduledDelayMillis = typeof (config === null || config === void 0 ? void 0 : config.scheduledDelayMillis) === 'number' ? config.scheduledDelayMillis : env.OTEL_BSP_SCHEDULE_DELAY;\n    this._exportTimeoutMillis = typeof (config === null || config === void 0 ? void 0 : config.exportTimeoutMillis) === 'number' ? config.exportTimeoutMillis : env.OTEL_BSP_EXPORT_TIMEOUT;\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n    if (this._maxExportBatchSize > this._maxQueueSize) {\n      diag.warn('BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize');\n      this._maxExportBatchSize = this._maxQueueSize;\n    }\n  }\n  BatchSpanProcessorBase.prototype.forceFlush = function () {\n    if (this._shutdownOnce.isCalled) {\n      return this._shutdownOnce.promise;\n    }\n    return this._flushAll();\n  };\n  // does nothing.\n  BatchSpanProcessorBase.prototype.onStart = function (_span, _parentContext) {};\n  BatchSpanProcessorBase.prototype.onEnd = function (span) {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n    if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n      return;\n    }\n    this._addToBuffer(span);\n  };\n  BatchSpanProcessorBase.prototype.shutdown = function () {\n    return this._shutdownOnce.call();\n  };\n  BatchSpanProcessorBase.prototype._shutdown = function () {\n    var _this = this;\n    return Promise.resolve().then(function () {\n      return _this.onShutdown();\n    }).then(function () {\n      return _this._flushAll();\n    }).then(function () {\n      return _this._exporter.shutdown();\n    });\n  };\n  /** Add a span in the buffer. */\n  BatchSpanProcessorBase.prototype._addToBuffer = function (span) {\n    if (this._finishedSpans.length >= this._maxQueueSize) {\n      // limit reached, drop span\n      if (this._droppedSpansCount === 0) {\n        diag.debug('maxQueueSize reached, dropping spans');\n      }\n      this._droppedSpansCount++;\n      return;\n    }\n    if (this._droppedSpansCount > 0) {\n      // some spans were dropped, log once with count of spans dropped\n      diag.warn(\"Dropped \" + this._droppedSpansCount + \" spans because maxQueueSize reached\");\n      this._droppedSpansCount = 0;\n    }\n    this._finishedSpans.push(span);\n    this._maybeStartTimer();\n  };\n  /**\n   * Send all spans to the exporter respecting the batch size limit\n   * This function is used only on forceFlush or shutdown,\n   * for all other cases _flush should be used\n   * */\n  BatchSpanProcessorBase.prototype._flushAll = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      var promises = [];\n      // calculate number of batches\n      var count = Math.ceil(_this._finishedSpans.length / _this._maxExportBatchSize);\n      for (var i = 0, j = count; i < j; i++) {\n        promises.push(_this._flushOneBatch());\n      }\n      Promise.all(promises).then(function () {\n        resolve();\n      }).catch(reject);\n    });\n  };\n  BatchSpanProcessorBase.prototype._flushOneBatch = function () {\n    var _this = this;\n    this._clearTimer();\n    if (this._finishedSpans.length === 0) {\n      return Promise.resolve();\n    }\n    return new Promise(function (resolve, reject) {\n      var timer = setTimeout(function () {\n        // don't wait anymore for export, this way the next batch can start\n        reject(new Error('Timeout'));\n      }, _this._exportTimeoutMillis);\n      // prevent downstream exporter calls from generating spans\n      context.with(suppressTracing(context.active()), function () {\n        // Reset the finished spans buffer here because the next invocations of the _flush method\n        // could pass the same finished spans to the exporter if the buffer is cleared\n        // outside the execution of this callback.\n        var spans = _this._finishedSpans.splice(0, _this._maxExportBatchSize);\n        var doExport = function () {\n          return _this._exporter.export(spans, function (result) {\n            var _a;\n            clearTimeout(timer);\n            if (result.code === ExportResultCode.SUCCESS) {\n              resolve();\n            } else {\n              reject((_a = result.error) !== null && _a !== void 0 ? _a : new Error('BatchSpanProcessor: span export failed'));\n            }\n          });\n        };\n        var pendingResources = spans.map(function (span) {\n          return span.resource;\n        }).filter(function (resource) {\n          return resource.asyncAttributesPending;\n        });\n        // Avoid scheduling a promise to make the behavior more predictable and easier to test\n        if (pendingResources.length === 0) {\n          doExport();\n        } else {\n          Promise.all(pendingResources.map(function (resource) {\n            var _a;\n            return (_a = resource.waitForAsyncAttributes) === null || _a === void 0 ? void 0 : _a.call(resource);\n          })).then(doExport, function (err) {\n            globalErrorHandler(err);\n            reject(err);\n          });\n        }\n      });\n    });\n  };\n  BatchSpanProcessorBase.prototype._maybeStartTimer = function () {\n    var _this = this;\n    if (this._isExporting) return;\n    var flush = function () {\n      _this._isExporting = true;\n      _this._flushOneBatch().then(function () {\n        _this._isExporting = false;\n        if (_this._finishedSpans.length > 0) {\n          _this._clearTimer();\n          _this._maybeStartTimer();\n        }\n      }).catch(function (e) {\n        _this._isExporting = false;\n        globalErrorHandler(e);\n      });\n    };\n    // we only wait if the queue doesn't have enough elements yet\n    if (this._finishedSpans.length >= this._maxExportBatchSize) {\n      return flush();\n    }\n    if (this._timer !== undefined) return;\n    this._timer = setTimeout(function () {\n      return flush();\n    }, this._scheduledDelayMillis);\n    unrefTimer(this._timer);\n  };\n  BatchSpanProcessorBase.prototype._clearTimer = function () {\n    if (this._timer !== undefined) {\n      clearTimeout(this._timer);\n      this._timer = undefined;\n    }\n  };\n  return BatchSpanProcessorBase;\n}();\nexport { BatchSpanProcessorBase };","map":{"version":3,"names":["context","diag","TraceFlags","BindOnceFuture","ExportResultCode","getEnv","globalErrorHandler","suppressTracing","unrefTimer","BatchSpanProcessorBase","_exporter","config","_isExporting","_finishedSpans","_droppedSpansCount","env","_maxExportBatchSize","maxExportBatchSize","OTEL_BSP_MAX_EXPORT_BATCH_SIZE","_maxQueueSize","maxQueueSize","OTEL_BSP_MAX_QUEUE_SIZE","_scheduledDelayMillis","scheduledDelayMillis","OTEL_BSP_SCHEDULE_DELAY","_exportTimeoutMillis","exportTimeoutMillis","OTEL_BSP_EXPORT_TIMEOUT","_shutdownOnce","_shutdown","warn","prototype","forceFlush","isCalled","promise","_flushAll","onStart","_span","_parentContext","onEnd","span","spanContext","traceFlags","SAMPLED","_addToBuffer","shutdown","call","_this","Promise","resolve","then","onShutdown","length","debug","push","_maybeStartTimer","reject","promises","count","Math","ceil","i","j","_flushOneBatch","all","catch","_clearTimer","timer","setTimeout","Error","with","active","spans","splice","doExport","export","result","_a","clearTimeout","code","SUCCESS","error","pendingResources","map","resource","filter","asyncAttributesPending","waitForAsyncAttributes","err","flush","e","_timer","undefined"],"sources":["/home/bvpelt/Develop/openteltest/node_modules/@opentelemetry/instrumentation-fetch/node_modules/@opentelemetry/sdk-trace-web/node_modules/@opentelemetry/sdk-trace-base/build/esm/export/BatchSpanProcessorBase.js"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { context, diag, TraceFlags } from '@opentelemetry/api';\nimport { BindOnceFuture, ExportResultCode, getEnv, globalErrorHandler, suppressTracing, unrefTimer, } from '@opentelemetry/core';\n/**\n * Implementation of the {@link SpanProcessor} that batches spans exported by\n * the SDK then pushes them to the exporter pipeline.\n */\nvar BatchSpanProcessorBase = /** @class */ (function () {\n    function BatchSpanProcessorBase(_exporter, config) {\n        this._exporter = _exporter;\n        this._isExporting = false;\n        this._finishedSpans = [];\n        this._droppedSpansCount = 0;\n        var env = getEnv();\n        this._maxExportBatchSize =\n            typeof (config === null || config === void 0 ? void 0 : config.maxExportBatchSize) === 'number'\n                ? config.maxExportBatchSize\n                : env.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;\n        this._maxQueueSize =\n            typeof (config === null || config === void 0 ? void 0 : config.maxQueueSize) === 'number'\n                ? config.maxQueueSize\n                : env.OTEL_BSP_MAX_QUEUE_SIZE;\n        this._scheduledDelayMillis =\n            typeof (config === null || config === void 0 ? void 0 : config.scheduledDelayMillis) === 'number'\n                ? config.scheduledDelayMillis\n                : env.OTEL_BSP_SCHEDULE_DELAY;\n        this._exportTimeoutMillis =\n            typeof (config === null || config === void 0 ? void 0 : config.exportTimeoutMillis) === 'number'\n                ? config.exportTimeoutMillis\n                : env.OTEL_BSP_EXPORT_TIMEOUT;\n        this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n        if (this._maxExportBatchSize > this._maxQueueSize) {\n            diag.warn('BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize');\n            this._maxExportBatchSize = this._maxQueueSize;\n        }\n    }\n    BatchSpanProcessorBase.prototype.forceFlush = function () {\n        if (this._shutdownOnce.isCalled) {\n            return this._shutdownOnce.promise;\n        }\n        return this._flushAll();\n    };\n    // does nothing.\n    BatchSpanProcessorBase.prototype.onStart = function (_span, _parentContext) { };\n    BatchSpanProcessorBase.prototype.onEnd = function (span) {\n        if (this._shutdownOnce.isCalled) {\n            return;\n        }\n        if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n            return;\n        }\n        this._addToBuffer(span);\n    };\n    BatchSpanProcessorBase.prototype.shutdown = function () {\n        return this._shutdownOnce.call();\n    };\n    BatchSpanProcessorBase.prototype._shutdown = function () {\n        var _this = this;\n        return Promise.resolve()\n            .then(function () {\n            return _this.onShutdown();\n        })\n            .then(function () {\n            return _this._flushAll();\n        })\n            .then(function () {\n            return _this._exporter.shutdown();\n        });\n    };\n    /** Add a span in the buffer. */\n    BatchSpanProcessorBase.prototype._addToBuffer = function (span) {\n        if (this._finishedSpans.length >= this._maxQueueSize) {\n            // limit reached, drop span\n            if (this._droppedSpansCount === 0) {\n                diag.debug('maxQueueSize reached, dropping spans');\n            }\n            this._droppedSpansCount++;\n            return;\n        }\n        if (this._droppedSpansCount > 0) {\n            // some spans were dropped, log once with count of spans dropped\n            diag.warn(\"Dropped \" + this._droppedSpansCount + \" spans because maxQueueSize reached\");\n            this._droppedSpansCount = 0;\n        }\n        this._finishedSpans.push(span);\n        this._maybeStartTimer();\n    };\n    /**\n     * Send all spans to the exporter respecting the batch size limit\n     * This function is used only on forceFlush or shutdown,\n     * for all other cases _flush should be used\n     * */\n    BatchSpanProcessorBase.prototype._flushAll = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            var promises = [];\n            // calculate number of batches\n            var count = Math.ceil(_this._finishedSpans.length / _this._maxExportBatchSize);\n            for (var i = 0, j = count; i < j; i++) {\n                promises.push(_this._flushOneBatch());\n            }\n            Promise.all(promises)\n                .then(function () {\n                resolve();\n            })\n                .catch(reject);\n        });\n    };\n    BatchSpanProcessorBase.prototype._flushOneBatch = function () {\n        var _this = this;\n        this._clearTimer();\n        if (this._finishedSpans.length === 0) {\n            return Promise.resolve();\n        }\n        return new Promise(function (resolve, reject) {\n            var timer = setTimeout(function () {\n                // don't wait anymore for export, this way the next batch can start\n                reject(new Error('Timeout'));\n            }, _this._exportTimeoutMillis);\n            // prevent downstream exporter calls from generating spans\n            context.with(suppressTracing(context.active()), function () {\n                // Reset the finished spans buffer here because the next invocations of the _flush method\n                // could pass the same finished spans to the exporter if the buffer is cleared\n                // outside the execution of this callback.\n                var spans = _this._finishedSpans.splice(0, _this._maxExportBatchSize);\n                var doExport = function () {\n                    return _this._exporter.export(spans, function (result) {\n                        var _a;\n                        clearTimeout(timer);\n                        if (result.code === ExportResultCode.SUCCESS) {\n                            resolve();\n                        }\n                        else {\n                            reject((_a = result.error) !== null && _a !== void 0 ? _a : new Error('BatchSpanProcessor: span export failed'));\n                        }\n                    });\n                };\n                var pendingResources = spans\n                    .map(function (span) { return span.resource; })\n                    .filter(function (resource) { return resource.asyncAttributesPending; });\n                // Avoid scheduling a promise to make the behavior more predictable and easier to test\n                if (pendingResources.length === 0) {\n                    doExport();\n                }\n                else {\n                    Promise.all(pendingResources.map(function (resource) { var _a; return (_a = resource.waitForAsyncAttributes) === null || _a === void 0 ? void 0 : _a.call(resource); })).then(doExport, function (err) {\n                        globalErrorHandler(err);\n                        reject(err);\n                    });\n                }\n            });\n        });\n    };\n    BatchSpanProcessorBase.prototype._maybeStartTimer = function () {\n        var _this = this;\n        if (this._isExporting)\n            return;\n        var flush = function () {\n            _this._isExporting = true;\n            _this._flushOneBatch()\n                .then(function () {\n                _this._isExporting = false;\n                if (_this._finishedSpans.length > 0) {\n                    _this._clearTimer();\n                    _this._maybeStartTimer();\n                }\n            })\n                .catch(function (e) {\n                _this._isExporting = false;\n                globalErrorHandler(e);\n            });\n        };\n        // we only wait if the queue doesn't have enough elements yet\n        if (this._finishedSpans.length >= this._maxExportBatchSize) {\n            return flush();\n        }\n        if (this._timer !== undefined)\n            return;\n        this._timer = setTimeout(function () { return flush(); }, this._scheduledDelayMillis);\n        unrefTimer(this._timer);\n    };\n    BatchSpanProcessorBase.prototype._clearTimer = function () {\n        if (this._timer !== undefined) {\n            clearTimeout(this._timer);\n            this._timer = undefined;\n        }\n    };\n    return BatchSpanProcessorBase;\n}());\nexport { BatchSpanProcessorBase };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}