{"ast":null,"code":"// Copyright (c) 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\n// reverse engineered TBinaryProtocol message envelope spec\n// http://slackhappy.github.io/thriftfiddle/tbinaryspec.html\nvar RW = require('./rw');\nvar util = require('util');\nvar Struct = require('./struct').Struct;\nvar errors = require('./errors');\nvar EMPTY_OBJECT = {};\nvar types = {\n  CALL: 1,\n  REPLY: 2,\n  EXCEPTION: 3,\n  ONEWAY: 4\n};\n// <-> inverse\nvar typeNames = {\n  1: 'CALL',\n  2: 'REPLY',\n  3: 'EXCEPTION',\n  4: 'ONEWAY'\n};\n\n// These are elided syntax trees, to avoid IDL parsing at start time.\n\nvar exceptionTypesDef = {\n  type: 'Enum',\n  id: {\n    name: 'ThriftMessageEnvelopeExceptionType'\n  },\n  definitions: [{\n    id: {\n      name: 'UNKNOWN'\n    },\n    value: {\n      value: 0\n    }\n  }, {\n    id: {\n      name: 'UNKNOWN_METHOD'\n    },\n    value: {\n      value: 1\n    }\n  }, {\n    id: {\n      name: 'INVALID_MESSAGE_TYPE'\n    },\n    value: {\n      value: 2\n    }\n  }, {\n    id: {\n      name: 'WRONG_METHOD_NAME'\n    },\n    value: {\n      value: 3\n    }\n  }, {\n    id: {\n      name: 'BAD_SEQUENCE_ID'\n    },\n    value: {\n      value: 4\n    }\n  }, {\n    id: {\n      name: 'MISSING_RESULT'\n    },\n    value: {\n      value: 5\n    }\n  }, {\n    id: {\n      name: 'INTERNAL_ERROR'\n    },\n    value: {\n      value: 6\n    }\n  }, {\n    id: {\n      name: 'PROTOCOL_ERROR'\n    },\n    value: {\n      value: 7\n    }\n  }, {\n    id: {\n      name: 'INVALID_TRANSFORM'\n    },\n    value: {\n      value: 8\n    }\n  }, {\n    id: {\n      name: 'INVALID_PROTOCOL'\n    },\n    value: {\n      value: 9\n    }\n  }, {\n    id: {\n      name: 'UNSUPPORTED_CLIENT_TYPE'\n    },\n    value: {\n      value: 10\n    }\n  }]\n};\n\n// AST for the implicit exception struct\nvar exceptionDef = {\n  type: 'Struct',\n  id: {\n    name: 'ThriftMessageEnvelopeException'\n  },\n  fields: [{\n    id: {\n      value: 1\n    },\n    name: 'message',\n    valueType: {\n      type: 'BaseType',\n      baseType: 'string'\n    },\n    optional: true,\n    required: false\n  }, {\n    id: {\n      value: 2\n    },\n    name: 'type',\n    valueType: {\n      type: 'Identifier',\n      name: 'ThriftMessageEnvelopeExceptionType'\n    },\n    optional: true,\n    required: false\n  }]\n};\nfunction Message(message) {\n  message = message || EMPTY_OBJECT;\n  this.id = message.id;\n  this.name = message.name;\n  this.body = message.body;\n  this.type = message.type;\n  this.version = message.version || 0; // >0 implies strict\n}\n\nfunction MessageRW(body, exception) {\n  this.body = body;\n  this.exception = exception;\n  RW.call(this);\n}\nutil.inherits(MessageRW, RW);\nMessageRW.prototype.poolByteLength = function poolByteLength(result, message) {\n  // header\n  var length = message.name.length;\n  // names must be half-ascii, so ucs2 length === byte length\n  if (message.version > 0) {\n    // strict\n    // version:2 type:2 name~4 id:4\n    length += 12;\n  } else {\n    // legacy non-strict message header\n    // name~4 type:1 id:4\n    length += 9;\n  }\n  if (message.type === 'EXCEPTION') {\n    result = this.exception.poolByteLength(result, message.body);\n    if (result.err) {\n      return result;\n    }\n    length += result.length;\n    return result.reset(null, length);\n  }\n\n  // body\n  result = this.body.poolByteLength(result, message.body);\n  if (result.err) {\n    return result;\n  }\n  length += result.length;\n  return result.reset(null, length);\n};\nMessageRW.prototype.poolWriteInto = function poolWriteInto(result, message, buffer, offset) {\n  if (message.version > 0) {\n    result = this.poolStrictWriteInto(result, message, buffer, offset);\n  } else {\n    result = this.poolLegacyWriteInto(result, message, buffer, offset);\n  }\n  if (result.err) {\n    return result;\n  }\n  offset = result.offset;\n  if (message.type === 'EXCEPTION') {\n    return this.exception.poolWriteInto(result, message.body, buffer, offset);\n  }\n\n  // write body\n  return this.body.poolWriteInto(result, message.body, buffer, offset);\n};\nMessageRW.prototype.poolStrictWriteInto = function poolStrictWriteInto(result, message, buffer, offset) {\n  // version:2 type:2 name~4 id:4\n\n  // version:2 (with MSB set)\n  buffer.writeUInt16BE(message.version | 0x8000, offset);\n  offset += 2;\n\n  // type:2\n  var type = types[message.type];\n  if (type == null) {\n    return result.reset(new errors.InvalidMessageEnvelopeTypeName({\n      name: message.type\n    }));\n  }\n  buffer.writeUInt16BE(type, offset);\n  offset += 2;\n\n  // name.length:4\n  buffer.writeUInt32BE(message.name.length, offset);\n  offset += 4;\n\n  // name:name.length\n  buffer.write(message.name, offset, 'ascii');\n  offset += message.name.length;\n\n  // id:4\n  buffer.writeUInt32BE(message.id, offset);\n  offset += 4;\n  return result.reset(null, offset);\n};\nMessageRW.prototype.poolLegacyWriteInto = function poolLegacyWriteInto(result, message, buffer, offset) {\n  // name~4 type:1 id:4\n\n  // name.length:4\n  buffer.writeUInt32BE(message.name.length, offset, true);\n  offset += 4;\n\n  // name:name.length\n  buffer.write(message.name, offset, 'ascii');\n  offset += message.name.length;\n\n  // type:1\n  var type = types[message.type];\n  if (type == null) {\n    return result.reset(new errors.InvalidMessageEnvelopeTypeName({\n      name: message.type\n    }));\n  }\n  buffer.writeUInt8(type, offset);\n  offset += 1;\n\n  // id:4\n  buffer.writeUInt32BE(message.id, offset, true);\n  offset += 4;\n  return result.reset(null, offset);\n};\nMessageRW.prototype.poolReadFrom = function poolReadFrom(result, buffer, offset) {\n  var msb = buffer.readInt8(offset, true);\n  if (msb < 0) {\n    result = this.poolStrictReadFrom(result, buffer, offset);\n  } else {\n    result = this.poolLegacyReadFrom(result, buffer, offset);\n  }\n  if (result.err) {\n    return result;\n  }\n  var message = result.value;\n  offset = result.offset;\n  if (message.type === 'EXCEPTION') {\n    result = this.exception.poolReadFrom(result, buffer, offset);\n    if (result.err) {\n      return result;\n    }\n    message.body = result.value;\n    // Decode the enumeration\n    offset += result.offset;\n    return result.reset(message.body, offset, message);\n  }\n\n  // body\n  result = this.body.poolReadFrom(result, buffer, offset);\n  if (result.err) {\n    return result;\n  }\n  message.body = result.value;\n  offset = result.offset;\n  return result.reset(null, offset, message);\n};\nMessageRW.prototype.poolStrictReadFrom = function poolStrictReadFrom(result, buffer, offset) {\n  // the first two bytes might be \"flag\" and \"version\", or just \"version\"\n  // with the MSB flipped to make strict distinguishable.\n  // The type only needs the lesser byte of the available two.\n  // version:2 type:2 name~4 id:4\n\n  var message = new Message();\n  message.version = buffer.readUInt16BE(offset, true) & ~0x8000; // mask out MSB\n  offset += 2;\n  if (message.version !== 1) {\n    return result.reset(new errors.UnrecognizedMessageEnvelopeVersion({\n      version: message.version\n    }));\n  }\n\n  // type:2\n  var type = buffer.readUInt16BE(offset, true) & 0xFF;\n  offset += 2;\n  message.type = typeNames[type];\n  if (message.type == null) {\n    return result.reset(new errors.UnrecognizedMessageEnvelopeType({\n      value: type\n    }));\n  }\n\n  // name.length:4\n  var length = buffer.readUInt32BE(offset, true);\n  offset += 4;\n\n  // name:name.length\n  message.name = buffer.toString('ascii', offset, offset + length, true);\n  offset += length;\n\n  // id:4\n  message.id = buffer.readUInt32BE(offset, true);\n  offset += 4;\n  return result.reset(null, offset, message);\n};\nMessageRW.prototype.poolLegacyReadFrom = function poolLegacyReadFrom(result, buffer, offset) {\n  // name~4 type:1 id:4\n  var message = new Message();\n\n  // name.length\n  var length = buffer.readUInt32BE(offset, true);\n  offset += 4;\n\n  // name:name.length\n  message.name = buffer.toString('ascii', offset, offset + length, true);\n  offset += length;\n\n  // type:2\n  var type = buffer.readUInt8(offset, true);\n  offset += 1;\n\n  // id:4\n  message.id = buffer.readUInt32BE(offset, true);\n  offset += 4;\n  message.type = typeNames[type];\n  if (message.type == null) {\n    return result.reset(new errors.UnrecognizedMessageEnvelopeType({\n      value: type\n    }));\n  }\n  return result.reset(null, offset, message);\n};\nmodule.exports.Message = Message;\nmodule.exports.MessageRW = MessageRW;\nmodule.exports.types = types;\nmodule.exports.typeNames = typeNames;\nmodule.exports.exceptionDef = exceptionDef;\nmodule.exports.exceptionTypesDef = exceptionTypesDef;","map":{"version":3,"names":["RW","require","util","Struct","errors","EMPTY_OBJECT","types","CALL","REPLY","EXCEPTION","ONEWAY","typeNames","exceptionTypesDef","type","id","name","definitions","value","exceptionDef","fields","valueType","baseType","optional","required","Message","message","body","version","MessageRW","exception","call","inherits","prototype","poolByteLength","result","length","err","reset","poolWriteInto","buffer","offset","poolStrictWriteInto","poolLegacyWriteInto","writeUInt16BE","InvalidMessageEnvelopeTypeName","writeUInt32BE","write","writeUInt8","poolReadFrom","msb","readInt8","poolStrictReadFrom","poolLegacyReadFrom","readUInt16BE","UnrecognizedMessageEnvelopeVersion","UnrecognizedMessageEnvelopeType","readUInt32BE","toString","readUInt8","module","exports"],"sources":["/home/bvpelt/Develop/openteltest/node_modules/thriftrw/message.js"],"sourcesContent":["// Copyright (c) 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\n// reverse engineered TBinaryProtocol message envelope spec\n// http://slackhappy.github.io/thriftfiddle/tbinaryspec.html\n\nvar RW = require('./rw');\nvar util = require('util');\nvar Struct = require('./struct').Struct;\nvar errors = require('./errors');\n\nvar EMPTY_OBJECT = {};\n\nvar types = {\n    CALL: 1,\n    REPLY: 2,\n    EXCEPTION: 3,\n    ONEWAY: 4\n};\n// <-> inverse\nvar typeNames = {\n    1: 'CALL',\n    2: 'REPLY',\n    3: 'EXCEPTION',\n    4: 'ONEWAY'\n};\n\n// These are elided syntax trees, to avoid IDL parsing at start time.\n\nvar exceptionTypesDef = {\n    type: 'Enum',\n    id: {name: 'ThriftMessageEnvelopeExceptionType'},\n    definitions: [\n        {id: {name: 'UNKNOWN'},                 value: {value: 0}},\n        {id: {name: 'UNKNOWN_METHOD'},          value: {value: 1}},\n        {id: {name: 'INVALID_MESSAGE_TYPE'},    value: {value: 2}},\n        {id: {name: 'WRONG_METHOD_NAME'},       value: {value: 3}},\n        {id: {name: 'BAD_SEQUENCE_ID'},         value: {value: 4}},\n        {id: {name: 'MISSING_RESULT'},          value: {value: 5}},\n        {id: {name: 'INTERNAL_ERROR'},          value: {value: 6}},\n        {id: {name: 'PROTOCOL_ERROR'},          value: {value: 7}},\n        {id: {name: 'INVALID_TRANSFORM'},       value: {value: 8}},\n        {id: {name: 'INVALID_PROTOCOL'},        value: {value: 9}},\n        {id: {name: 'UNSUPPORTED_CLIENT_TYPE'}, value: {value: 10}}\n    ]\n};\n\n// AST for the implicit exception struct\nvar exceptionDef = {\n    type: 'Struct',\n    id: {name: 'ThriftMessageEnvelopeException'},\n    fields: [\n        {\n            id: {value: 1},\n            name: 'message',\n            valueType: {\n                type: 'BaseType',\n                baseType: 'string'\n            },\n            optional: true,\n            required: false\n        },\n        {\n            id: {value: 2},\n            name: 'type',\n            valueType: {\n                type: 'Identifier',\n                name: 'ThriftMessageEnvelopeExceptionType'\n            },\n            optional: true,\n            required: false\n        }\n    ]\n};\n\nfunction Message(message) {\n    message = message || EMPTY_OBJECT;\n    this.id = message.id;\n    this.name = message.name;\n    this.body = message.body;\n    this.type = message.type;\n    this.version = message.version || 0; // >0 implies strict\n}\n\nfunction MessageRW(body, exception) {\n    this.body = body;\n    this.exception = exception;\n    RW.call(this);\n}\nutil.inherits(MessageRW, RW);\n\nMessageRW.prototype.poolByteLength = function poolByteLength(result, message) {\n    // header\n    var length = message.name.length;\n    // names must be half-ascii, so ucs2 length === byte length\n    if (message.version > 0) { // strict\n        // version:2 type:2 name~4 id:4\n        length += 12;\n    } else { // legacy non-strict message header\n        // name~4 type:1 id:4\n        length += 9;\n    }\n\n    if (message.type === 'EXCEPTION') {\n        result = this.exception.poolByteLength(result, message.body);\n        if (result.err) {\n            return result;\n        }\n        length += result.length;\n        return result.reset(null, length);\n    }\n\n    // body\n    result = this.body.poolByteLength(result, message.body);\n    if (result.err) {\n        return result;\n    }\n    length += result.length;\n\n    return result.reset(null, length);\n};\n\nMessageRW.prototype.poolWriteInto = function poolWriteInto(result, message, buffer, offset) {\n    if (message.version > 0) {\n        result = this.poolStrictWriteInto(result, message, buffer, offset);\n    } else {\n        result = this.poolLegacyWriteInto(result, message, buffer, offset);\n    }\n    if (result.err) {\n        return result;\n    }\n    offset = result.offset;\n\n    if (message.type === 'EXCEPTION') {\n        return this.exception.poolWriteInto(result, message.body, buffer, offset);\n    }\n\n    // write body\n    return this.body.poolWriteInto(result, message.body, buffer, offset);\n};\n\nMessageRW.prototype.poolStrictWriteInto = function poolStrictWriteInto(result, message, buffer, offset) {\n    // version:2 type:2 name~4 id:4\n\n    // version:2 (with MSB set)\n    buffer.writeUInt16BE(message.version | 0x8000, offset);\n    offset += 2;\n\n    // type:2\n    var type = types[message.type];\n    if (type == null) {\n        return result.reset(new errors.InvalidMessageEnvelopeTypeName({\n            name: message.type\n        }));\n    }\n    buffer.writeUInt16BE(type, offset);\n    offset += 2;\n\n    // name.length:4\n    buffer.writeUInt32BE(message.name.length, offset);\n    offset += 4;\n\n    // name:name.length\n    buffer.write(message.name, offset, 'ascii');\n    offset += message.name.length;\n\n    // id:4\n    buffer.writeUInt32BE(message.id, offset);\n    offset += 4;\n\n    return result.reset(null, offset);\n};\n\nMessageRW.prototype.poolLegacyWriteInto = function poolLegacyWriteInto(result, message, buffer, offset) {\n    // name~4 type:1 id:4\n\n    // name.length:4\n    buffer.writeUInt32BE(message.name.length, offset, true);\n    offset += 4;\n\n    // name:name.length\n    buffer.write(message.name, offset, 'ascii');\n    offset += message.name.length;\n\n    // type:1\n    var type = types[message.type];\n    if (type == null) {\n        return result.reset(new errors.InvalidMessageEnvelopeTypeName({\n            name: message.type\n        }));\n    }\n    buffer.writeUInt8(type, offset);\n    offset += 1;\n\n    // id:4\n    buffer.writeUInt32BE(message.id, offset, true);\n    offset += 4;\n\n    return result.reset(null, offset);\n};\n\nMessageRW.prototype.poolReadFrom = function poolReadFrom(result, buffer, offset) {\n    var msb = buffer.readInt8(offset, true);\n    if (msb < 0) {\n        result = this.poolStrictReadFrom(result, buffer, offset);\n    } else {\n        result = this.poolLegacyReadFrom(result, buffer, offset);\n    }\n    if (result.err) {\n        return result;\n    }\n    var message = result.value;\n    offset = result.offset;\n\n    if (message.type === 'EXCEPTION') {\n        result = this.exception.poolReadFrom(result, buffer, offset);\n        if (result.err) {\n            return result;\n        }\n        message.body = result.value;\n        // Decode the enumeration\n        offset += result.offset;\n        return result.reset(message.body, offset, message);\n    }\n\n    // body\n    result = this.body.poolReadFrom(result, buffer, offset);\n    if (result.err) {\n        return result;\n    }\n    message.body = result.value;\n    offset = result.offset;\n\n    return result.reset(null, offset, message);\n};\n\nMessageRW.prototype.poolStrictReadFrom = function poolStrictReadFrom(result, buffer, offset) {\n    // the first two bytes might be \"flag\" and \"version\", or just \"version\"\n    // with the MSB flipped to make strict distinguishable.\n    // The type only needs the lesser byte of the available two.\n    // version:2 type:2 name~4 id:4\n\n    var message = new Message();\n    message.version = buffer.readUInt16BE(offset, true) & ~0x8000; // mask out MSB\n    offset += 2;\n\n    if (message.version !== 1) {\n        return result.reset(new errors.UnrecognizedMessageEnvelopeVersion({\n            version: message.version\n        }));\n    }\n\n    // type:2\n    var type = buffer.readUInt16BE(offset, true) & 0xFF;\n    offset += 2;\n\n    message.type = typeNames[type];\n    if (message.type == null) {\n        return result.reset(new errors.UnrecognizedMessageEnvelopeType({\n            value: type\n        }));\n    }\n\n    // name.length:4\n    var length = buffer.readUInt32BE(offset, true);\n    offset += 4;\n\n    // name:name.length\n    message.name = buffer.toString('ascii', offset, offset + length, true);\n    offset += length;\n\n    // id:4\n    message.id = buffer.readUInt32BE(offset, true);\n    offset += 4;\n\n    return result.reset(null, offset, message);\n};\n\nMessageRW.prototype.poolLegacyReadFrom = function poolLegacyReadFrom(result, buffer, offset) {\n    // name~4 type:1 id:4\n    var message = new Message();\n\n    // name.length\n    var length = buffer.readUInt32BE(offset, true);\n    offset += 4;\n\n    // name:name.length\n    message.name = buffer.toString('ascii', offset, offset + length, true);\n    offset += length;\n\n    // type:2\n    var type = buffer.readUInt8(offset, true);\n    offset += 1;\n\n    // id:4\n    message.id = buffer.readUInt32BE(offset, true);\n    offset += 4;\n\n    message.type = typeNames[type];\n    if (message.type == null) {\n        return result.reset(new errors.UnrecognizedMessageEnvelopeType({\n            value: type\n        }));\n    }\n\n    return result.reset(null, offset, message);\n};\n\nmodule.exports.Message = Message;\nmodule.exports.MessageRW = MessageRW;\nmodule.exports.types = types;\nmodule.exports.typeNames = typeNames;\nmodule.exports.exceptionDef = exceptionDef;\nmodule.exports.exceptionTypesDef = exceptionTypesDef;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}