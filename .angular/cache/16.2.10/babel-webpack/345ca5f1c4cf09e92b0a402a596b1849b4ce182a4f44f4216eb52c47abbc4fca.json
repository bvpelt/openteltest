{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { MetricStorage } from './MetricStorage';\nimport { DeltaMetricProcessor } from './DeltaMetricProcessor';\nimport { TemporalMetricProcessor } from './TemporalMetricProcessor';\nimport { AttributeHashMap } from './HashMap';\n/**\n * Internal interface.\n *\n * Stores and aggregates {@link MetricData} for asynchronous instruments.\n */\nvar AsyncMetricStorage = /** @class */function (_super) {\n  __extends(AsyncMetricStorage, _super);\n  function AsyncMetricStorage(_instrumentDescriptor, aggregator, _attributesProcessor, collectorHandles) {\n    var _this = _super.call(this, _instrumentDescriptor) || this;\n    _this._attributesProcessor = _attributesProcessor;\n    _this._deltaMetricStorage = new DeltaMetricProcessor(aggregator);\n    _this._temporalMetricStorage = new TemporalMetricProcessor(aggregator, collectorHandles);\n    return _this;\n  }\n  AsyncMetricStorage.prototype.record = function (measurements, observationTime) {\n    var _this = this;\n    var processed = new AttributeHashMap();\n    Array.from(measurements.entries()).forEach(function (_a) {\n      var _b = __read(_a, 2),\n        attributes = _b[0],\n        value = _b[1];\n      processed.set(_this._attributesProcessor.process(attributes), value);\n    });\n    this._deltaMetricStorage.batchCumulate(processed, observationTime);\n  };\n  /**\n   * Collects the metrics from this storage. The ObservableCallback is invoked\n   * during the collection.\n   *\n   * Note: This is a stateful operation and may reset any interval-related\n   * state for the MetricCollector.\n   */\n  AsyncMetricStorage.prototype.collect = function (collector, collectionTime) {\n    var accumulations = this._deltaMetricStorage.collect();\n    return this._temporalMetricStorage.buildMetrics(collector, this._instrumentDescriptor, accumulations, collectionTime);\n  };\n  return AsyncMetricStorage;\n}(MetricStorage);\nexport { AsyncMetricStorage };","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","__read","o","n","m","Symbol","iterator","i","r","ar","e","next","done","push","value","error","MetricStorage","DeltaMetricProcessor","TemporalMetricProcessor","AttributeHashMap","AsyncMetricStorage","_super","_instrumentDescriptor","aggregator","_attributesProcessor","collectorHandles","_this","_deltaMetricStorage","_temporalMetricStorage","record","measurements","observationTime","processed","from","entries","forEach","_a","_b","attributes","set","process","batchCumulate","collect","collector","collectionTime","accumulations","buildMetrics"],"sources":["/home/bvpelt/Develop/openteltest/node_modules/@opentelemetry/sdk-metrics/build/esm/state/AsyncMetricStorage.js"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { MetricStorage } from './MetricStorage';\nimport { DeltaMetricProcessor } from './DeltaMetricProcessor';\nimport { TemporalMetricProcessor } from './TemporalMetricProcessor';\nimport { AttributeHashMap } from './HashMap';\n/**\n * Internal interface.\n *\n * Stores and aggregates {@link MetricData} for asynchronous instruments.\n */\nvar AsyncMetricStorage = /** @class */ (function (_super) {\n    __extends(AsyncMetricStorage, _super);\n    function AsyncMetricStorage(_instrumentDescriptor, aggregator, _attributesProcessor, collectorHandles) {\n        var _this = _super.call(this, _instrumentDescriptor) || this;\n        _this._attributesProcessor = _attributesProcessor;\n        _this._deltaMetricStorage = new DeltaMetricProcessor(aggregator);\n        _this._temporalMetricStorage = new TemporalMetricProcessor(aggregator, collectorHandles);\n        return _this;\n    }\n    AsyncMetricStorage.prototype.record = function (measurements, observationTime) {\n        var _this = this;\n        var processed = new AttributeHashMap();\n        Array.from(measurements.entries()).forEach(function (_a) {\n            var _b = __read(_a, 2), attributes = _b[0], value = _b[1];\n            processed.set(_this._attributesProcessor.process(attributes), value);\n        });\n        this._deltaMetricStorage.batchCumulate(processed, observationTime);\n    };\n    /**\n     * Collects the metrics from this storage. The ObservableCallback is invoked\n     * during the collection.\n     *\n     * Note: This is a stateful operation and may reset any interval-related\n     * state for the MetricCollector.\n     */\n    AsyncMetricStorage.prototype.collect = function (collector, collectionTime) {\n        var accumulations = this._deltaMetricStorage.collect();\n        return this._temporalMetricStorage.buildMetrics(collector, this._instrumentDescriptor, accumulations, collectionTime);\n    };\n    return AsyncMetricStorage;\n}(MetricStorage));\nexport { AsyncMetricStorage };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}