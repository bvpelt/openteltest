{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { diag, SpanStatusCode } from '@opentelemetry/api';\nimport { addHrTimes, millisToHrTime, getTimeOrigin, hrTime, hrTimeDuration, isAttributeValue, isTimeInput, isTimeInputHrTime, otperformance, sanitizeAttributes } from '@opentelemetry/core';\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions';\nimport { ExceptionEventName } from './enums';\n/**\n * This class represents a span.\n */\nvar Span = /** @class */function () {\n  /**\n   * Constructs a new Span instance.\n   *\n   * @deprecated calling Span constructor directly is not supported. Please use tracer.startSpan.\n   * */\n  function Span(parentTracer, context, spanName, spanContext, kind, parentSpanId, links, startTime, _deprecatedClock // keeping this argument even though it is unused to ensure backwards compatibility\n  ) {\n    if (links === void 0) {\n      links = [];\n    }\n    this.attributes = {};\n    this.links = [];\n    this.events = [];\n    this._droppedAttributesCount = 0;\n    this._droppedEventsCount = 0;\n    this._droppedLinksCount = 0;\n    this.status = {\n      code: SpanStatusCode.UNSET\n    };\n    this.endTime = [0, 0];\n    this._ended = false;\n    this._duration = [-1, -1];\n    this.name = spanName;\n    this._spanContext = spanContext;\n    this.parentSpanId = parentSpanId;\n    this.kind = kind;\n    this.links = links;\n    var now = Date.now();\n    this._performanceStartTime = otperformance.now();\n    this._performanceOffset = now - (this._performanceStartTime + getTimeOrigin());\n    this._startTimeProvided = startTime != null;\n    this.startTime = this._getTime(startTime !== null && startTime !== void 0 ? startTime : now);\n    this.resource = parentTracer.resource;\n    this.instrumentationLibrary = parentTracer.instrumentationLibrary;\n    this._spanLimits = parentTracer.getSpanLimits();\n    this._spanProcessor = parentTracer.getActiveSpanProcessor();\n    this._spanProcessor.onStart(this, context);\n    this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;\n  }\n  Span.prototype.spanContext = function () {\n    return this._spanContext;\n  };\n  Span.prototype.setAttribute = function (key, value) {\n    if (value == null || this._isSpanEnded()) return this;\n    if (key.length === 0) {\n      diag.warn(\"Invalid attribute key: \" + key);\n      return this;\n    }\n    if (!isAttributeValue(value)) {\n      diag.warn(\"Invalid attribute value set for key: \" + key);\n      return this;\n    }\n    if (Object.keys(this.attributes).length >= this._spanLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {\n      this._droppedAttributesCount++;\n      return this;\n    }\n    this.attributes[key] = this._truncateToSize(value);\n    return this;\n  };\n  Span.prototype.setAttributes = function (attributes) {\n    var e_1, _a;\n    try {\n      for (var _b = __values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = __read(_c.value, 2),\n          k = _d[0],\n          v = _d[1];\n        this.setAttribute(k, v);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return this;\n  };\n  /**\n   *\n   * @param name Span Name\n   * @param [attributesOrStartTime] Span attributes or start time\n   *     if type is {@type TimeInput} and 3rd param is undefined\n   * @param [timeStamp] Specified time stamp for the event\n   */\n  Span.prototype.addEvent = function (name, attributesOrStartTime, timeStamp) {\n    if (this._isSpanEnded()) return this;\n    if (this._spanLimits.eventCountLimit === 0) {\n      diag.warn('No events allowed.');\n      this._droppedEventsCount++;\n      return this;\n    }\n    if (this.events.length >= this._spanLimits.eventCountLimit) {\n      diag.warn('Dropping extra events.');\n      this.events.shift();\n      this._droppedEventsCount++;\n    }\n    if (isTimeInput(attributesOrStartTime)) {\n      if (!isTimeInput(timeStamp)) {\n        timeStamp = attributesOrStartTime;\n      }\n      attributesOrStartTime = undefined;\n    }\n    var attributes = sanitizeAttributes(attributesOrStartTime);\n    this.events.push({\n      name: name,\n      attributes: attributes,\n      time: this._getTime(timeStamp),\n      droppedAttributesCount: 0\n    });\n    return this;\n  };\n  Span.prototype.setStatus = function (status) {\n    if (this._isSpanEnded()) return this;\n    this.status = status;\n    return this;\n  };\n  Span.prototype.updateName = function (name) {\n    if (this._isSpanEnded()) return this;\n    this.name = name;\n    return this;\n  };\n  Span.prototype.end = function (endTime) {\n    if (this._isSpanEnded()) {\n      diag.error(this.name + \" \" + this._spanContext.traceId + \"-\" + this._spanContext.spanId + \" - You can only call end() on a span once.\");\n      return;\n    }\n    this._ended = true;\n    this.endTime = this._getTime(endTime);\n    this._duration = hrTimeDuration(this.startTime, this.endTime);\n    if (this._duration[0] < 0) {\n      diag.warn('Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.', this.startTime, this.endTime);\n      this.endTime = this.startTime.slice();\n      this._duration = [0, 0];\n    }\n    this._spanProcessor.onEnd(this);\n  };\n  Span.prototype._getTime = function (inp) {\n    if (typeof inp === 'number' && inp < otperformance.now()) {\n      // must be a performance timestamp\n      // apply correction and convert to hrtime\n      return hrTime(inp + this._performanceOffset);\n    }\n    if (typeof inp === 'number') {\n      return millisToHrTime(inp);\n    }\n    if (inp instanceof Date) {\n      return millisToHrTime(inp.getTime());\n    }\n    if (isTimeInputHrTime(inp)) {\n      return inp;\n    }\n    if (this._startTimeProvided) {\n      // if user provided a time for the start manually\n      // we can't use duration to calculate event/end times\n      return millisToHrTime(Date.now());\n    }\n    var msDuration = otperformance.now() - this._performanceStartTime;\n    return addHrTimes(this.startTime, millisToHrTime(msDuration));\n  };\n  Span.prototype.isRecording = function () {\n    return this._ended === false;\n  };\n  Span.prototype.recordException = function (exception, time) {\n    var attributes = {};\n    if (typeof exception === 'string') {\n      attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception;\n    } else if (exception) {\n      if (exception.code) {\n        attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.code.toString();\n      } else if (exception.name) {\n        attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.name;\n      }\n      if (exception.message) {\n        attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception.message;\n      }\n      if (exception.stack) {\n        attributes[SemanticAttributes.EXCEPTION_STACKTRACE] = exception.stack;\n      }\n    }\n    // these are minimum requirements from spec\n    if (attributes[SemanticAttributes.EXCEPTION_TYPE] || attributes[SemanticAttributes.EXCEPTION_MESSAGE]) {\n      this.addEvent(ExceptionEventName, attributes, time);\n    } else {\n      diag.warn(\"Failed to record an exception \" + exception);\n    }\n  };\n  Object.defineProperty(Span.prototype, \"duration\", {\n    get: function () {\n      return this._duration;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Span.prototype, \"ended\", {\n    get: function () {\n      return this._ended;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Span.prototype, \"droppedAttributesCount\", {\n    get: function () {\n      return this._droppedAttributesCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Span.prototype, \"droppedEventsCount\", {\n    get: function () {\n      return this._droppedEventsCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Span.prototype, \"droppedLinksCount\", {\n    get: function () {\n      return this._droppedLinksCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Span.prototype._isSpanEnded = function () {\n    if (this._ended) {\n      diag.warn(\"Can not execute the operation on ended Span {traceId: \" + this._spanContext.traceId + \", spanId: \" + this._spanContext.spanId + \"}\");\n    }\n    return this._ended;\n  };\n  // Utility function to truncate given value within size\n  // for value type of string, will truncate to given limit\n  // for type of non-string, will return same value\n  Span.prototype._truncateToLimitUtil = function (value, limit) {\n    if (value.length <= limit) {\n      return value;\n    }\n    return value.substr(0, limit);\n  };\n  /**\n   * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then\n   * return string with trucated to {@code attributeValueLengthLimit} characters\n   *\n   * If the given attribute value is array of strings then\n   * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters\n   *\n   * Otherwise return same Attribute {@code value}\n   *\n   * @param value Attribute value\n   * @returns truncated attribute value if required, otherwise same value\n   */\n  Span.prototype._truncateToSize = function (value) {\n    var _this = this;\n    var limit = this._attributeValueLengthLimit;\n    // Check limit\n    if (limit <= 0) {\n      // Negative values are invalid, so do not truncate\n      diag.warn(\"Attribute value limit must be positive, got \" + limit);\n      return value;\n    }\n    // String\n    if (typeof value === 'string') {\n      return this._truncateToLimitUtil(value, limit);\n    }\n    // Array of strings\n    if (Array.isArray(value)) {\n      return value.map(function (val) {\n        return typeof val === 'string' ? _this._truncateToLimitUtil(val, limit) : val;\n      });\n    }\n    // Other types, no need to apply value length limit\n    return value;\n  };\n  return Span;\n}();\nexport { Span };","map":{"version":3,"names":["__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","__read","n","r","ar","e","push","error","diag","SpanStatusCode","addHrTimes","millisToHrTime","getTimeOrigin","hrTime","hrTimeDuration","isAttributeValue","isTimeInput","isTimeInputHrTime","otperformance","sanitizeAttributes","SemanticAttributes","ExceptionEventName","Span","parentTracer","context","spanName","spanContext","kind","parentSpanId","links","startTime","_deprecatedClock","attributes","events","_droppedAttributesCount","_droppedEventsCount","_droppedLinksCount","status","code","UNSET","endTime","_ended","_duration","name","_spanContext","now","Date","_performanceStartTime","_performanceOffset","_startTimeProvided","_getTime","resource","instrumentationLibrary","_spanLimits","getSpanLimits","_spanProcessor","getActiveSpanProcessor","onStart","_attributeValueLengthLimit","attributeValueLengthLimit","prototype","setAttribute","key","_isSpanEnded","warn","Object","keys","attributeCountLimit","hasOwnProperty","_truncateToSize","setAttributes","e_1","_a","_b","entries","_c","_d","k","v","e_1_1","return","addEvent","attributesOrStartTime","timeStamp","eventCountLimit","shift","undefined","time","droppedAttributesCount","setStatus","updateName","end","traceId","spanId","slice","onEnd","inp","getTime","msDuration","isRecording","recordException","exception","EXCEPTION_MESSAGE","EXCEPTION_TYPE","toString","message","stack","EXCEPTION_STACKTRACE","defineProperty","get","enumerable","configurable","_truncateToLimitUtil","limit","substr","_this","Array","isArray","map","val"],"sources":["/home/bvpelt/Develop/openteltest/node_modules/@opentelemetry/instrumentation-fetch/node_modules/@opentelemetry/sdk-trace-web/node_modules/@opentelemetry/sdk-trace-base/build/esm/Span.js"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { diag, SpanStatusCode, } from '@opentelemetry/api';\nimport { addHrTimes, millisToHrTime, getTimeOrigin, hrTime, hrTimeDuration, isAttributeValue, isTimeInput, isTimeInputHrTime, otperformance, sanitizeAttributes, } from '@opentelemetry/core';\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions';\nimport { ExceptionEventName } from './enums';\n/**\n * This class represents a span.\n */\nvar Span = /** @class */ (function () {\n    /**\n     * Constructs a new Span instance.\n     *\n     * @deprecated calling Span constructor directly is not supported. Please use tracer.startSpan.\n     * */\n    function Span(parentTracer, context, spanName, spanContext, kind, parentSpanId, links, startTime, _deprecatedClock // keeping this argument even though it is unused to ensure backwards compatibility\n    ) {\n        if (links === void 0) { links = []; }\n        this.attributes = {};\n        this.links = [];\n        this.events = [];\n        this._droppedAttributesCount = 0;\n        this._droppedEventsCount = 0;\n        this._droppedLinksCount = 0;\n        this.status = {\n            code: SpanStatusCode.UNSET,\n        };\n        this.endTime = [0, 0];\n        this._ended = false;\n        this._duration = [-1, -1];\n        this.name = spanName;\n        this._spanContext = spanContext;\n        this.parentSpanId = parentSpanId;\n        this.kind = kind;\n        this.links = links;\n        var now = Date.now();\n        this._performanceStartTime = otperformance.now();\n        this._performanceOffset =\n            now - (this._performanceStartTime + getTimeOrigin());\n        this._startTimeProvided = startTime != null;\n        this.startTime = this._getTime(startTime !== null && startTime !== void 0 ? startTime : now);\n        this.resource = parentTracer.resource;\n        this.instrumentationLibrary = parentTracer.instrumentationLibrary;\n        this._spanLimits = parentTracer.getSpanLimits();\n        this._spanProcessor = parentTracer.getActiveSpanProcessor();\n        this._spanProcessor.onStart(this, context);\n        this._attributeValueLengthLimit =\n            this._spanLimits.attributeValueLengthLimit || 0;\n    }\n    Span.prototype.spanContext = function () {\n        return this._spanContext;\n    };\n    Span.prototype.setAttribute = function (key, value) {\n        if (value == null || this._isSpanEnded())\n            return this;\n        if (key.length === 0) {\n            diag.warn(\"Invalid attribute key: \" + key);\n            return this;\n        }\n        if (!isAttributeValue(value)) {\n            diag.warn(\"Invalid attribute value set for key: \" + key);\n            return this;\n        }\n        if (Object.keys(this.attributes).length >=\n            this._spanLimits.attributeCountLimit &&\n            !Object.prototype.hasOwnProperty.call(this.attributes, key)) {\n            this._droppedAttributesCount++;\n            return this;\n        }\n        this.attributes[key] = this._truncateToSize(value);\n        return this;\n    };\n    Span.prototype.setAttributes = function (attributes) {\n        var e_1, _a;\n        try {\n            for (var _b = __values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var _d = __read(_c.value, 2), k = _d[0], v = _d[1];\n                this.setAttribute(k, v);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return this;\n    };\n    /**\n     *\n     * @param name Span Name\n     * @param [attributesOrStartTime] Span attributes or start time\n     *     if type is {@type TimeInput} and 3rd param is undefined\n     * @param [timeStamp] Specified time stamp for the event\n     */\n    Span.prototype.addEvent = function (name, attributesOrStartTime, timeStamp) {\n        if (this._isSpanEnded())\n            return this;\n        if (this._spanLimits.eventCountLimit === 0) {\n            diag.warn('No events allowed.');\n            this._droppedEventsCount++;\n            return this;\n        }\n        if (this.events.length >= this._spanLimits.eventCountLimit) {\n            diag.warn('Dropping extra events.');\n            this.events.shift();\n            this._droppedEventsCount++;\n        }\n        if (isTimeInput(attributesOrStartTime)) {\n            if (!isTimeInput(timeStamp)) {\n                timeStamp = attributesOrStartTime;\n            }\n            attributesOrStartTime = undefined;\n        }\n        var attributes = sanitizeAttributes(attributesOrStartTime);\n        this.events.push({\n            name: name,\n            attributes: attributes,\n            time: this._getTime(timeStamp),\n            droppedAttributesCount: 0,\n        });\n        return this;\n    };\n    Span.prototype.setStatus = function (status) {\n        if (this._isSpanEnded())\n            return this;\n        this.status = status;\n        return this;\n    };\n    Span.prototype.updateName = function (name) {\n        if (this._isSpanEnded())\n            return this;\n        this.name = name;\n        return this;\n    };\n    Span.prototype.end = function (endTime) {\n        if (this._isSpanEnded()) {\n            diag.error(this.name + \" \" + this._spanContext.traceId + \"-\" + this._spanContext.spanId + \" - You can only call end() on a span once.\");\n            return;\n        }\n        this._ended = true;\n        this.endTime = this._getTime(endTime);\n        this._duration = hrTimeDuration(this.startTime, this.endTime);\n        if (this._duration[0] < 0) {\n            diag.warn('Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.', this.startTime, this.endTime);\n            this.endTime = this.startTime.slice();\n            this._duration = [0, 0];\n        }\n        this._spanProcessor.onEnd(this);\n    };\n    Span.prototype._getTime = function (inp) {\n        if (typeof inp === 'number' && inp < otperformance.now()) {\n            // must be a performance timestamp\n            // apply correction and convert to hrtime\n            return hrTime(inp + this._performanceOffset);\n        }\n        if (typeof inp === 'number') {\n            return millisToHrTime(inp);\n        }\n        if (inp instanceof Date) {\n            return millisToHrTime(inp.getTime());\n        }\n        if (isTimeInputHrTime(inp)) {\n            return inp;\n        }\n        if (this._startTimeProvided) {\n            // if user provided a time for the start manually\n            // we can't use duration to calculate event/end times\n            return millisToHrTime(Date.now());\n        }\n        var msDuration = otperformance.now() - this._performanceStartTime;\n        return addHrTimes(this.startTime, millisToHrTime(msDuration));\n    };\n    Span.prototype.isRecording = function () {\n        return this._ended === false;\n    };\n    Span.prototype.recordException = function (exception, time) {\n        var attributes = {};\n        if (typeof exception === 'string') {\n            attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception;\n        }\n        else if (exception) {\n            if (exception.code) {\n                attributes[SemanticAttributes.EXCEPTION_TYPE] =\n                    exception.code.toString();\n            }\n            else if (exception.name) {\n                attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.name;\n            }\n            if (exception.message) {\n                attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception.message;\n            }\n            if (exception.stack) {\n                attributes[SemanticAttributes.EXCEPTION_STACKTRACE] = exception.stack;\n            }\n        }\n        // these are minimum requirements from spec\n        if (attributes[SemanticAttributes.EXCEPTION_TYPE] ||\n            attributes[SemanticAttributes.EXCEPTION_MESSAGE]) {\n            this.addEvent(ExceptionEventName, attributes, time);\n        }\n        else {\n            diag.warn(\"Failed to record an exception \" + exception);\n        }\n    };\n    Object.defineProperty(Span.prototype, \"duration\", {\n        get: function () {\n            return this._duration;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Span.prototype, \"ended\", {\n        get: function () {\n            return this._ended;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Span.prototype, \"droppedAttributesCount\", {\n        get: function () {\n            return this._droppedAttributesCount;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Span.prototype, \"droppedEventsCount\", {\n        get: function () {\n            return this._droppedEventsCount;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Span.prototype, \"droppedLinksCount\", {\n        get: function () {\n            return this._droppedLinksCount;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Span.prototype._isSpanEnded = function () {\n        if (this._ended) {\n            diag.warn(\"Can not execute the operation on ended Span {traceId: \" + this._spanContext.traceId + \", spanId: \" + this._spanContext.spanId + \"}\");\n        }\n        return this._ended;\n    };\n    // Utility function to truncate given value within size\n    // for value type of string, will truncate to given limit\n    // for type of non-string, will return same value\n    Span.prototype._truncateToLimitUtil = function (value, limit) {\n        if (value.length <= limit) {\n            return value;\n        }\n        return value.substr(0, limit);\n    };\n    /**\n     * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then\n     * return string with trucated to {@code attributeValueLengthLimit} characters\n     *\n     * If the given attribute value is array of strings then\n     * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters\n     *\n     * Otherwise return same Attribute {@code value}\n     *\n     * @param value Attribute value\n     * @returns truncated attribute value if required, otherwise same value\n     */\n    Span.prototype._truncateToSize = function (value) {\n        var _this = this;\n        var limit = this._attributeValueLengthLimit;\n        // Check limit\n        if (limit <= 0) {\n            // Negative values are invalid, so do not truncate\n            diag.warn(\"Attribute value limit must be positive, got \" + limit);\n            return value;\n        }\n        // String\n        if (typeof value === 'string') {\n            return this._truncateToLimitUtil(value, limit);\n        }\n        // Array of strings\n        if (Array.isArray(value)) {\n            return value.map(function (val) {\n                return typeof val === 'string' ? _this._truncateToLimitUtil(val, limit) : val;\n            });\n        }\n        // Other types, no need to apply value length limit\n        return value;\n    };\n    return Span;\n}());\nexport { Span };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,QAAQ,GAAI,IAAI,IAAI,IAAI,CAACA,QAAQ,IAAK,UAASC,CAAC,EAAE;EAClD,IAAIC,CAAC,GAAG,OAAOC,MAAM,KAAK,UAAU,IAAIA,MAAM,CAACC,QAAQ;IAAEC,CAAC,GAAGH,CAAC,IAAID,CAAC,CAACC,CAAC,CAAC;IAAEI,CAAC,GAAG,CAAC;EAC7E,IAAID,CAAC,EAAE,OAAOA,CAAC,CAACE,IAAI,CAACN,CAAC,CAAC;EACvB,IAAIA,CAAC,IAAI,OAAOA,CAAC,CAACO,MAAM,KAAK,QAAQ,EAAE,OAAO;IAC1CC,IAAI,EAAE,SAAAA,CAAA,EAAY;MACd,IAAIR,CAAC,IAAIK,CAAC,IAAIL,CAAC,CAACO,MAAM,EAAEP,CAAC,GAAG,KAAK,CAAC;MAClC,OAAO;QAAES,KAAK,EAAET,CAAC,IAAIA,CAAC,CAACK,CAAC,EAAE,CAAC;QAAEK,IAAI,EAAE,CAACV;MAAE,CAAC;IAC3C;EACJ,CAAC;EACD,MAAM,IAAIW,SAAS,CAACV,CAAC,GAAG,yBAAyB,GAAG,iCAAiC,CAAC;AAC1F,CAAC;AACD,IAAIW,MAAM,GAAI,IAAI,IAAI,IAAI,CAACA,MAAM,IAAK,UAAUZ,CAAC,EAAEa,CAAC,EAAE;EAClD,IAAIT,CAAC,GAAG,OAAOF,MAAM,KAAK,UAAU,IAAIF,CAAC,CAACE,MAAM,CAACC,QAAQ,CAAC;EAC1D,IAAI,CAACC,CAAC,EAAE,OAAOJ,CAAC;EAChB,IAAIK,CAAC,GAAGD,CAAC,CAACE,IAAI,CAACN,CAAC,CAAC;IAAEc,CAAC;IAAEC,EAAE,GAAG,EAAE;IAAEC,CAAC;EAChC,IAAI;IACA,OAAO,CAACH,CAAC,KAAK,KAAK,CAAC,IAAIA,CAAC,EAAE,GAAG,CAAC,KAAK,CAAC,CAACC,CAAC,GAAGT,CAAC,CAACG,IAAI,CAAC,CAAC,EAAEE,IAAI,EAAEK,EAAE,CAACE,IAAI,CAACH,CAAC,CAACL,KAAK,CAAC;EAC9E,CAAC,CACD,OAAOS,KAAK,EAAE;IAAEF,CAAC,GAAG;MAAEE,KAAK,EAAEA;IAAM,CAAC;EAAE,CAAC,SAC/B;IACJ,IAAI;MACA,IAAIJ,CAAC,IAAI,CAACA,CAAC,CAACJ,IAAI,KAAKN,CAAC,GAAGC,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAED,CAAC,CAACE,IAAI,CAACD,CAAC,CAAC;IACpD,CAAC,SACO;MAAE,IAAIW,CAAC,EAAE,MAAMA,CAAC,CAACE,KAAK;IAAE;EACpC;EACA,OAAOH,EAAE;AACb,CAAC;AACD,SAASI,IAAI,EAAEC,cAAc,QAAS,oBAAoB;AAC1D,SAASC,UAAU,EAAEC,cAAc,EAAEC,aAAa,EAAEC,MAAM,EAAEC,cAAc,EAAEC,gBAAgB,EAAEC,WAAW,EAAEC,iBAAiB,EAAEC,aAAa,EAAEC,kBAAkB,QAAS,qBAAqB;AAC7L,SAASC,kBAAkB,QAAQ,qCAAqC;AACxE,SAASC,kBAAkB,QAAQ,SAAS;AAC5C;AACA;AACA;AACA,IAAIC,IAAI,GAAG,aAAe,YAAY;EAClC;AACJ;AACA;AACA;AACA;EACI,SAASA,IAAIA,CAACC,YAAY,EAAEC,OAAO,EAAEC,QAAQ,EAAEC,WAAW,EAAEC,IAAI,EAAEC,YAAY,EAAEC,KAAK,EAAEC,SAAS,EAAEC,gBAAgB,CAAC;EAAA,EACjH;IACE,IAAIF,KAAK,KAAK,KAAK,CAAC,EAAE;MAAEA,KAAK,GAAG,EAAE;IAAE;IACpC,IAAI,CAACG,UAAU,GAAG,CAAC,CAAC;IACpB,IAAI,CAACH,KAAK,GAAG,EAAE;IACf,IAAI,CAACI,MAAM,GAAG,EAAE;IAChB,IAAI,CAACC,uBAAuB,GAAG,CAAC;IAChC,IAAI,CAACC,mBAAmB,GAAG,CAAC;IAC5B,IAAI,CAACC,kBAAkB,GAAG,CAAC;IAC3B,IAAI,CAACC,MAAM,GAAG;MACVC,IAAI,EAAE7B,cAAc,CAAC8B;IACzB,CAAC;IACD,IAAI,CAACC,OAAO,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;IACrB,IAAI,CAACC,MAAM,GAAG,KAAK;IACnB,IAAI,CAACC,SAAS,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACzB,IAAI,CAACC,IAAI,GAAGlB,QAAQ;IACpB,IAAI,CAACmB,YAAY,GAAGlB,WAAW;IAC/B,IAAI,CAACE,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACD,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACE,KAAK,GAAGA,KAAK;IAClB,IAAIgB,GAAG,GAAGC,IAAI,CAACD,GAAG,CAAC,CAAC;IACpB,IAAI,CAACE,qBAAqB,GAAG7B,aAAa,CAAC2B,GAAG,CAAC,CAAC;IAChD,IAAI,CAACG,kBAAkB,GACnBH,GAAG,IAAI,IAAI,CAACE,qBAAqB,GAAGnC,aAAa,CAAC,CAAC,CAAC;IACxD,IAAI,CAACqC,kBAAkB,GAAGnB,SAAS,IAAI,IAAI;IAC3C,IAAI,CAACA,SAAS,GAAG,IAAI,CAACoB,QAAQ,CAACpB,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAGA,SAAS,GAAGe,GAAG,CAAC;IAC5F,IAAI,CAACM,QAAQ,GAAG5B,YAAY,CAAC4B,QAAQ;IACrC,IAAI,CAACC,sBAAsB,GAAG7B,YAAY,CAAC6B,sBAAsB;IACjE,IAAI,CAACC,WAAW,GAAG9B,YAAY,CAAC+B,aAAa,CAAC,CAAC;IAC/C,IAAI,CAACC,cAAc,GAAGhC,YAAY,CAACiC,sBAAsB,CAAC,CAAC;IAC3D,IAAI,CAACD,cAAc,CAACE,OAAO,CAAC,IAAI,EAAEjC,OAAO,CAAC;IAC1C,IAAI,CAACkC,0BAA0B,GAC3B,IAAI,CAACL,WAAW,CAACM,yBAAyB,IAAI,CAAC;EACvD;EACArC,IAAI,CAACsC,SAAS,CAAClC,WAAW,GAAG,YAAY;IACrC,OAAO,IAAI,CAACkB,YAAY;EAC5B,CAAC;EACDtB,IAAI,CAACsC,SAAS,CAACC,YAAY,GAAG,UAAUC,GAAG,EAAEhE,KAAK,EAAE;IAChD,IAAIA,KAAK,IAAI,IAAI,IAAI,IAAI,CAACiE,YAAY,CAAC,CAAC,EACpC,OAAO,IAAI;IACf,IAAID,GAAG,CAAClE,MAAM,KAAK,CAAC,EAAE;MAClBY,IAAI,CAACwD,IAAI,CAAC,yBAAyB,GAAGF,GAAG,CAAC;MAC1C,OAAO,IAAI;IACf;IACA,IAAI,CAAC/C,gBAAgB,CAACjB,KAAK,CAAC,EAAE;MAC1BU,IAAI,CAACwD,IAAI,CAAC,uCAAuC,GAAGF,GAAG,CAAC;MACxD,OAAO,IAAI;IACf;IACA,IAAIG,MAAM,CAACC,IAAI,CAAC,IAAI,CAAClC,UAAU,CAAC,CAACpC,MAAM,IACnC,IAAI,CAACyD,WAAW,CAACc,mBAAmB,IACpC,CAACF,MAAM,CAACL,SAAS,CAACQ,cAAc,CAACzE,IAAI,CAAC,IAAI,CAACqC,UAAU,EAAE8B,GAAG,CAAC,EAAE;MAC7D,IAAI,CAAC5B,uBAAuB,EAAE;MAC9B,OAAO,IAAI;IACf;IACA,IAAI,CAACF,UAAU,CAAC8B,GAAG,CAAC,GAAG,IAAI,CAACO,eAAe,CAACvE,KAAK,CAAC;IAClD,OAAO,IAAI;EACf,CAAC;EACDwB,IAAI,CAACsC,SAAS,CAACU,aAAa,GAAG,UAAUtC,UAAU,EAAE;IACjD,IAAIuC,GAAG,EAAEC,EAAE;IACX,IAAI;MACA,KAAK,IAAIC,EAAE,GAAGrF,QAAQ,CAAC6E,MAAM,CAACS,OAAO,CAAC1C,UAAU,CAAC,CAAC,EAAE2C,EAAE,GAAGF,EAAE,CAAC5E,IAAI,CAAC,CAAC,EAAE,CAAC8E,EAAE,CAAC5E,IAAI,EAAE4E,EAAE,GAAGF,EAAE,CAAC5E,IAAI,CAAC,CAAC,EAAE;QAC1F,IAAI+E,EAAE,GAAG3E,MAAM,CAAC0E,EAAE,CAAC7E,KAAK,EAAE,CAAC,CAAC;UAAE+E,CAAC,GAAGD,EAAE,CAAC,CAAC,CAAC;UAAEE,CAAC,GAAGF,EAAE,CAAC,CAAC,CAAC;QAClD,IAAI,CAACf,YAAY,CAACgB,CAAC,EAAEC,CAAC,CAAC;MAC3B;IACJ,CAAC,CACD,OAAOC,KAAK,EAAE;MAAER,GAAG,GAAG;QAAEhE,KAAK,EAAEwE;MAAM,CAAC;IAAE,CAAC,SACjC;MACJ,IAAI;QACA,IAAIJ,EAAE,IAAI,CAACA,EAAE,CAAC5E,IAAI,KAAKyE,EAAE,GAAGC,EAAE,CAACO,MAAM,CAAC,EAAER,EAAE,CAAC7E,IAAI,CAAC8E,EAAE,CAAC;MACvD,CAAC,SACO;QAAE,IAAIF,GAAG,EAAE,MAAMA,GAAG,CAAChE,KAAK;MAAE;IACxC;IACA,OAAO,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIe,IAAI,CAACsC,SAAS,CAACqB,QAAQ,GAAG,UAAUtC,IAAI,EAAEuC,qBAAqB,EAAEC,SAAS,EAAE;IACxE,IAAI,IAAI,CAACpB,YAAY,CAAC,CAAC,EACnB,OAAO,IAAI;IACf,IAAI,IAAI,CAACV,WAAW,CAAC+B,eAAe,KAAK,CAAC,EAAE;MACxC5E,IAAI,CAACwD,IAAI,CAAC,oBAAoB,CAAC;MAC/B,IAAI,CAAC7B,mBAAmB,EAAE;MAC1B,OAAO,IAAI;IACf;IACA,IAAI,IAAI,CAACF,MAAM,CAACrC,MAAM,IAAI,IAAI,CAACyD,WAAW,CAAC+B,eAAe,EAAE;MACxD5E,IAAI,CAACwD,IAAI,CAAC,wBAAwB,CAAC;MACnC,IAAI,CAAC/B,MAAM,CAACoD,KAAK,CAAC,CAAC;MACnB,IAAI,CAAClD,mBAAmB,EAAE;IAC9B;IACA,IAAInB,WAAW,CAACkE,qBAAqB,CAAC,EAAE;MACpC,IAAI,CAAClE,WAAW,CAACmE,SAAS,CAAC,EAAE;QACzBA,SAAS,GAAGD,qBAAqB;MACrC;MACAA,qBAAqB,GAAGI,SAAS;IACrC;IACA,IAAItD,UAAU,GAAGb,kBAAkB,CAAC+D,qBAAqB,CAAC;IAC1D,IAAI,CAACjD,MAAM,CAAC3B,IAAI,CAAC;MACbqC,IAAI,EAAEA,IAAI;MACVX,UAAU,EAAEA,UAAU;MACtBuD,IAAI,EAAE,IAAI,CAACrC,QAAQ,CAACiC,SAAS,CAAC;MAC9BK,sBAAsB,EAAE;IAC5B,CAAC,CAAC;IACF,OAAO,IAAI;EACf,CAAC;EACDlE,IAAI,CAACsC,SAAS,CAAC6B,SAAS,GAAG,UAAUpD,MAAM,EAAE;IACzC,IAAI,IAAI,CAAC0B,YAAY,CAAC,CAAC,EACnB,OAAO,IAAI;IACf,IAAI,CAAC1B,MAAM,GAAGA,MAAM;IACpB,OAAO,IAAI;EACf,CAAC;EACDf,IAAI,CAACsC,SAAS,CAAC8B,UAAU,GAAG,UAAU/C,IAAI,EAAE;IACxC,IAAI,IAAI,CAACoB,YAAY,CAAC,CAAC,EACnB,OAAO,IAAI;IACf,IAAI,CAACpB,IAAI,GAAGA,IAAI;IAChB,OAAO,IAAI;EACf,CAAC;EACDrB,IAAI,CAACsC,SAAS,CAAC+B,GAAG,GAAG,UAAUnD,OAAO,EAAE;IACpC,IAAI,IAAI,CAACuB,YAAY,CAAC,CAAC,EAAE;MACrBvD,IAAI,CAACD,KAAK,CAAC,IAAI,CAACoC,IAAI,GAAG,GAAG,GAAG,IAAI,CAACC,YAAY,CAACgD,OAAO,GAAG,GAAG,GAAG,IAAI,CAAChD,YAAY,CAACiD,MAAM,GAAG,4CAA4C,CAAC;MACvI;IACJ;IACA,IAAI,CAACpD,MAAM,GAAG,IAAI;IAClB,IAAI,CAACD,OAAO,GAAG,IAAI,CAACU,QAAQ,CAACV,OAAO,CAAC;IACrC,IAAI,CAACE,SAAS,GAAG5B,cAAc,CAAC,IAAI,CAACgB,SAAS,EAAE,IAAI,CAACU,OAAO,CAAC;IAC7D,IAAI,IAAI,CAACE,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE;MACvBlC,IAAI,CAACwD,IAAI,CAAC,qFAAqF,EAAE,IAAI,CAAClC,SAAS,EAAE,IAAI,CAACU,OAAO,CAAC;MAC9H,IAAI,CAACA,OAAO,GAAG,IAAI,CAACV,SAAS,CAACgE,KAAK,CAAC,CAAC;MACrC,IAAI,CAACpD,SAAS,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;IAC3B;IACA,IAAI,CAACa,cAAc,CAACwC,KAAK,CAAC,IAAI,CAAC;EACnC,CAAC;EACDzE,IAAI,CAACsC,SAAS,CAACV,QAAQ,GAAG,UAAU8C,GAAG,EAAE;IACrC,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAIA,GAAG,GAAG9E,aAAa,CAAC2B,GAAG,CAAC,CAAC,EAAE;MACtD;MACA;MACA,OAAOhC,MAAM,CAACmF,GAAG,GAAG,IAAI,CAAChD,kBAAkB,CAAC;IAChD;IACA,IAAI,OAAOgD,GAAG,KAAK,QAAQ,EAAE;MACzB,OAAOrF,cAAc,CAACqF,GAAG,CAAC;IAC9B;IACA,IAAIA,GAAG,YAAYlD,IAAI,EAAE;MACrB,OAAOnC,cAAc,CAACqF,GAAG,CAACC,OAAO,CAAC,CAAC,CAAC;IACxC;IACA,IAAIhF,iBAAiB,CAAC+E,GAAG,CAAC,EAAE;MACxB,OAAOA,GAAG;IACd;IACA,IAAI,IAAI,CAAC/C,kBAAkB,EAAE;MACzB;MACA;MACA,OAAOtC,cAAc,CAACmC,IAAI,CAACD,GAAG,CAAC,CAAC,CAAC;IACrC;IACA,IAAIqD,UAAU,GAAGhF,aAAa,CAAC2B,GAAG,CAAC,CAAC,GAAG,IAAI,CAACE,qBAAqB;IACjE,OAAOrC,UAAU,CAAC,IAAI,CAACoB,SAAS,EAAEnB,cAAc,CAACuF,UAAU,CAAC,CAAC;EACjE,CAAC;EACD5E,IAAI,CAACsC,SAAS,CAACuC,WAAW,GAAG,YAAY;IACrC,OAAO,IAAI,CAAC1D,MAAM,KAAK,KAAK;EAChC,CAAC;EACDnB,IAAI,CAACsC,SAAS,CAACwC,eAAe,GAAG,UAAUC,SAAS,EAAEd,IAAI,EAAE;IACxD,IAAIvD,UAAU,GAAG,CAAC,CAAC;IACnB,IAAI,OAAOqE,SAAS,KAAK,QAAQ,EAAE;MAC/BrE,UAAU,CAACZ,kBAAkB,CAACkF,iBAAiB,CAAC,GAAGD,SAAS;IAChE,CAAC,MACI,IAAIA,SAAS,EAAE;MAChB,IAAIA,SAAS,CAAC/D,IAAI,EAAE;QAChBN,UAAU,CAACZ,kBAAkB,CAACmF,cAAc,CAAC,GACzCF,SAAS,CAAC/D,IAAI,CAACkE,QAAQ,CAAC,CAAC;MACjC,CAAC,MACI,IAAIH,SAAS,CAAC1D,IAAI,EAAE;QACrBX,UAAU,CAACZ,kBAAkB,CAACmF,cAAc,CAAC,GAAGF,SAAS,CAAC1D,IAAI;MAClE;MACA,IAAI0D,SAAS,CAACI,OAAO,EAAE;QACnBzE,UAAU,CAACZ,kBAAkB,CAACkF,iBAAiB,CAAC,GAAGD,SAAS,CAACI,OAAO;MACxE;MACA,IAAIJ,SAAS,CAACK,KAAK,EAAE;QACjB1E,UAAU,CAACZ,kBAAkB,CAACuF,oBAAoB,CAAC,GAAGN,SAAS,CAACK,KAAK;MACzE;IACJ;IACA;IACA,IAAI1E,UAAU,CAACZ,kBAAkB,CAACmF,cAAc,CAAC,IAC7CvE,UAAU,CAACZ,kBAAkB,CAACkF,iBAAiB,CAAC,EAAE;MAClD,IAAI,CAACrB,QAAQ,CAAC5D,kBAAkB,EAAEW,UAAU,EAAEuD,IAAI,CAAC;IACvD,CAAC,MACI;MACD/E,IAAI,CAACwD,IAAI,CAAC,gCAAgC,GAAGqC,SAAS,CAAC;IAC3D;EACJ,CAAC;EACDpC,MAAM,CAAC2C,cAAc,CAACtF,IAAI,CAACsC,SAAS,EAAE,UAAU,EAAE;IAC9CiD,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAO,IAAI,CAACnE,SAAS;IACzB,CAAC;IACDoE,UAAU,EAAE,KAAK;IACjBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACF9C,MAAM,CAAC2C,cAAc,CAACtF,IAAI,CAACsC,SAAS,EAAE,OAAO,EAAE;IAC3CiD,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAO,IAAI,CAACpE,MAAM;IACtB,CAAC;IACDqE,UAAU,EAAE,KAAK;IACjBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACF9C,MAAM,CAAC2C,cAAc,CAACtF,IAAI,CAACsC,SAAS,EAAE,wBAAwB,EAAE;IAC5DiD,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAO,IAAI,CAAC3E,uBAAuB;IACvC,CAAC;IACD4E,UAAU,EAAE,KAAK;IACjBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACF9C,MAAM,CAAC2C,cAAc,CAACtF,IAAI,CAACsC,SAAS,EAAE,oBAAoB,EAAE;IACxDiD,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAO,IAAI,CAAC1E,mBAAmB;IACnC,CAAC;IACD2E,UAAU,EAAE,KAAK;IACjBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACF9C,MAAM,CAAC2C,cAAc,CAACtF,IAAI,CAACsC,SAAS,EAAE,mBAAmB,EAAE;IACvDiD,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAO,IAAI,CAACzE,kBAAkB;IAClC,CAAC;IACD0E,UAAU,EAAE,KAAK;IACjBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFzF,IAAI,CAACsC,SAAS,CAACG,YAAY,GAAG,YAAY;IACtC,IAAI,IAAI,CAACtB,MAAM,EAAE;MACbjC,IAAI,CAACwD,IAAI,CAAC,wDAAwD,GAAG,IAAI,CAACpB,YAAY,CAACgD,OAAO,GAAG,YAAY,GAAG,IAAI,CAAChD,YAAY,CAACiD,MAAM,GAAG,GAAG,CAAC;IACnJ;IACA,OAAO,IAAI,CAACpD,MAAM;EACtB,CAAC;EACD;EACA;EACA;EACAnB,IAAI,CAACsC,SAAS,CAACoD,oBAAoB,GAAG,UAAUlH,KAAK,EAAEmH,KAAK,EAAE;IAC1D,IAAInH,KAAK,CAACF,MAAM,IAAIqH,KAAK,EAAE;MACvB,OAAOnH,KAAK;IAChB;IACA,OAAOA,KAAK,CAACoH,MAAM,CAAC,CAAC,EAAED,KAAK,CAAC;EACjC,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI3F,IAAI,CAACsC,SAAS,CAACS,eAAe,GAAG,UAAUvE,KAAK,EAAE;IAC9C,IAAIqH,KAAK,GAAG,IAAI;IAChB,IAAIF,KAAK,GAAG,IAAI,CAACvD,0BAA0B;IAC3C;IACA,IAAIuD,KAAK,IAAI,CAAC,EAAE;MACZ;MACAzG,IAAI,CAACwD,IAAI,CAAC,8CAA8C,GAAGiD,KAAK,CAAC;MACjE,OAAOnH,KAAK;IAChB;IACA;IACA,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC3B,OAAO,IAAI,CAACkH,oBAAoB,CAAClH,KAAK,EAAEmH,KAAK,CAAC;IAClD;IACA;IACA,IAAIG,KAAK,CAACC,OAAO,CAACvH,KAAK,CAAC,EAAE;MACtB,OAAOA,KAAK,CAACwH,GAAG,CAAC,UAAUC,GAAG,EAAE;QAC5B,OAAO,OAAOA,GAAG,KAAK,QAAQ,GAAGJ,KAAK,CAACH,oBAAoB,CAACO,GAAG,EAAEN,KAAK,CAAC,GAAGM,GAAG;MACjF,CAAC,CAAC;IACN;IACA;IACA,OAAOzH,KAAK;EAChB,CAAC;EACD,OAAOwB,IAAI;AACf,CAAC,CAAC,CAAE;AACJ,SAASA,IAAI"},"metadata":{},"sourceType":"module","externalDependencies":[]}