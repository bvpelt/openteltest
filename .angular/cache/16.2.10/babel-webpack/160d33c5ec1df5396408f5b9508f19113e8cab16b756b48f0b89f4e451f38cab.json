{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { otperformance as performance } from '../platform';\nvar NANOSECOND_DIGITS = 9;\nvar NANOSECOND_DIGITS_IN_MILLIS = 6;\nvar MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);\nvar SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);\n/**\n * Converts a number of milliseconds from epoch to HrTime([seconds, remainder in nanoseconds]).\n * @param epochMillis\n */\nexport function millisToHrTime(epochMillis) {\n  var epochSeconds = epochMillis / 1000;\n  // Decimals only.\n  var seconds = Math.trunc(epochSeconds);\n  // Round sub-nanosecond accuracy to nanosecond.\n  var nanos = Math.round(epochMillis % 1000 * MILLISECONDS_TO_NANOSECONDS);\n  return [seconds, nanos];\n}\nexport function getTimeOrigin() {\n  var timeOrigin = performance.timeOrigin;\n  if (typeof timeOrigin !== 'number') {\n    var perf = performance;\n    timeOrigin = perf.timing && perf.timing.fetchStart;\n  }\n  return timeOrigin;\n}\n/**\n * Returns an hrtime calculated via performance component.\n * @param performanceNow\n */\nexport function hrTime(performanceNow) {\n  var timeOrigin = millisToHrTime(getTimeOrigin());\n  var now = millisToHrTime(typeof performanceNow === 'number' ? performanceNow : performance.now());\n  return addHrTimes(timeOrigin, now);\n}\n/**\n *\n * Converts a TimeInput to an HrTime, defaults to _hrtime().\n * @param time\n */\nexport function timeInputToHrTime(time) {\n  // process.hrtime\n  if (isTimeInputHrTime(time)) {\n    return time;\n  } else if (typeof time === 'number') {\n    // Must be a performance.now() if it's smaller than process start time.\n    if (time < getTimeOrigin()) {\n      return hrTime(time);\n    } else {\n      // epoch milliseconds or performance.timeOrigin\n      return millisToHrTime(time);\n    }\n  } else if (time instanceof Date) {\n    return millisToHrTime(time.getTime());\n  } else {\n    throw TypeError('Invalid input type');\n  }\n}\n/**\n * Returns a duration of two hrTime.\n * @param startTime\n * @param endTime\n */\nexport function hrTimeDuration(startTime, endTime) {\n  var seconds = endTime[0] - startTime[0];\n  var nanos = endTime[1] - startTime[1];\n  // overflow\n  if (nanos < 0) {\n    seconds -= 1;\n    // negate\n    nanos += SECOND_TO_NANOSECONDS;\n  }\n  return [seconds, nanos];\n}\n/**\n * Convert hrTime to timestamp, for example \"2019-05-14T17:00:00.000123456Z\"\n * @param time\n */\nexport function hrTimeToTimeStamp(time) {\n  var precision = NANOSECOND_DIGITS;\n  var tmp = \"\" + '0'.repeat(precision) + time[1] + \"Z\";\n  var nanoString = tmp.substr(tmp.length - precision - 1);\n  var date = new Date(time[0] * 1000).toISOString();\n  return date.replace('000Z', nanoString);\n}\n/**\n * Convert hrTime to nanoseconds.\n * @param time\n */\nexport function hrTimeToNanoseconds(time) {\n  return time[0] * SECOND_TO_NANOSECONDS + time[1];\n}\n/**\n * Convert hrTime to milliseconds.\n * @param time\n */\nexport function hrTimeToMilliseconds(time) {\n  return time[0] * 1e3 + time[1] / 1e6;\n}\n/**\n * Convert hrTime to microseconds.\n * @param time\n */\nexport function hrTimeToMicroseconds(time) {\n  return time[0] * 1e6 + time[1] / 1e3;\n}\n/**\n * check if time is HrTime\n * @param value\n */\nexport function isTimeInputHrTime(value) {\n  return Array.isArray(value) && value.length === 2 && typeof value[0] === 'number' && typeof value[1] === 'number';\n}\n/**\n * check if input value is a correct types.TimeInput\n * @param value\n */\nexport function isTimeInput(value) {\n  return isTimeInputHrTime(value) || typeof value === 'number' || value instanceof Date;\n}\n/**\n * Given 2 HrTime formatted times, return their sum as an HrTime.\n */\nexport function addHrTimes(time1, time2) {\n  var out = [time1[0] + time2[0], time1[1] + time2[1]];\n  // Nanoseconds\n  if (out[1] >= SECOND_TO_NANOSECONDS) {\n    out[1] -= SECOND_TO_NANOSECONDS;\n    out[0] += 1;\n  }\n  return out;\n}","map":{"version":3,"names":["otperformance","performance","NANOSECOND_DIGITS","NANOSECOND_DIGITS_IN_MILLIS","MILLISECONDS_TO_NANOSECONDS","Math","pow","SECOND_TO_NANOSECONDS","millisToHrTime","epochMillis","epochSeconds","seconds","trunc","nanos","round","getTimeOrigin","timeOrigin","perf","timing","fetchStart","hrTime","performanceNow","now","addHrTimes","timeInputToHrTime","time","isTimeInputHrTime","Date","getTime","TypeError","hrTimeDuration","startTime","endTime","hrTimeToTimeStamp","precision","tmp","repeat","nanoString","substr","length","date","toISOString","replace","hrTimeToNanoseconds","hrTimeToMilliseconds","hrTimeToMicroseconds","value","Array","isArray","isTimeInput","time1","time2","out"],"sources":["/home/bvpelt/Develop/openteltest/node_modules/@opentelemetry/core/build/esm/common/time.js"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { otperformance as performance } from '../platform';\nvar NANOSECOND_DIGITS = 9;\nvar NANOSECOND_DIGITS_IN_MILLIS = 6;\nvar MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);\nvar SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);\n/**\n * Converts a number of milliseconds from epoch to HrTime([seconds, remainder in nanoseconds]).\n * @param epochMillis\n */\nexport function millisToHrTime(epochMillis) {\n    var epochSeconds = epochMillis / 1000;\n    // Decimals only.\n    var seconds = Math.trunc(epochSeconds);\n    // Round sub-nanosecond accuracy to nanosecond.\n    var nanos = Math.round((epochMillis % 1000) * MILLISECONDS_TO_NANOSECONDS);\n    return [seconds, nanos];\n}\nexport function getTimeOrigin() {\n    var timeOrigin = performance.timeOrigin;\n    if (typeof timeOrigin !== 'number') {\n        var perf = performance;\n        timeOrigin = perf.timing && perf.timing.fetchStart;\n    }\n    return timeOrigin;\n}\n/**\n * Returns an hrtime calculated via performance component.\n * @param performanceNow\n */\nexport function hrTime(performanceNow) {\n    var timeOrigin = millisToHrTime(getTimeOrigin());\n    var now = millisToHrTime(typeof performanceNow === 'number' ? performanceNow : performance.now());\n    return addHrTimes(timeOrigin, now);\n}\n/**\n *\n * Converts a TimeInput to an HrTime, defaults to _hrtime().\n * @param time\n */\nexport function timeInputToHrTime(time) {\n    // process.hrtime\n    if (isTimeInputHrTime(time)) {\n        return time;\n    }\n    else if (typeof time === 'number') {\n        // Must be a performance.now() if it's smaller than process start time.\n        if (time < getTimeOrigin()) {\n            return hrTime(time);\n        }\n        else {\n            // epoch milliseconds or performance.timeOrigin\n            return millisToHrTime(time);\n        }\n    }\n    else if (time instanceof Date) {\n        return millisToHrTime(time.getTime());\n    }\n    else {\n        throw TypeError('Invalid input type');\n    }\n}\n/**\n * Returns a duration of two hrTime.\n * @param startTime\n * @param endTime\n */\nexport function hrTimeDuration(startTime, endTime) {\n    var seconds = endTime[0] - startTime[0];\n    var nanos = endTime[1] - startTime[1];\n    // overflow\n    if (nanos < 0) {\n        seconds -= 1;\n        // negate\n        nanos += SECOND_TO_NANOSECONDS;\n    }\n    return [seconds, nanos];\n}\n/**\n * Convert hrTime to timestamp, for example \"2019-05-14T17:00:00.000123456Z\"\n * @param time\n */\nexport function hrTimeToTimeStamp(time) {\n    var precision = NANOSECOND_DIGITS;\n    var tmp = \"\" + '0'.repeat(precision) + time[1] + \"Z\";\n    var nanoString = tmp.substr(tmp.length - precision - 1);\n    var date = new Date(time[0] * 1000).toISOString();\n    return date.replace('000Z', nanoString);\n}\n/**\n * Convert hrTime to nanoseconds.\n * @param time\n */\nexport function hrTimeToNanoseconds(time) {\n    return time[0] * SECOND_TO_NANOSECONDS + time[1];\n}\n/**\n * Convert hrTime to milliseconds.\n * @param time\n */\nexport function hrTimeToMilliseconds(time) {\n    return time[0] * 1e3 + time[1] / 1e6;\n}\n/**\n * Convert hrTime to microseconds.\n * @param time\n */\nexport function hrTimeToMicroseconds(time) {\n    return time[0] * 1e6 + time[1] / 1e3;\n}\n/**\n * check if time is HrTime\n * @param value\n */\nexport function isTimeInputHrTime(value) {\n    return (Array.isArray(value) &&\n        value.length === 2 &&\n        typeof value[0] === 'number' &&\n        typeof value[1] === 'number');\n}\n/**\n * check if input value is a correct types.TimeInput\n * @param value\n */\nexport function isTimeInput(value) {\n    return (isTimeInputHrTime(value) ||\n        typeof value === 'number' ||\n        value instanceof Date);\n}\n/**\n * Given 2 HrTime formatted times, return their sum as an HrTime.\n */\nexport function addHrTimes(time1, time2) {\n    var out = [time1[0] + time2[0], time1[1] + time2[1]];\n    // Nanoseconds\n    if (out[1] >= SECOND_TO_NANOSECONDS) {\n        out[1] -= SECOND_TO_NANOSECONDS;\n        out[0] += 1;\n    }\n    return out;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}