{"ast":null,"code":"'use strict';\n\nvar util = require('util');\nvar HexTransform = require('./hex_transform');\nfunction ChunkedHexTransform(options) {\n  if (!(this instanceof ChunkedHexTransform)) {\n    return new ChunkedHexTransform(options);\n  }\n  // istanbul ignore next\n  if (!options) options = {};\n  HexTransform.call(this, options);\n  var self = this;\n  if (typeof options.header === 'function') {\n    self.header = options.header;\n  } else if (typeof options.header === 'object') {\n    self.header = simpleHeader(options.header);\n  } else if (typeof options.header === 'string') {\n    self.header = simpleHeader({\n      label: options.header\n    });\n  } else {\n    self.header = simpleHeader();\n  }\n  self.chunkNum = 0;\n}\nutil.inherits(ChunkedHexTransform, HexTransform);\nChunkedHexTransform.prototype._transform = function transform(chunk, encoding, done) {\n  var self = this;\n  // istanbul ignore next\n  if (self.totalOffset) {\n    self.reset();\n  }\n  ++self.chunkNum;\n  var header = self.header(self.chunkNum, chunk);\n  if (header.length) {\n    self.push(header);\n  }\n  HexTransform.prototype._transform.call(self, chunk, encoding, function subDone(err) {\n    self.reset();\n    done(err);\n  });\n};\nfunction simpleHeader(opts) {\n  opts = opts || {};\n  var fmt = '-- ';\n  if (opts.label) fmt += opts.label + ' ';\n  fmt += 'chunk[%s] length: %s (0x%s)\\n';\n  return function header(chunkNum, chunk) {\n    var len = chunk.length;\n    var hexlen = len.toString(16);\n    return util.format(fmt, chunkNum, len, hexlen);\n  };\n}\nmodule.exports = ChunkedHexTransform;","map":{"version":3,"names":["util","require","HexTransform","ChunkedHexTransform","options","call","self","header","simpleHeader","label","chunkNum","inherits","prototype","_transform","transform","chunk","encoding","done","totalOffset","reset","length","push","subDone","err","opts","fmt","len","hexlen","toString","format","module","exports"],"sources":["/home/bvpelt/Develop/openteltest/node_modules/hexer/chunked_hex_transform.js"],"sourcesContent":["'use strict';\n\nvar util = require('util');\nvar HexTransform = require('./hex_transform');\n\nfunction ChunkedHexTransform(options) {\n    if (!(this instanceof ChunkedHexTransform)) {\n        return new ChunkedHexTransform(options);\n    }\n    // istanbul ignore next\n    if (!options) options = {};\n    HexTransform.call(this, options);\n    var self = this;\n    if (typeof options.header === 'function') {\n        self.header = options.header;\n    } else if (typeof options.header === 'object') {\n        self.header = simpleHeader(options.header);\n    } else if (typeof options.header === 'string') {\n        self.header = simpleHeader({\n            label: options.header\n        });\n    } else {\n        self.header = simpleHeader();\n    }\n    self.chunkNum = 0;\n}\nutil.inherits(ChunkedHexTransform, HexTransform);\n\nChunkedHexTransform.prototype._transform = function transform(chunk, encoding, done) {\n    var self = this;\n    // istanbul ignore next\n    if (self.totalOffset) {\n        self.reset();\n    }\n\n    ++self.chunkNum;\n    var header = self.header(self.chunkNum, chunk);\n    if (header.length) {\n        self.push(header);\n    }\n\n    HexTransform.prototype._transform.call(self, chunk, encoding, function subDone(err) {\n        self.reset();\n        done(err);\n    });\n};\n\nfunction simpleHeader(opts) {\n    opts = opts || {};\n    var fmt = '-- ';\n    if (opts.label) fmt += opts.label + ' ';\n    fmt += 'chunk[%s] length: %s (0x%s)\\n';\n    return function header(chunkNum, chunk) {\n        var len = chunk.length;\n        var hexlen = len.toString(16);\n        return util.format(fmt, chunkNum, len, hexlen);\n    };\n}\n\nmodule.exports = ChunkedHexTransform;\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC1B,IAAIC,YAAY,GAAGD,OAAO,CAAC,iBAAiB,CAAC;AAE7C,SAASE,mBAAmBA,CAACC,OAAO,EAAE;EAClC,IAAI,EAAE,IAAI,YAAYD,mBAAmB,CAAC,EAAE;IACxC,OAAO,IAAIA,mBAAmB,CAACC,OAAO,CAAC;EAC3C;EACA;EACA,IAAI,CAACA,OAAO,EAAEA,OAAO,GAAG,CAAC,CAAC;EAC1BF,YAAY,CAACG,IAAI,CAAC,IAAI,EAAED,OAAO,CAAC;EAChC,IAAIE,IAAI,GAAG,IAAI;EACf,IAAI,OAAOF,OAAO,CAACG,MAAM,KAAK,UAAU,EAAE;IACtCD,IAAI,CAACC,MAAM,GAAGH,OAAO,CAACG,MAAM;EAChC,CAAC,MAAM,IAAI,OAAOH,OAAO,CAACG,MAAM,KAAK,QAAQ,EAAE;IAC3CD,IAAI,CAACC,MAAM,GAAGC,YAAY,CAACJ,OAAO,CAACG,MAAM,CAAC;EAC9C,CAAC,MAAM,IAAI,OAAOH,OAAO,CAACG,MAAM,KAAK,QAAQ,EAAE;IAC3CD,IAAI,CAACC,MAAM,GAAGC,YAAY,CAAC;MACvBC,KAAK,EAAEL,OAAO,CAACG;IACnB,CAAC,CAAC;EACN,CAAC,MAAM;IACHD,IAAI,CAACC,MAAM,GAAGC,YAAY,CAAC,CAAC;EAChC;EACAF,IAAI,CAACI,QAAQ,GAAG,CAAC;AACrB;AACAV,IAAI,CAACW,QAAQ,CAACR,mBAAmB,EAAED,YAAY,CAAC;AAEhDC,mBAAmB,CAACS,SAAS,CAACC,UAAU,GAAG,SAASC,SAASA,CAACC,KAAK,EAAEC,QAAQ,EAAEC,IAAI,EAAE;EACjF,IAAIX,IAAI,GAAG,IAAI;EACf;EACA,IAAIA,IAAI,CAACY,WAAW,EAAE;IAClBZ,IAAI,CAACa,KAAK,CAAC,CAAC;EAChB;EAEA,EAAEb,IAAI,CAACI,QAAQ;EACf,IAAIH,MAAM,GAAGD,IAAI,CAACC,MAAM,CAACD,IAAI,CAACI,QAAQ,EAAEK,KAAK,CAAC;EAC9C,IAAIR,MAAM,CAACa,MAAM,EAAE;IACfd,IAAI,CAACe,IAAI,CAACd,MAAM,CAAC;EACrB;EAEAL,YAAY,CAACU,SAAS,CAACC,UAAU,CAACR,IAAI,CAACC,IAAI,EAAES,KAAK,EAAEC,QAAQ,EAAE,SAASM,OAAOA,CAACC,GAAG,EAAE;IAChFjB,IAAI,CAACa,KAAK,CAAC,CAAC;IACZF,IAAI,CAACM,GAAG,CAAC;EACb,CAAC,CAAC;AACN,CAAC;AAED,SAASf,YAAYA,CAACgB,IAAI,EAAE;EACxBA,IAAI,GAAGA,IAAI,IAAI,CAAC,CAAC;EACjB,IAAIC,GAAG,GAAG,KAAK;EACf,IAAID,IAAI,CAACf,KAAK,EAAEgB,GAAG,IAAID,IAAI,CAACf,KAAK,GAAG,GAAG;EACvCgB,GAAG,IAAI,+BAA+B;EACtC,OAAO,SAASlB,MAAMA,CAACG,QAAQ,EAAEK,KAAK,EAAE;IACpC,IAAIW,GAAG,GAAGX,KAAK,CAACK,MAAM;IACtB,IAAIO,MAAM,GAAGD,GAAG,CAACE,QAAQ,CAAC,EAAE,CAAC;IAC7B,OAAO5B,IAAI,CAAC6B,MAAM,CAACJ,GAAG,EAAEf,QAAQ,EAAEgB,GAAG,EAAEC,MAAM,CAAC;EAClD,CAAC;AACL;AAEAG,MAAM,CAACC,OAAO,GAAG5B,mBAAmB"},"metadata":{},"sourceType":"script","externalDependencies":[]}