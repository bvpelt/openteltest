{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { AttributeHashMap } from './HashMap';\n/**\n * Internal interface.\n *\n * Provides unique reporting for each collector. Allows synchronous collection\n * of metrics and reports given temporality values.\n */\nvar TemporalMetricProcessor = /** @class */function () {\n  function TemporalMetricProcessor(_aggregator, collectorHandles) {\n    var _this = this;\n    this._aggregator = _aggregator;\n    this._unreportedAccumulations = new Map();\n    this._reportHistory = new Map();\n    collectorHandles.forEach(function (handle) {\n      _this._unreportedAccumulations.set(handle, []);\n    });\n  }\n  /**\n   * Builds the {@link MetricData} streams to report against a specific MetricCollector.\n   * @param collector The information of the MetricCollector.\n   * @param collectors The registered collectors.\n   * @param instrumentDescriptor The instrumentation descriptor that these metrics generated with.\n   * @param currentAccumulations The current accumulation of metric data from instruments.\n   * @param collectionTime The current collection timestamp.\n   * @returns The {@link MetricData} points or `null`.\n   */\n  TemporalMetricProcessor.prototype.buildMetrics = function (collector, instrumentDescriptor, currentAccumulations, collectionTime) {\n    this._stashAccumulations(currentAccumulations);\n    var unreportedAccumulations = this._getMergedUnreportedAccumulations(collector);\n    var result = unreportedAccumulations;\n    var aggregationTemporality;\n    // Check our last report time.\n    if (this._reportHistory.has(collector)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      var last = this._reportHistory.get(collector);\n      var lastCollectionTime = last.collectionTime;\n      aggregationTemporality = last.aggregationTemporality;\n      // Use aggregation temporality + instrument to determine if we do a merge or a diff of\n      // previous. We have the following four scenarios:\n      // 1. Cumulative Aggregation (temporality) + Delta recording (sync instrument).\n      //    Here we merge with our last record to get a cumulative aggregation.\n      // 2. Cumulative Aggregation + Cumulative recording (async instrument).\n      //    Cumulative records are converted to delta recording with DeltaMetricProcessor.\n      //    Here we merge with our last record to get a cumulative aggregation.\n      // 3. Delta Aggregation + Delta recording\n      //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.\n      // 4. Delta Aggregation + Cumulative recording.\n      //    Cumulative records are converted to delta recording with DeltaMetricProcessor.\n      //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.\n      if (aggregationTemporality === AggregationTemporality.CUMULATIVE) {\n        // We need to make sure the current delta recording gets merged into the previous cumulative\n        // for the next cumulative recording.\n        result = TemporalMetricProcessor.merge(last.accumulations, unreportedAccumulations, this._aggregator);\n      } else {\n        result = TemporalMetricProcessor.calibrateStartTime(last.accumulations, unreportedAccumulations, lastCollectionTime);\n      }\n    } else {\n      // Call into user code to select aggregation temporality for the instrument.\n      aggregationTemporality = collector.selectAggregationTemporality(instrumentDescriptor.type);\n    }\n    // Update last reported (cumulative) accumulation.\n    this._reportHistory.set(collector, {\n      accumulations: result,\n      collectionTime: collectionTime,\n      aggregationTemporality: aggregationTemporality\n    });\n    var accumulationRecords = AttributesMapToAccumulationRecords(result);\n    // do not convert to metric data if there is nothing to convert.\n    if (accumulationRecords.length === 0) {\n      return undefined;\n    }\n    return this._aggregator.toMetricData(instrumentDescriptor, aggregationTemporality, accumulationRecords, /* endTime */collectionTime);\n  };\n  TemporalMetricProcessor.prototype._stashAccumulations = function (currentAccumulation) {\n    var e_1, _a;\n    var registeredCollectors = this._unreportedAccumulations.keys();\n    try {\n      for (var registeredCollectors_1 = __values(registeredCollectors), registeredCollectors_1_1 = registeredCollectors_1.next(); !registeredCollectors_1_1.done; registeredCollectors_1_1 = registeredCollectors_1.next()) {\n        var collector = registeredCollectors_1_1.value;\n        var stash = this._unreportedAccumulations.get(collector);\n        if (stash === undefined) {\n          stash = [];\n          this._unreportedAccumulations.set(collector, stash);\n        }\n        stash.push(currentAccumulation);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (registeredCollectors_1_1 && !registeredCollectors_1_1.done && (_a = registeredCollectors_1.return)) _a.call(registeredCollectors_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n  TemporalMetricProcessor.prototype._getMergedUnreportedAccumulations = function (collector) {\n    var e_2, _a;\n    var result = new AttributeHashMap();\n    var unreportedList = this._unreportedAccumulations.get(collector);\n    this._unreportedAccumulations.set(collector, []);\n    if (unreportedList === undefined) {\n      return result;\n    }\n    try {\n      for (var unreportedList_1 = __values(unreportedList), unreportedList_1_1 = unreportedList_1.next(); !unreportedList_1_1.done; unreportedList_1_1 = unreportedList_1.next()) {\n        var it_1 = unreportedList_1_1.value;\n        result = TemporalMetricProcessor.merge(result, it_1, this._aggregator);\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (unreportedList_1_1 && !unreportedList_1_1.done && (_a = unreportedList_1.return)) _a.call(unreportedList_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    return result;\n  };\n  TemporalMetricProcessor.merge = function (last, current, aggregator) {\n    var result = last;\n    var iterator = current.entries();\n    var next = iterator.next();\n    while (next.done !== true) {\n      var _a = __read(next.value, 3),\n        key = _a[0],\n        record = _a[1],\n        hash = _a[2];\n      if (last.has(key, hash)) {\n        var lastAccumulation = last.get(key, hash);\n        // last.has() returned true, lastAccumulation is present.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        var accumulation = aggregator.merge(lastAccumulation, record);\n        result.set(key, accumulation, hash);\n      } else {\n        result.set(key, record, hash);\n      }\n      next = iterator.next();\n    }\n    return result;\n  };\n  /**\n   * Calibrate the reported metric streams' startTime to lastCollectionTime. Leaves\n   * the new stream to be the initial observation time unchanged.\n   */\n  TemporalMetricProcessor.calibrateStartTime = function (last, current, lastCollectionTime) {\n    var e_3, _a;\n    try {\n      for (var _b = __values(last.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = __read(_c.value, 2),\n          key = _d[0],\n          hash = _d[1];\n        var currentAccumulation = current.get(key, hash);\n        currentAccumulation === null || currentAccumulation === void 0 ? void 0 : currentAccumulation.setStartTime(lastCollectionTime);\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n    return current;\n  };\n  return TemporalMetricProcessor;\n}();\nexport { TemporalMetricProcessor };\n// TypeScript complains about converting 3 elements tuple to AccumulationRecord<T>.\nfunction AttributesMapToAccumulationRecords(map) {\n  return Array.from(map.entries());\n}","map":{"version":3,"names":["__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","__read","n","r","ar","e","push","error","AggregationTemporality","AttributeHashMap","TemporalMetricProcessor","_aggregator","collectorHandles","_this","_unreportedAccumulations","Map","_reportHistory","forEach","handle","set","prototype","buildMetrics","collector","instrumentDescriptor","currentAccumulations","collectionTime","_stashAccumulations","unreportedAccumulations","_getMergedUnreportedAccumulations","result","aggregationTemporality","has","last","get","lastCollectionTime","CUMULATIVE","merge","accumulations","calibrateStartTime","selectAggregationTemporality","type","accumulationRecords","AttributesMapToAccumulationRecords","undefined","toMetricData","currentAccumulation","e_1","_a","registeredCollectors","keys","registeredCollectors_1","registeredCollectors_1_1","stash","e_1_1","return","e_2","unreportedList","unreportedList_1","unreportedList_1_1","it_1","e_2_1","current","aggregator","entries","key","record","hash","lastAccumulation","accumulation","e_3","_b","_c","_d","setStartTime","e_3_1","map","Array","from"],"sources":["/home/bvpelt/Develop/openteltest/node_modules/@opentelemetry/sdk-metrics/build/esm/state/TemporalMetricProcessor.js"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { AttributeHashMap } from './HashMap';\n/**\n * Internal interface.\n *\n * Provides unique reporting for each collector. Allows synchronous collection\n * of metrics and reports given temporality values.\n */\nvar TemporalMetricProcessor = /** @class */ (function () {\n    function TemporalMetricProcessor(_aggregator, collectorHandles) {\n        var _this = this;\n        this._aggregator = _aggregator;\n        this._unreportedAccumulations = new Map();\n        this._reportHistory = new Map();\n        collectorHandles.forEach(function (handle) {\n            _this._unreportedAccumulations.set(handle, []);\n        });\n    }\n    /**\n     * Builds the {@link MetricData} streams to report against a specific MetricCollector.\n     * @param collector The information of the MetricCollector.\n     * @param collectors The registered collectors.\n     * @param instrumentDescriptor The instrumentation descriptor that these metrics generated with.\n     * @param currentAccumulations The current accumulation of metric data from instruments.\n     * @param collectionTime The current collection timestamp.\n     * @returns The {@link MetricData} points or `null`.\n     */\n    TemporalMetricProcessor.prototype.buildMetrics = function (collector, instrumentDescriptor, currentAccumulations, collectionTime) {\n        this._stashAccumulations(currentAccumulations);\n        var unreportedAccumulations = this._getMergedUnreportedAccumulations(collector);\n        var result = unreportedAccumulations;\n        var aggregationTemporality;\n        // Check our last report time.\n        if (this._reportHistory.has(collector)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            var last = this._reportHistory.get(collector);\n            var lastCollectionTime = last.collectionTime;\n            aggregationTemporality = last.aggregationTemporality;\n            // Use aggregation temporality + instrument to determine if we do a merge or a diff of\n            // previous. We have the following four scenarios:\n            // 1. Cumulative Aggregation (temporality) + Delta recording (sync instrument).\n            //    Here we merge with our last record to get a cumulative aggregation.\n            // 2. Cumulative Aggregation + Cumulative recording (async instrument).\n            //    Cumulative records are converted to delta recording with DeltaMetricProcessor.\n            //    Here we merge with our last record to get a cumulative aggregation.\n            // 3. Delta Aggregation + Delta recording\n            //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.\n            // 4. Delta Aggregation + Cumulative recording.\n            //    Cumulative records are converted to delta recording with DeltaMetricProcessor.\n            //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.\n            if (aggregationTemporality === AggregationTemporality.CUMULATIVE) {\n                // We need to make sure the current delta recording gets merged into the previous cumulative\n                // for the next cumulative recording.\n                result = TemporalMetricProcessor.merge(last.accumulations, unreportedAccumulations, this._aggregator);\n            }\n            else {\n                result = TemporalMetricProcessor.calibrateStartTime(last.accumulations, unreportedAccumulations, lastCollectionTime);\n            }\n        }\n        else {\n            // Call into user code to select aggregation temporality for the instrument.\n            aggregationTemporality = collector.selectAggregationTemporality(instrumentDescriptor.type);\n        }\n        // Update last reported (cumulative) accumulation.\n        this._reportHistory.set(collector, {\n            accumulations: result,\n            collectionTime: collectionTime,\n            aggregationTemporality: aggregationTemporality,\n        });\n        var accumulationRecords = AttributesMapToAccumulationRecords(result);\n        // do not convert to metric data if there is nothing to convert.\n        if (accumulationRecords.length === 0) {\n            return undefined;\n        }\n        return this._aggregator.toMetricData(instrumentDescriptor, aggregationTemporality, accumulationRecords, \n        /* endTime */ collectionTime);\n    };\n    TemporalMetricProcessor.prototype._stashAccumulations = function (currentAccumulation) {\n        var e_1, _a;\n        var registeredCollectors = this._unreportedAccumulations.keys();\n        try {\n            for (var registeredCollectors_1 = __values(registeredCollectors), registeredCollectors_1_1 = registeredCollectors_1.next(); !registeredCollectors_1_1.done; registeredCollectors_1_1 = registeredCollectors_1.next()) {\n                var collector = registeredCollectors_1_1.value;\n                var stash = this._unreportedAccumulations.get(collector);\n                if (stash === undefined) {\n                    stash = [];\n                    this._unreportedAccumulations.set(collector, stash);\n                }\n                stash.push(currentAccumulation);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (registeredCollectors_1_1 && !registeredCollectors_1_1.done && (_a = registeredCollectors_1.return)) _a.call(registeredCollectors_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    TemporalMetricProcessor.prototype._getMergedUnreportedAccumulations = function (collector) {\n        var e_2, _a;\n        var result = new AttributeHashMap();\n        var unreportedList = this._unreportedAccumulations.get(collector);\n        this._unreportedAccumulations.set(collector, []);\n        if (unreportedList === undefined) {\n            return result;\n        }\n        try {\n            for (var unreportedList_1 = __values(unreportedList), unreportedList_1_1 = unreportedList_1.next(); !unreportedList_1_1.done; unreportedList_1_1 = unreportedList_1.next()) {\n                var it_1 = unreportedList_1_1.value;\n                result = TemporalMetricProcessor.merge(result, it_1, this._aggregator);\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (unreportedList_1_1 && !unreportedList_1_1.done && (_a = unreportedList_1.return)) _a.call(unreportedList_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return result;\n    };\n    TemporalMetricProcessor.merge = function (last, current, aggregator) {\n        var result = last;\n        var iterator = current.entries();\n        var next = iterator.next();\n        while (next.done !== true) {\n            var _a = __read(next.value, 3), key = _a[0], record = _a[1], hash = _a[2];\n            if (last.has(key, hash)) {\n                var lastAccumulation = last.get(key, hash);\n                // last.has() returned true, lastAccumulation is present.\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                var accumulation = aggregator.merge(lastAccumulation, record);\n                result.set(key, accumulation, hash);\n            }\n            else {\n                result.set(key, record, hash);\n            }\n            next = iterator.next();\n        }\n        return result;\n    };\n    /**\n     * Calibrate the reported metric streams' startTime to lastCollectionTime. Leaves\n     * the new stream to be the initial observation time unchanged.\n     */\n    TemporalMetricProcessor.calibrateStartTime = function (last, current, lastCollectionTime) {\n        var e_3, _a;\n        try {\n            for (var _b = __values(last.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var _d = __read(_c.value, 2), key = _d[0], hash = _d[1];\n                var currentAccumulation = current.get(key, hash);\n                currentAccumulation === null || currentAccumulation === void 0 ? void 0 : currentAccumulation.setStartTime(lastCollectionTime);\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        return current;\n    };\n    return TemporalMetricProcessor;\n}());\nexport { TemporalMetricProcessor };\n// TypeScript complains about converting 3 elements tuple to AccumulationRecord<T>.\nfunction AttributesMapToAccumulationRecords(map) {\n    return Array.from(map.entries());\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}