{"ast":null,"code":"\"use strict\";\n\nvar extend = require('xtend');\nvar util = require('util');\nvar Transform = require('stream').Transform;\nvar render = require('./render');\nfunction HexTransform(options) {\n  if (!(this instanceof HexTransform)) {\n    return new HexTransform(options);\n  }\n  // istanbul ignore next\n  if (!options) options = {};\n  if (options.colored) options = extend(render.coloredOptions, options);\n  Transform.call(this, options);\n  var self = this;\n  self.options = options;\n  self.prefix = self.options.prefix || '';\n  self.cols = self.options.cols || 16;\n  self.group = self.options.group || 2;\n  self.gutter = self.options.gutter || 0;\n  // istanbul ignore if\n  self.annotateLine = options.annotateLine || null;\n  self.decorateHexen = self.options.decorateHexen || noopDecorate;\n  self.decorateHuman = self.options.decorateHuman || noopDecorate;\n  self.renderHexen = self.options.renderHexen || render.byte2hex;\n  self.renderHuman = self.options.renderHuman || render.byte2char;\n  // istanbul ignore next\n  self.groupSeparator = self.options.groupSeparator === undefined ? ' ' : self.options.groupSeparator;\n  self.headSep = self.options.headSep === undefined ? ': ' : self.options.headSep;\n  // istanbul ignore next\n  self.divide = self.options.divide === undefined ? '  ' : self.options.divide;\n  // istanbul ignore next\n  self.emptyHexen = self.options.emptyHexen === undefined ? '  ' : self.options.emptyHexen;\n  self.emptyHuman = self.options.emptyHuman || '';\n  self.nullHuman = self.options.nullHuman || '';\n  self.offsetWidth = self.options.offsetWidth || 8;\n  self.gutter = Math.max(self.offsetWidth, self.gutter);\n  self.line = '';\n  self.hexen = '';\n  self.human = '';\n  self.reset();\n}\nutil.inherits(HexTransform, Transform);\nHexTransform.prototype.reset = function reset() {\n  var self = this;\n  self._finishLine();\n  self.screenOffset = 0;\n  self.totalOffset = 0;\n};\nHexTransform.prototype._transform = function transform(chunk, encoding, done) {\n  var self = this;\n  for (var offset = 0; offset < chunk.length; offset++) {\n    if (self.screenOffset % self.cols === 0) {\n      self._finishLine();\n      self._startLine();\n    }\n    self._addByte(chunk[offset]);\n  }\n  done(null);\n};\nHexTransform.prototype._flush = function flush(done) {\n  var self = this;\n  if (self.totalOffset === 0 && self.nullHuman) {\n    self._startLine();\n    self.human += self.nullHuman;\n  }\n  self._finishLine();\n  done(null);\n};\nHexTransform.prototype._startLine = function startLine() {\n  var self = this;\n  var head = render.pad('0', self.totalOffset.toString(16), self.offsetWidth);\n  self.line = self.prefix + render.pad(' ', head, self.gutter) + self.headSep;\n};\nHexTransform.prototype._finishLine = function finishLine() {\n  var self = this;\n  if (self.line.length) {\n    var rem = self.screenOffset % self.cols;\n    if (rem !== 0 || self.totalOffset === 0 && self.nullHuman) {\n      rem = self.cols - rem;\n      for (var i = 0; i < rem; i++) {\n        self._addEmpty();\n      }\n    }\n    self.line += self.hexen + self.divide + self.human;\n    // istanbul ignore if\n    if (self.annotateLine) {\n      self.line += self.annotateLine(self.totalOffset - self.cols, self.totalOffset);\n    }\n    self.line += '\\n';\n    self.push(self.line);\n    self.line = '';\n    self.hexen = '';\n    self.human = '';\n  }\n};\nHexTransform.prototype._addEmpty = function addEmpty() {\n  var self = this;\n  self._addPart(self.emptyHexen, self.emptyHuman);\n};\nHexTransform.prototype._addByte = function addByte(b) {\n  var self = this;\n  var hexen = self.renderHexen(b);\n  var human = self.renderHuman(b);\n  self._addPart(hexen, human, b);\n};\nHexTransform.prototype._addPart = function addByte(hexen, human, b) {\n  var self = this;\n  hexen = self.decorateHexen(self.totalOffset, self.screenOffset, hexen, b);\n  human = self.decorateHuman(self.totalOffset, self.screenOffset, human, b);\n  var isStartOfRow = self.screenOffset % self.cols === 0;\n  var isStartOfGroup = self.screenOffset % self.group === 0;\n  if (!isStartOfRow && isStartOfGroup) {\n    self.hexen += self.groupSeparator;\n  }\n  self.hexen += hexen;\n  self.human += human;\n  self.totalOffset++;\n  self.screenOffset++;\n};\nfunction noopDecorate(offset, screenOffset, s) {\n  return s;\n}\nmodule.exports = HexTransform;","map":{"version":3,"names":["extend","require","util","Transform","render","HexTransform","options","colored","coloredOptions","call","self","prefix","cols","group","gutter","annotateLine","decorateHexen","noopDecorate","decorateHuman","renderHexen","byte2hex","renderHuman","byte2char","groupSeparator","undefined","headSep","divide","emptyHexen","emptyHuman","nullHuman","offsetWidth","Math","max","line","hexen","human","reset","inherits","prototype","_finishLine","screenOffset","totalOffset","_transform","transform","chunk","encoding","done","offset","length","_startLine","_addByte","_flush","flush","startLine","head","pad","toString","finishLine","rem","i","_addEmpty","push","addEmpty","_addPart","addByte","b","isStartOfRow","isStartOfGroup","s","module","exports"],"sources":["/home/bvpelt/Develop/openteltest/node_modules/hexer/hex_transform.js"],"sourcesContent":["\"use strict\";\n\nvar extend = require('xtend');\nvar util = require('util');\nvar Transform = require('stream').Transform;\nvar render = require('./render');\n\nfunction HexTransform(options) {\n    if (!(this instanceof HexTransform)) {\n        return new HexTransform(options);\n    }\n    // istanbul ignore next\n    if (!options) options = {};\n    if (options.colored) options = extend(render.coloredOptions, options);\n    Transform.call(this, options);\n    var self = this;\n    self.options = options;\n    self.prefix = self.options.prefix || '';\n    self.cols = self.options.cols || 16;\n    self.group = self.options.group || 2;\n    self.gutter = self.options.gutter || 0;\n    // istanbul ignore if\n    self.annotateLine = options.annotateLine || null;\n    self.decorateHexen = self.options.decorateHexen || noopDecorate;\n    self.decorateHuman = self.options.decorateHuman || noopDecorate;\n    self.renderHexen = self.options.renderHexen || render.byte2hex;\n    self.renderHuman = self.options.renderHuman || render.byte2char;\n    // istanbul ignore next\n    self.groupSeparator = self.options.groupSeparator === undefined ? ' ' : self.options.groupSeparator;\n    self.headSep = self.options.headSep === undefined ? ': ' : self.options.headSep;\n    // istanbul ignore next\n    self.divide = self.options.divide === undefined ? '  ' : self.options.divide;\n    // istanbul ignore next\n    self.emptyHexen = self.options.emptyHexen === undefined ? '  ' : self.options.emptyHexen;\n    self.emptyHuman = self.options.emptyHuman || '';\n    self.nullHuman = self.options.nullHuman || '';\n    self.offsetWidth = self.options.offsetWidth || 8;\n    self.gutter = Math.max(self.offsetWidth, self.gutter);\n    self.line = '';\n    self.hexen = '';\n    self.human = '';\n    self.reset();\n}\nutil.inherits(HexTransform, Transform);\n\nHexTransform.prototype.reset = function reset() {\n    var self = this;\n    self._finishLine();\n    self.screenOffset = 0;\n    self.totalOffset = 0;\n};\n\nHexTransform.prototype._transform = function transform(chunk, encoding, done) {\n    var self = this;\n    for (var offset=0; offset<chunk.length; offset++) {\n        if (self.screenOffset % self.cols === 0) {\n            self._finishLine();\n            self._startLine();\n        }\n        self._addByte(chunk[offset]);\n    }\n    done(null);\n};\n\nHexTransform.prototype._flush = function flush(done) {\n    var self = this;\n    if (self.totalOffset === 0 && self.nullHuman) {\n        self._startLine();\n        self.human += self.nullHuman;\n    }\n    self._finishLine();\n    done(null);\n};\n\nHexTransform.prototype._startLine = function startLine() {\n    var self = this;\n    var head = render.pad('0', self.totalOffset.toString(16), self.offsetWidth);\n    self.line = self.prefix + render.pad(' ', head, self.gutter) + self.headSep;\n};\n\nHexTransform.prototype._finishLine = function finishLine() {\n    var self = this;\n    if (self.line.length) {\n        var rem = self.screenOffset % self.cols;\n        if (rem !== 0 || (self.totalOffset === 0 && self.nullHuman)) {\n            rem = self.cols - rem;\n            for (var i=0; i<rem; i++) {\n                self._addEmpty();\n            }\n        }\n        self.line += self.hexen + self.divide + self.human;\n        // istanbul ignore if\n        if (self.annotateLine) {\n            self.line += self.annotateLine(self.totalOffset - self.cols, self.totalOffset);\n        }\n        self.line += '\\n';\n        self.push(self.line);\n        self.line = '';\n        self.hexen = '';\n        self.human = '';\n    }\n};\n\nHexTransform.prototype._addEmpty = function addEmpty() {\n    var self = this;\n    self._addPart(self.emptyHexen, self.emptyHuman);\n};\n\nHexTransform.prototype._addByte = function addByte(b) {\n    var self = this;\n    var hexen = self.renderHexen(b);\n    var human = self.renderHuman(b);\n    self._addPart(hexen, human, b);\n};\n\nHexTransform.prototype._addPart = function addByte(hexen, human, b) {\n    var self = this;\n    hexen = self.decorateHexen(self.totalOffset, self.screenOffset, hexen, b);\n    human = self.decorateHuman(self.totalOffset, self.screenOffset, human, b);\n    var isStartOfRow = self.screenOffset % self.cols === 0;\n    var isStartOfGroup = self.screenOffset % self.group === 0;\n    if (!isStartOfRow && isStartOfGroup) {\n        self.hexen += self.groupSeparator;\n    }\n    self.hexen += hexen;\n    self.human += human;\n    self.totalOffset++;\n    self.screenOffset++;\n};\n\nfunction noopDecorate(offset, screenOffset, s) {\n    return s;\n}\n\nmodule.exports = HexTransform;\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,MAAM,GAAGC,OAAO,CAAC,OAAO,CAAC;AAC7B,IAAIC,IAAI,GAAGD,OAAO,CAAC,MAAM,CAAC;AAC1B,IAAIE,SAAS,GAAGF,OAAO,CAAC,QAAQ,CAAC,CAACE,SAAS;AAC3C,IAAIC,MAAM,GAAGH,OAAO,CAAC,UAAU,CAAC;AAEhC,SAASI,YAAYA,CAACC,OAAO,EAAE;EAC3B,IAAI,EAAE,IAAI,YAAYD,YAAY,CAAC,EAAE;IACjC,OAAO,IAAIA,YAAY,CAACC,OAAO,CAAC;EACpC;EACA;EACA,IAAI,CAACA,OAAO,EAAEA,OAAO,GAAG,CAAC,CAAC;EAC1B,IAAIA,OAAO,CAACC,OAAO,EAAED,OAAO,GAAGN,MAAM,CAACI,MAAM,CAACI,cAAc,EAAEF,OAAO,CAAC;EACrEH,SAAS,CAACM,IAAI,CAAC,IAAI,EAAEH,OAAO,CAAC;EAC7B,IAAII,IAAI,GAAG,IAAI;EACfA,IAAI,CAACJ,OAAO,GAAGA,OAAO;EACtBI,IAAI,CAACC,MAAM,GAAGD,IAAI,CAACJ,OAAO,CAACK,MAAM,IAAI,EAAE;EACvCD,IAAI,CAACE,IAAI,GAAGF,IAAI,CAACJ,OAAO,CAACM,IAAI,IAAI,EAAE;EACnCF,IAAI,CAACG,KAAK,GAAGH,IAAI,CAACJ,OAAO,CAACO,KAAK,IAAI,CAAC;EACpCH,IAAI,CAACI,MAAM,GAAGJ,IAAI,CAACJ,OAAO,CAACQ,MAAM,IAAI,CAAC;EACtC;EACAJ,IAAI,CAACK,YAAY,GAAGT,OAAO,CAACS,YAAY,IAAI,IAAI;EAChDL,IAAI,CAACM,aAAa,GAAGN,IAAI,CAACJ,OAAO,CAACU,aAAa,IAAIC,YAAY;EAC/DP,IAAI,CAACQ,aAAa,GAAGR,IAAI,CAACJ,OAAO,CAACY,aAAa,IAAID,YAAY;EAC/DP,IAAI,CAACS,WAAW,GAAGT,IAAI,CAACJ,OAAO,CAACa,WAAW,IAAIf,MAAM,CAACgB,QAAQ;EAC9DV,IAAI,CAACW,WAAW,GAAGX,IAAI,CAACJ,OAAO,CAACe,WAAW,IAAIjB,MAAM,CAACkB,SAAS;EAC/D;EACAZ,IAAI,CAACa,cAAc,GAAGb,IAAI,CAACJ,OAAO,CAACiB,cAAc,KAAKC,SAAS,GAAG,GAAG,GAAGd,IAAI,CAACJ,OAAO,CAACiB,cAAc;EACnGb,IAAI,CAACe,OAAO,GAAGf,IAAI,CAACJ,OAAO,CAACmB,OAAO,KAAKD,SAAS,GAAG,IAAI,GAAGd,IAAI,CAACJ,OAAO,CAACmB,OAAO;EAC/E;EACAf,IAAI,CAACgB,MAAM,GAAGhB,IAAI,CAACJ,OAAO,CAACoB,MAAM,KAAKF,SAAS,GAAG,IAAI,GAAGd,IAAI,CAACJ,OAAO,CAACoB,MAAM;EAC5E;EACAhB,IAAI,CAACiB,UAAU,GAAGjB,IAAI,CAACJ,OAAO,CAACqB,UAAU,KAAKH,SAAS,GAAG,IAAI,GAAGd,IAAI,CAACJ,OAAO,CAACqB,UAAU;EACxFjB,IAAI,CAACkB,UAAU,GAAGlB,IAAI,CAACJ,OAAO,CAACsB,UAAU,IAAI,EAAE;EAC/ClB,IAAI,CAACmB,SAAS,GAAGnB,IAAI,CAACJ,OAAO,CAACuB,SAAS,IAAI,EAAE;EAC7CnB,IAAI,CAACoB,WAAW,GAAGpB,IAAI,CAACJ,OAAO,CAACwB,WAAW,IAAI,CAAC;EAChDpB,IAAI,CAACI,MAAM,GAAGiB,IAAI,CAACC,GAAG,CAACtB,IAAI,CAACoB,WAAW,EAAEpB,IAAI,CAACI,MAAM,CAAC;EACrDJ,IAAI,CAACuB,IAAI,GAAG,EAAE;EACdvB,IAAI,CAACwB,KAAK,GAAG,EAAE;EACfxB,IAAI,CAACyB,KAAK,GAAG,EAAE;EACfzB,IAAI,CAAC0B,KAAK,CAAC,CAAC;AAChB;AACAlC,IAAI,CAACmC,QAAQ,CAAChC,YAAY,EAAEF,SAAS,CAAC;AAEtCE,YAAY,CAACiC,SAAS,CAACF,KAAK,GAAG,SAASA,KAAKA,CAAA,EAAG;EAC5C,IAAI1B,IAAI,GAAG,IAAI;EACfA,IAAI,CAAC6B,WAAW,CAAC,CAAC;EAClB7B,IAAI,CAAC8B,YAAY,GAAG,CAAC;EACrB9B,IAAI,CAAC+B,WAAW,GAAG,CAAC;AACxB,CAAC;AAEDpC,YAAY,CAACiC,SAAS,CAACI,UAAU,GAAG,SAASC,SAASA,CAACC,KAAK,EAAEC,QAAQ,EAAEC,IAAI,EAAE;EAC1E,IAAIpC,IAAI,GAAG,IAAI;EACf,KAAK,IAAIqC,MAAM,GAAC,CAAC,EAAEA,MAAM,GAACH,KAAK,CAACI,MAAM,EAAED,MAAM,EAAE,EAAE;IAC9C,IAAIrC,IAAI,CAAC8B,YAAY,GAAG9B,IAAI,CAACE,IAAI,KAAK,CAAC,EAAE;MACrCF,IAAI,CAAC6B,WAAW,CAAC,CAAC;MAClB7B,IAAI,CAACuC,UAAU,CAAC,CAAC;IACrB;IACAvC,IAAI,CAACwC,QAAQ,CAACN,KAAK,CAACG,MAAM,CAAC,CAAC;EAChC;EACAD,IAAI,CAAC,IAAI,CAAC;AACd,CAAC;AAEDzC,YAAY,CAACiC,SAAS,CAACa,MAAM,GAAG,SAASC,KAAKA,CAACN,IAAI,EAAE;EACjD,IAAIpC,IAAI,GAAG,IAAI;EACf,IAAIA,IAAI,CAAC+B,WAAW,KAAK,CAAC,IAAI/B,IAAI,CAACmB,SAAS,EAAE;IAC1CnB,IAAI,CAACuC,UAAU,CAAC,CAAC;IACjBvC,IAAI,CAACyB,KAAK,IAAIzB,IAAI,CAACmB,SAAS;EAChC;EACAnB,IAAI,CAAC6B,WAAW,CAAC,CAAC;EAClBO,IAAI,CAAC,IAAI,CAAC;AACd,CAAC;AAEDzC,YAAY,CAACiC,SAAS,CAACW,UAAU,GAAG,SAASI,SAASA,CAAA,EAAG;EACrD,IAAI3C,IAAI,GAAG,IAAI;EACf,IAAI4C,IAAI,GAAGlD,MAAM,CAACmD,GAAG,CAAC,GAAG,EAAE7C,IAAI,CAAC+B,WAAW,CAACe,QAAQ,CAAC,EAAE,CAAC,EAAE9C,IAAI,CAACoB,WAAW,CAAC;EAC3EpB,IAAI,CAACuB,IAAI,GAAGvB,IAAI,CAACC,MAAM,GAAGP,MAAM,CAACmD,GAAG,CAAC,GAAG,EAAED,IAAI,EAAE5C,IAAI,CAACI,MAAM,CAAC,GAAGJ,IAAI,CAACe,OAAO;AAC/E,CAAC;AAEDpB,YAAY,CAACiC,SAAS,CAACC,WAAW,GAAG,SAASkB,UAAUA,CAAA,EAAG;EACvD,IAAI/C,IAAI,GAAG,IAAI;EACf,IAAIA,IAAI,CAACuB,IAAI,CAACe,MAAM,EAAE;IAClB,IAAIU,GAAG,GAAGhD,IAAI,CAAC8B,YAAY,GAAG9B,IAAI,CAACE,IAAI;IACvC,IAAI8C,GAAG,KAAK,CAAC,IAAKhD,IAAI,CAAC+B,WAAW,KAAK,CAAC,IAAI/B,IAAI,CAACmB,SAAU,EAAE;MACzD6B,GAAG,GAAGhD,IAAI,CAACE,IAAI,GAAG8C,GAAG;MACrB,KAAK,IAAIC,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACD,GAAG,EAAEC,CAAC,EAAE,EAAE;QACtBjD,IAAI,CAACkD,SAAS,CAAC,CAAC;MACpB;IACJ;IACAlD,IAAI,CAACuB,IAAI,IAAIvB,IAAI,CAACwB,KAAK,GAAGxB,IAAI,CAACgB,MAAM,GAAGhB,IAAI,CAACyB,KAAK;IAClD;IACA,IAAIzB,IAAI,CAACK,YAAY,EAAE;MACnBL,IAAI,CAACuB,IAAI,IAAIvB,IAAI,CAACK,YAAY,CAACL,IAAI,CAAC+B,WAAW,GAAG/B,IAAI,CAACE,IAAI,EAAEF,IAAI,CAAC+B,WAAW,CAAC;IAClF;IACA/B,IAAI,CAACuB,IAAI,IAAI,IAAI;IACjBvB,IAAI,CAACmD,IAAI,CAACnD,IAAI,CAACuB,IAAI,CAAC;IACpBvB,IAAI,CAACuB,IAAI,GAAG,EAAE;IACdvB,IAAI,CAACwB,KAAK,GAAG,EAAE;IACfxB,IAAI,CAACyB,KAAK,GAAG,EAAE;EACnB;AACJ,CAAC;AAED9B,YAAY,CAACiC,SAAS,CAACsB,SAAS,GAAG,SAASE,QAAQA,CAAA,EAAG;EACnD,IAAIpD,IAAI,GAAG,IAAI;EACfA,IAAI,CAACqD,QAAQ,CAACrD,IAAI,CAACiB,UAAU,EAAEjB,IAAI,CAACkB,UAAU,CAAC;AACnD,CAAC;AAEDvB,YAAY,CAACiC,SAAS,CAACY,QAAQ,GAAG,SAASc,OAAOA,CAACC,CAAC,EAAE;EAClD,IAAIvD,IAAI,GAAG,IAAI;EACf,IAAIwB,KAAK,GAAGxB,IAAI,CAACS,WAAW,CAAC8C,CAAC,CAAC;EAC/B,IAAI9B,KAAK,GAAGzB,IAAI,CAACW,WAAW,CAAC4C,CAAC,CAAC;EAC/BvD,IAAI,CAACqD,QAAQ,CAAC7B,KAAK,EAAEC,KAAK,EAAE8B,CAAC,CAAC;AAClC,CAAC;AAED5D,YAAY,CAACiC,SAAS,CAACyB,QAAQ,GAAG,SAASC,OAAOA,CAAC9B,KAAK,EAAEC,KAAK,EAAE8B,CAAC,EAAE;EAChE,IAAIvD,IAAI,GAAG,IAAI;EACfwB,KAAK,GAAGxB,IAAI,CAACM,aAAa,CAACN,IAAI,CAAC+B,WAAW,EAAE/B,IAAI,CAAC8B,YAAY,EAAEN,KAAK,EAAE+B,CAAC,CAAC;EACzE9B,KAAK,GAAGzB,IAAI,CAACQ,aAAa,CAACR,IAAI,CAAC+B,WAAW,EAAE/B,IAAI,CAAC8B,YAAY,EAAEL,KAAK,EAAE8B,CAAC,CAAC;EACzE,IAAIC,YAAY,GAAGxD,IAAI,CAAC8B,YAAY,GAAG9B,IAAI,CAACE,IAAI,KAAK,CAAC;EACtD,IAAIuD,cAAc,GAAGzD,IAAI,CAAC8B,YAAY,GAAG9B,IAAI,CAACG,KAAK,KAAK,CAAC;EACzD,IAAI,CAACqD,YAAY,IAAIC,cAAc,EAAE;IACjCzD,IAAI,CAACwB,KAAK,IAAIxB,IAAI,CAACa,cAAc;EACrC;EACAb,IAAI,CAACwB,KAAK,IAAIA,KAAK;EACnBxB,IAAI,CAACyB,KAAK,IAAIA,KAAK;EACnBzB,IAAI,CAAC+B,WAAW,EAAE;EAClB/B,IAAI,CAAC8B,YAAY,EAAE;AACvB,CAAC;AAED,SAASvB,YAAYA,CAAC8B,MAAM,EAAEP,YAAY,EAAE4B,CAAC,EAAE;EAC3C,OAAOA,CAAC;AACZ;AAEAC,MAAM,CAACC,OAAO,GAAGjE,YAAY"},"metadata":{},"sourceType":"script","externalDependencies":[]}