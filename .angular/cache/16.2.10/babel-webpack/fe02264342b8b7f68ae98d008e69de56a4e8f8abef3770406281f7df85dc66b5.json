{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _asyncToGenerator = require(\"/home/bvpelt/Develop/openteltest/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JaegerExporter = void 0;\nconst api_1 = require(\"@opentelemetry/api\");\nconst core_1 = require(\"@opentelemetry/core\");\nconst dgram_1 = require(\"dgram\");\nconst semantic_conventions_1 = require(\"@opentelemetry/semantic-conventions\");\nconst transform_1 = require(\"./transform\");\nconst jaegerTypes = require(\"./types\");\n/**\n * Format and sends span information to Jaeger Exporter.\n *\n * @deprecated Jaeger supports the OpenTelemetry protocol natively\n * (see https://www.jaegertracing.io/docs/1.41/apis/#opentelemetry-protocol-stable).\n * This exporter will not be required by the OpenTelemetry specification starting July 2023, and\n * will not receive any security fixes past March 2024.\n *\n * Please migrate to any of the following packages:\n * - `@opentelemetry/exporter-trace-otlp-proto`\n * - `@opentelemetry/exporter-trace-otlp-grpc`\n * - `@opentelemetry/exporter-trace-otlp-http`\n */\nclass JaegerExporter {\n  constructor(config) {\n    const localConfig = Object.assign({}, config);\n    this._onShutdownFlushTimeout = typeof localConfig.flushTimeout === 'number' ? localConfig.flushTimeout : 2000;\n    // https://github.com/jaegertracing/jaeger-client-node#environment-variables\n    // By default, the client sends traces via UDP to the agent at localhost:6832. Use OTEL_EXPORTER_JAEGER_AGENT_HOST and\n    // JAEGER_AGENT_PORT to send UDP traces to a different host:port. If OTEL_EXPORTER_JAEGER_ENDPOINT is set, the client sends traces\n    // to the endpoint via HTTP, making the OTEL_EXPORTER_JAEGER_AGENT_HOST and JAEGER_AGENT_PORT unused. If OTEL_EXPORTER_JAEGER_ENDPOINT is secured,\n    // HTTP basic authentication can be performed by setting the OTEL_EXPORTER_JAEGER_USER and OTEL_EXPORTER_JAEGER_PASSWORD environment variables.\n    const env = (0, core_1.getEnv)();\n    localConfig.endpoint = localConfig.endpoint || env.OTEL_EXPORTER_JAEGER_ENDPOINT;\n    localConfig.username = localConfig.username || env.OTEL_EXPORTER_JAEGER_USER;\n    localConfig.password = localConfig.password || env.OTEL_EXPORTER_JAEGER_PASSWORD;\n    localConfig.host = localConfig.host || env.OTEL_EXPORTER_JAEGER_AGENT_HOST;\n    localConfig.port = localConfig.port || env.OTEL_EXPORTER_JAEGER_AGENT_PORT;\n    this._localConfig = localConfig;\n    this._shutdownOnce = new core_1.BindOnceFuture(this._shutdown, this);\n  }\n  /** Exports a list of spans to Jaeger. */\n  export(spans, resultCallback) {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n    if (spans.length === 0) {\n      return resultCallback({\n        code: core_1.ExportResultCode.SUCCESS\n      });\n    }\n    api_1.diag.debug('Jaeger exporter export');\n    this._sendSpans(spans, resultCallback).catch(error => {\n      return resultCallback({\n        code: core_1.ExportResultCode.FAILED,\n        error\n      });\n    });\n  }\n  /** Shutdown exporter. */\n  shutdown() {\n    return this._shutdownOnce.call();\n  }\n  /**\n   * Exports any pending spans in exporter\n   */\n  forceFlush() {\n    return this._flush();\n  }\n  _shutdown() {\n    return Promise.race([new Promise((_resolve, reject) => {\n      setTimeout(() => reject(new Error('Flush timeout')), this._onShutdownFlushTimeout);\n    }), this._flush()]).finally(() => {\n      var _a;\n      (_a = this._sender) === null || _a === void 0 ? void 0 : _a.close();\n    });\n  }\n  /** Transform spans and sends to Jaeger service. */\n  _sendSpans(spans, done) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const thriftSpan = spans.map(span => (0, transform_1.spanToThrift)(span));\n      for (const span of thriftSpan) {\n        try {\n          yield _this._append(span);\n        } catch (error) {\n          // TODO right now we break out on first error, is that desirable?\n          if (done) return done({\n            code: core_1.ExportResultCode.FAILED,\n            error\n          });\n        }\n      }\n      api_1.diag.debug(`successful append for : ${thriftSpan.length}`);\n      // Flush all spans on each export. No-op if span buffer is empty\n      yield _this._flush();\n      if (done) return process.nextTick(done, {\n        code: core_1.ExportResultCode.SUCCESS\n      });\n    })();\n  }\n  _append(span) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => {\n        _this2._getSender(span).append(span, (count, err) => {\n          if (err) {\n            return reject(new Error(err));\n          }\n          resolve(count);\n        });\n      });\n    })();\n  }\n  _getSender(span) {\n    if (this._sender) {\n      return this._sender;\n    }\n    const sender = this._localConfig.endpoint ? new jaegerTypes.HTTPSender(this._localConfig) : new jaegerTypes.UDPSender(this._localConfig);\n    if (sender._client instanceof dgram_1.Socket) {\n      // unref socket to prevent it from keeping the process running\n      sender._client.unref();\n    }\n    const serviceNameTag = span.tags.find(t => t.key === semantic_conventions_1.SemanticResourceAttributes.SERVICE_NAME);\n    const serviceName = (serviceNameTag === null || serviceNameTag === void 0 ? void 0 : serviceNameTag.vStr) || 'unknown_service';\n    sender.setProcess({\n      serviceName,\n      tags: jaegerTypes.ThriftUtils.getThriftTags(this._localConfig.tags || [])\n    });\n    this._sender = sender;\n    return sender;\n  }\n  _flush() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      yield new Promise((resolve, reject) => {\n        if (!_this3._sender) {\n          return resolve();\n        }\n        _this3._sender.flush((_count, err) => {\n          if (err) {\n            return reject(new Error(err));\n          }\n          api_1.diag.debug(`successful flush for ${_count} spans`);\n          resolve();\n        });\n      });\n    })();\n  }\n}\nexports.JaegerExporter = JaegerExporter;","map":{"version":3,"names":["_asyncToGenerator","require","default","Object","defineProperty","exports","value","JaegerExporter","api_1","core_1","dgram_1","semantic_conventions_1","transform_1","jaegerTypes","constructor","config","localConfig","assign","_onShutdownFlushTimeout","flushTimeout","env","getEnv","endpoint","OTEL_EXPORTER_JAEGER_ENDPOINT","username","OTEL_EXPORTER_JAEGER_USER","password","OTEL_EXPORTER_JAEGER_PASSWORD","host","OTEL_EXPORTER_JAEGER_AGENT_HOST","port","OTEL_EXPORTER_JAEGER_AGENT_PORT","_localConfig","_shutdownOnce","BindOnceFuture","_shutdown","export","spans","resultCallback","isCalled","length","code","ExportResultCode","SUCCESS","diag","debug","_sendSpans","catch","error","FAILED","shutdown","call","forceFlush","_flush","Promise","race","_resolve","reject","setTimeout","Error","finally","_a","_sender","close","done","_this","thriftSpan","map","span","spanToThrift","_append","process","nextTick","_this2","resolve","_getSender","append","count","err","sender","HTTPSender","UDPSender","_client","Socket","unref","serviceNameTag","tags","find","t","key","SemanticResourceAttributes","SERVICE_NAME","serviceName","vStr","setProcess","ThriftUtils","getThriftTags","_this3","flush","_count"],"sources":["/home/bvpelt/Develop/openteltest/node_modules/@opentelemetry/exporter-jaeger/build/src/jaeger.js"],"sourcesContent":["\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JaegerExporter = void 0;\nconst api_1 = require(\"@opentelemetry/api\");\nconst core_1 = require(\"@opentelemetry/core\");\nconst dgram_1 = require(\"dgram\");\nconst semantic_conventions_1 = require(\"@opentelemetry/semantic-conventions\");\nconst transform_1 = require(\"./transform\");\nconst jaegerTypes = require(\"./types\");\n/**\n * Format and sends span information to Jaeger Exporter.\n *\n * @deprecated Jaeger supports the OpenTelemetry protocol natively\n * (see https://www.jaegertracing.io/docs/1.41/apis/#opentelemetry-protocol-stable).\n * This exporter will not be required by the OpenTelemetry specification starting July 2023, and\n * will not receive any security fixes past March 2024.\n *\n * Please migrate to any of the following packages:\n * - `@opentelemetry/exporter-trace-otlp-proto`\n * - `@opentelemetry/exporter-trace-otlp-grpc`\n * - `@opentelemetry/exporter-trace-otlp-http`\n */\nclass JaegerExporter {\n    constructor(config) {\n        const localConfig = Object.assign({}, config);\n        this._onShutdownFlushTimeout =\n            typeof localConfig.flushTimeout === 'number'\n                ? localConfig.flushTimeout\n                : 2000;\n        // https://github.com/jaegertracing/jaeger-client-node#environment-variables\n        // By default, the client sends traces via UDP to the agent at localhost:6832. Use OTEL_EXPORTER_JAEGER_AGENT_HOST and\n        // JAEGER_AGENT_PORT to send UDP traces to a different host:port. If OTEL_EXPORTER_JAEGER_ENDPOINT is set, the client sends traces\n        // to the endpoint via HTTP, making the OTEL_EXPORTER_JAEGER_AGENT_HOST and JAEGER_AGENT_PORT unused. If OTEL_EXPORTER_JAEGER_ENDPOINT is secured,\n        // HTTP basic authentication can be performed by setting the OTEL_EXPORTER_JAEGER_USER and OTEL_EXPORTER_JAEGER_PASSWORD environment variables.\n        const env = (0, core_1.getEnv)();\n        localConfig.endpoint =\n            localConfig.endpoint || env.OTEL_EXPORTER_JAEGER_ENDPOINT;\n        localConfig.username =\n            localConfig.username || env.OTEL_EXPORTER_JAEGER_USER;\n        localConfig.password =\n            localConfig.password || env.OTEL_EXPORTER_JAEGER_PASSWORD;\n        localConfig.host = localConfig.host || env.OTEL_EXPORTER_JAEGER_AGENT_HOST;\n        localConfig.port = localConfig.port || env.OTEL_EXPORTER_JAEGER_AGENT_PORT;\n        this._localConfig = localConfig;\n        this._shutdownOnce = new core_1.BindOnceFuture(this._shutdown, this);\n    }\n    /** Exports a list of spans to Jaeger. */\n    export(spans, resultCallback) {\n        if (this._shutdownOnce.isCalled) {\n            return;\n        }\n        if (spans.length === 0) {\n            return resultCallback({ code: core_1.ExportResultCode.SUCCESS });\n        }\n        api_1.diag.debug('Jaeger exporter export');\n        this._sendSpans(spans, resultCallback).catch(error => {\n            return resultCallback({ code: core_1.ExportResultCode.FAILED, error });\n        });\n    }\n    /** Shutdown exporter. */\n    shutdown() {\n        return this._shutdownOnce.call();\n    }\n    /**\n     * Exports any pending spans in exporter\n     */\n    forceFlush() {\n        return this._flush();\n    }\n    _shutdown() {\n        return Promise.race([\n            new Promise((_resolve, reject) => {\n                setTimeout(() => reject(new Error('Flush timeout')), this._onShutdownFlushTimeout);\n            }),\n            this._flush(),\n        ]).finally(() => {\n            var _a;\n            (_a = this._sender) === null || _a === void 0 ? void 0 : _a.close();\n        });\n    }\n    /** Transform spans and sends to Jaeger service. */\n    async _sendSpans(spans, done) {\n        const thriftSpan = spans.map(span => (0, transform_1.spanToThrift)(span));\n        for (const span of thriftSpan) {\n            try {\n                await this._append(span);\n            }\n            catch (error) {\n                // TODO right now we break out on first error, is that desirable?\n                if (done)\n                    return done({ code: core_1.ExportResultCode.FAILED, error });\n            }\n        }\n        api_1.diag.debug(`successful append for : ${thriftSpan.length}`);\n        // Flush all spans on each export. No-op if span buffer is empty\n        await this._flush();\n        if (done)\n            return process.nextTick(done, { code: core_1.ExportResultCode.SUCCESS });\n    }\n    async _append(span) {\n        return new Promise((resolve, reject) => {\n            this._getSender(span).append(span, (count, err) => {\n                if (err) {\n                    return reject(new Error(err));\n                }\n                resolve(count);\n            });\n        });\n    }\n    _getSender(span) {\n        if (this._sender) {\n            return this._sender;\n        }\n        const sender = this._localConfig.endpoint\n            ? new jaegerTypes.HTTPSender(this._localConfig)\n            : new jaegerTypes.UDPSender(this._localConfig);\n        if (sender._client instanceof dgram_1.Socket) {\n            // unref socket to prevent it from keeping the process running\n            sender._client.unref();\n        }\n        const serviceNameTag = span.tags.find(t => t.key === semantic_conventions_1.SemanticResourceAttributes.SERVICE_NAME);\n        const serviceName = (serviceNameTag === null || serviceNameTag === void 0 ? void 0 : serviceNameTag.vStr) || 'unknown_service';\n        sender.setProcess({\n            serviceName,\n            tags: jaegerTypes.ThriftUtils.getThriftTags(this._localConfig.tags || []),\n        });\n        this._sender = sender;\n        return sender;\n    }\n    async _flush() {\n        await new Promise((resolve, reject) => {\n            if (!this._sender) {\n                return resolve();\n            }\n            this._sender.flush((_count, err) => {\n                if (err) {\n                    return reject(new Error(err));\n                }\n                api_1.diag.debug(`successful flush for ${_count} spans`);\n                resolve();\n            });\n        });\n    }\n}\nexports.JaegerExporter = JaegerExporter;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}