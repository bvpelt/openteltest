{"ast":null,"code":"// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar hex = require('hexer');\nvar util = require('util');\nvar Result = require('./result');\nvar errors = require('./errors');\nvar AnnotatedBuffer = require('./annotated_buffer');\nvar errorHighlighter = require('./error_highlighter');\nfunction makeAnnotatedBuffer(buffer, start, clear) {\n  // istanbul ignore if\n  if (start > 0) buffer = buffer.slice(start);\n  // istanbul ignore if\n  if (clear) buffer.fill(0);\n  return new AnnotatedBuffer(buffer);\n}\nfunction annotateError(res1, res2, start, annBuf) {\n  // istanbul ignore if\n  if (!res2.err || res2.offset !== res1.offset - start || res2.err.type !== res1.err.type || res2.err.message !== res1.err.message) {\n    res1.err = errors.UnstableRW(res1.err, {\n      otherMessage: res2.err && res2.err.message\n    });\n  } else {\n    res1.err.buffer = annBuf;\n  }\n}\nvar emptyBuffer = Buffer.alloc(0);\nfunction fromBuffer(rw, buffer, offset) {\n  return fromBufferResult(rw, buffer, offset).toValue();\n}\nfunction byteLength(rw, value) {\n  return byteLengthResult(rw, value).toValue();\n}\nfunction toBuffer(rw, value) {\n  return toBufferResult(rw, value).toValue();\n}\nfunction intoBuffer(rw, buffer, value) {\n  return intoBufferResult(rw, buffer, value).toValue();\n}\n\n// The \"Tuple\" methods are deprecated\n\n/* istanbul ignore next */\nfunction fromBufferTuple(rw, buffer, offset) {\n  return fromBufferResult(rw, buffer, offset).toTuple();\n}\n\n/* istanbul ignore next */\nfunction byteLengthTuple(rw, value) {\n  return byteLengthResult(rw, value).toTuple();\n}\n\n/* istanbul ignore next */\nfunction toBufferTuple(rw, value) {\n  return toBufferResult(rw, value).toTuple();\n}\n\n/* istanbul ignore next */\nfunction intoBufferTuple(rw, buffer, value) {\n  return intoBufferResult(rw, buffer, value).toTuple();\n}\nfunction checkAllReadFrom(res, buffer) {\n  if (!res.err && res.offset !== buffer.length) {\n    res.err = errors.ShortRead({\n      remaining: buffer.length - res.offset,\n      buffer: buffer,\n      offset: res.offset\n    });\n  }\n  return res;\n}\nfunction genericResult(err, value, buffer, offset) {\n  if (err) {\n    if (err.offset === undefined) err.offset = offset;\n    if (err.buffer === undefined) err.buffer = buffer;\n  }\n  return new Result(err, value);\n}\nfunction fromBufferResult(rw, buffer, offset) {\n  var start = offset || 0;\n  var res = rw.readFrom(buffer, start);\n  res = checkAllReadFrom(res, buffer);\n  if (res.err) {\n    var annBuf = makeAnnotatedBuffer(buffer, start, false);\n    var res2 = rw.readFrom(annBuf, 0);\n    res2 = checkAllReadFrom(res2, buffer);\n    annotateError(res, res2, start, annBuf);\n  }\n  return genericResult(res.err, res.value, buffer, res.offset);\n}\nfunction byteLengthResult(rw, value) {\n  var lenRes = rw.byteLength(value);\n  if (lenRes.err) return new Result(lenRes.err, 0);else return new Result(null, lenRes.length);\n}\nfunction toBufferResult(rw, value) {\n  var lenRes = rw.byteLength(value);\n  if (lenRes.err) return new Result(lenRes.err, emptyBuffer);\n  var length = lenRes.length;\n  var buffer = Buffer.alloc(length);\n  return intoBufferResult(rw, buffer, value);\n}\nfunction checkAllWroteOver(res, buffer) {\n  if (!res.err && res.offset !== buffer.length) {\n    res.err = errors.ShortWrite({\n      remaining: buffer.length - res.offset,\n      buffer: buffer,\n      offset: res.offset\n    });\n  }\n  return res;\n}\nfunction intoBufferResult(rw, buffer, value) {\n  var res = rw.writeInto(value, buffer, 0);\n  res = checkAllWroteOver(res, buffer);\n  return genericResult(res.err, buffer, buffer, res.offset);\n}\n\n// istanbul ignore next TODO\nfunction formatError(err, options) {\n  options = options || {};\n  var name = err.name || err.constructor.name;\n  var str = util.format('%s: %s\\n', name, err.message);\n  if (err.buffer && err.buffer.hexdump) {\n    str += err.buffer.hexdump({\n      colored: options.color,\n      boldStart: false,\n      highlight: options.color ? errorHighlighter(err, options) : null\n    });\n  } else if (Buffer.isBuffer(err.buffer)) {\n    if (options.color) {\n      str += formatBufferColored(err, options);\n    } else {\n      str += formatBufferUncolored(err, options);\n    }\n  }\n  return str;\n}\n\n// istanbul ignore next TODO\nfunction formatBufferColored(err, options) {\n  // istanbul ignore else\n  if (!hex) {\n    return err.buffer.toString('hex');\n  }\n  options = options || {};\n  var opts = options.hexerOptions ? Object.create(options.hexerOptions) : {};\n  if (opts.colored === undefined) {\n    opts.colored = true;\n  }\n  var highlight = errorHighlighter(err, options);\n  opts.decorateHexen = highlight;\n  opts.decorateHuman = highlight;\n  return hex(err.buffer, opts);\n}\n\n// istanbul ignore next TODO\nfunction formatBufferUncolored(err, options) {\n  // istanbul ignore else\n  if (!hex) {\n    return err.buffer.toString('hex');\n  }\n  options = options || {};\n  var hasOffset = !(err.offset === undefined || err.offset === null);\n  var hasEnd = !(err.endOffset === undefined || err.endOffset === null);\n  var markStart = options.markStart || '>';\n  var markEnd = options.markEnd || '<';\n  var accum = 0;\n  var opts = options.hexerOptions ? Object.create(options.hexerOptions) : {};\n  if (hasOffset) {\n    opts.groupSeparator = '';\n    if (hasEnd) {\n      opts.decorateHexen = decorateRangedError;\n    } else {\n      opts.decorateHexen = decorateError;\n    }\n  }\n  return hex(err.buffer, opts);\n\n  // TODO: suspected broken across lines, should either test and complete or\n  // use some sort of alternate notation such as interstitial lines\n  function decorateRangedError(totalOffset, screenOffset, hexen) {\n    var s;\n    if (totalOffset === err.offset) {\n      accum = 1;\n      s = markStart + hexen;\n      if (totalOffset === err.endOffset - 1) {\n        s += markEnd;\n        accum = 0;\n      } else {\n        s = ' ' + s;\n      }\n      return s;\n    } else if (totalOffset === err.endOffset - 1) {\n      s = hexen + markEnd;\n      while (accum-- > 0) s += ' ';\n      accum = 0;\n      return s;\n    } else if (accum) {\n      accum += 2;\n      return hexen;\n    } else {\n      return ' ' + hexen + ' ';\n    }\n  }\n  function decorateError(totalOffset, screenOffset, hexen) {\n    if (totalOffset === err.offset) {\n      return markStart + hexen + markEnd;\n    } else {\n      return ' ' + hexen + ' ';\n    }\n  }\n}\nmodule.exports.fromBuffer = fromBuffer;\nmodule.exports.byteLength = byteLength;\nmodule.exports.toBuffer = toBuffer;\nmodule.exports.intoBuffer = intoBuffer;\nmodule.exports.formatError = formatError;\nmodule.exports.fromBufferTuple = fromBufferTuple;\nmodule.exports.byteLengthTuple = byteLengthTuple;\nmodule.exports.toBufferTuple = toBufferTuple;\nmodule.exports.intoBufferTuple = intoBufferTuple;\nmodule.exports.fromBufferResult = fromBufferResult;\nmodule.exports.byteLengthResult = byteLengthResult;\nmodule.exports.toBufferResult = toBufferResult;\nmodule.exports.intoBufferResult = intoBufferResult;\nmodule.exports.makeAnnotatedBuffer = makeAnnotatedBuffer;\nmodule.exports.checkAllReadFrom = checkAllReadFrom;\nmodule.exports.annotateError = annotateError;","map":{"version":3,"names":["hex","require","util","Result","errors","AnnotatedBuffer","errorHighlighter","makeAnnotatedBuffer","buffer","start","clear","slice","fill","annotateError","res1","res2","annBuf","err","offset","type","message","UnstableRW","otherMessage","emptyBuffer","Buffer","alloc","fromBuffer","rw","fromBufferResult","toValue","byteLength","value","byteLengthResult","toBuffer","toBufferResult","intoBuffer","intoBufferResult","fromBufferTuple","toTuple","byteLengthTuple","toBufferTuple","intoBufferTuple","checkAllReadFrom","res","length","ShortRead","remaining","genericResult","undefined","readFrom","lenRes","checkAllWroteOver","ShortWrite","writeInto","formatError","options","name","constructor","str","format","hexdump","colored","color","boldStart","highlight","isBuffer","formatBufferColored","formatBufferUncolored","toString","opts","hexerOptions","Object","create","decorateHexen","decorateHuman","hasOffset","hasEnd","endOffset","markStart","markEnd","accum","groupSeparator","decorateRangedError","decorateError","totalOffset","screenOffset","hexen","s","module","exports"],"sources":["/home/bvpelt/Develop/openteltest/node_modules/bufrw/interface.js"],"sourcesContent":["// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n'use strict';\n\nvar hex = require('hexer');\n\nvar util = require('util');\nvar Result = require('./result');\nvar errors = require('./errors');\n\nvar AnnotatedBuffer = require('./annotated_buffer');\nvar errorHighlighter = require('./error_highlighter');\n\nfunction makeAnnotatedBuffer(buffer, start, clear) {\n    // istanbul ignore if\n    if (start > 0) buffer = buffer.slice(start);\n    // istanbul ignore if\n    if (clear) buffer.fill(0);\n    return new AnnotatedBuffer(buffer);\n}\n\nfunction annotateError(res1, res2, start, annBuf) {\n    // istanbul ignore if\n    if (!res2.err ||\n        res2.offset !== res1.offset - start ||\n        res2.err.type !== res1.err.type ||\n        res2.err.message !== res1.err.message) {\n        res1.err = errors.UnstableRW(res1.err, {\n            otherMessage: res2.err && res2.err.message\n        });\n    } else {\n        res1.err.buffer = annBuf;\n    }\n}\n\nvar emptyBuffer = Buffer.alloc(0);\n\nfunction fromBuffer(rw, buffer, offset) {\n    return fromBufferResult(rw, buffer, offset).toValue();\n}\n\nfunction byteLength(rw, value) {\n    return byteLengthResult(rw, value).toValue();\n}\n\nfunction toBuffer(rw, value) {\n    return toBufferResult(rw, value).toValue();\n}\n\nfunction intoBuffer(rw, buffer, value) {\n    return intoBufferResult(rw, buffer, value).toValue();\n}\n\n// The \"Tuple\" methods are deprecated\n\n/* istanbul ignore next */\nfunction fromBufferTuple(rw, buffer, offset) {\n    return fromBufferResult(rw, buffer, offset).toTuple();\n}\n\n/* istanbul ignore next */\nfunction byteLengthTuple(rw, value) {\n    return byteLengthResult(rw, value).toTuple();\n}\n\n/* istanbul ignore next */\nfunction toBufferTuple(rw, value) {\n    return toBufferResult(rw, value).toTuple();\n}\n\n/* istanbul ignore next */\nfunction intoBufferTuple(rw, buffer, value) {\n    return intoBufferResult(rw, buffer, value).toTuple();\n}\n\nfunction checkAllReadFrom(res, buffer) {\n    if (!res.err && res.offset !== buffer.length) {\n        res.err = errors.ShortRead({\n            remaining: buffer.length - res.offset,\n            buffer: buffer,\n            offset: res.offset\n        });\n    }\n    return res;\n}\n\nfunction genericResult(err, value, buffer, offset) {\n    if (err) {\n        if (err.offset === undefined) err.offset = offset;\n        if (err.buffer === undefined) err.buffer = buffer;\n    }\n    return new Result(err, value);\n}\n\nfunction fromBufferResult(rw, buffer, offset) {\n    var start = offset || 0;\n    var res = rw.readFrom(buffer, start);\n    res = checkAllReadFrom(res, buffer);\n    if (res.err) {\n        var annBuf = makeAnnotatedBuffer(buffer, start, false);\n        var res2 = rw.readFrom(annBuf, 0);\n        res2 = checkAllReadFrom(res2, buffer);\n        annotateError(res, res2, start, annBuf);\n    }\n    return genericResult(res.err, res.value, buffer, res.offset);\n}\n\nfunction byteLengthResult(rw, value) {\n    var lenRes = rw.byteLength(value);\n    if (lenRes.err) return new Result(lenRes.err, 0);\n    else return new Result(null, lenRes.length);\n}\n\nfunction toBufferResult(rw, value) {\n    var lenRes = rw.byteLength(value);\n    if (lenRes.err) return new Result(lenRes.err, emptyBuffer);\n    var length = lenRes.length;\n    var buffer = Buffer.alloc(length);\n    return intoBufferResult(rw, buffer, value);\n}\n\nfunction checkAllWroteOver(res, buffer) {\n    if (!res.err && res.offset !== buffer.length) {\n        res.err = errors.ShortWrite({\n            remaining: buffer.length - res.offset,\n            buffer: buffer,\n            offset: res.offset\n        });\n    }\n    return res;\n}\n\nfunction intoBufferResult(rw, buffer, value) {\n    var res = rw.writeInto(value, buffer, 0);\n    res = checkAllWroteOver(res, buffer);\n    return genericResult(res.err, buffer, buffer, res.offset);\n}\n\n// istanbul ignore next TODO\nfunction formatError(err, options) {\n    options = options || {};\n    var name = err.name || err.constructor.name;\n    var str = util.format('%s: %s\\n', name, err.message);\n    if (err.buffer && err.buffer.hexdump) {\n        str += err.buffer.hexdump({\n            colored: options.color,\n            boldStart: false,\n            highlight: options.color ? errorHighlighter(err, options) : null\n        });\n    } else if (Buffer.isBuffer(err.buffer)) {\n        if (options.color) {\n            str += formatBufferColored(err, options);\n        } else {\n            str += formatBufferUncolored(err, options);\n        }\n    }\n    return str;\n}\n\n// istanbul ignore next TODO\nfunction formatBufferColored(err, options) {\n    // istanbul ignore else\n    if (!hex) {\n        return err.buffer.toString('hex');\n    }\n\n    options = options || {};\n    var opts = options.hexerOptions ? Object.create(options.hexerOptions) : {};\n    if (opts.colored === undefined) {\n        opts.colored = true;\n    }\n    var highlight = errorHighlighter(err, options);\n    opts.decorateHexen = highlight;\n    opts.decorateHuman = highlight;\n    return hex(err.buffer, opts);\n}\n\n// istanbul ignore next TODO\nfunction formatBufferUncolored(err, options) {\n    // istanbul ignore else\n    if (!hex) {\n        return err.buffer.toString('hex');\n    }\n\n    options = options || {};\n\n    var hasOffset = !(err.offset === undefined || err.offset === null);\n    var hasEnd = !(err.endOffset === undefined || err.endOffset === null);\n    var markStart = options.markStart || '>';\n    var markEnd = options.markEnd || '<';\n    var accum = 0;\n\n    var opts = options.hexerOptions ? Object.create(options.hexerOptions) : {};\n    if (hasOffset) {\n        opts.groupSeparator = '';\n        if (hasEnd) {\n            opts.decorateHexen = decorateRangedError;\n        } else {\n            opts.decorateHexen = decorateError;\n        }\n    }\n    return hex(err.buffer, opts);\n\n    // TODO: suspected broken across lines, should either test and complete or\n    // use some sort of alternate notation such as interstitial lines\n    function decorateRangedError(totalOffset, screenOffset, hexen) {\n        var s;\n        if (totalOffset === err.offset) {\n            accum = 1;\n            s = markStart + hexen;\n            if (totalOffset === err.endOffset-1) {\n                s += markEnd;\n                accum = 0;\n            } else {\n                s = ' ' + s;\n            }\n            return s;\n        } else if (totalOffset === err.endOffset-1) {\n            s = hexen + markEnd;\n            while (accum-- > 0) s += ' ';\n            accum = 0;\n            return s;\n        } else if (accum) {\n            accum += 2;\n            return hexen;\n        } else {\n            return ' ' + hexen + ' ';\n        }\n    }\n\n    function decorateError(totalOffset, screenOffset, hexen) {\n        if (totalOffset === err.offset) {\n            return markStart + hexen + markEnd;\n        } else {\n            return ' ' + hexen + ' ';\n        }\n    }\n}\n\nmodule.exports.fromBuffer = fromBuffer;\nmodule.exports.byteLength = byteLength;\nmodule.exports.toBuffer = toBuffer;\nmodule.exports.intoBuffer = intoBuffer;\nmodule.exports.formatError = formatError;\n\nmodule.exports.fromBufferTuple = fromBufferTuple;\nmodule.exports.byteLengthTuple = byteLengthTuple;\nmodule.exports.toBufferTuple = toBufferTuple;\nmodule.exports.intoBufferTuple = intoBufferTuple;\n\nmodule.exports.fromBufferResult = fromBufferResult;\nmodule.exports.byteLengthResult = byteLengthResult;\nmodule.exports.toBufferResult = toBufferResult;\nmodule.exports.intoBufferResult = intoBufferResult;\n\nmodule.exports.makeAnnotatedBuffer = makeAnnotatedBuffer;\nmodule.exports.checkAllReadFrom = checkAllReadFrom;\nmodule.exports.annotateError = annotateError;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}