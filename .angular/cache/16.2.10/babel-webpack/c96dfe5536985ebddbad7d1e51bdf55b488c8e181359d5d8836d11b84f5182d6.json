{"ast":null,"code":"// Copyright (c) 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint max-statements:[0, 99] */\n'use strict';\n\nvar bufrw = require('bufrw');\nvar TYPE = require('./TYPE');\nvar inherits = require('util').inherits;\nvar errors = require('./errors');\nfunction TField(typeid, id, val) {\n  if (!(this instanceof TField)) {\n    return new TField(typeid, id, val);\n  }\n  this.typeid = typeid;\n  this.id = id;\n  this.val = val;\n}\nfunction TStruct(fields) {\n  if (!(this instanceof TStruct)) {\n    return new TStruct(fields);\n  }\n  this.fields = fields || [];\n}\nfunction TStructRW(opts) {\n  if (!(this instanceof TStructRW)) {\n    return new TStructRW(opts);\n  }\n  this.ttypes = opts.ttypes;\n}\ninherits(TStructRW, bufrw.Base);\nTStructRW.prototype.poolByteLength = function poolByteLength(destResult, struct) {\n  var length = 1; // STOP byte\n  var t;\n  for (var i = 0; i < struct.fields.length; i++) {\n    var field = struct.fields[i];\n    var type = this.ttypes[field.typeid];\n    if (!type) {\n      return destResult.reset(errors.InvalidTypeidError({\n        typeid: field.typeid,\n        what: 'field::type'\n      }));\n    }\n    length += 3; // field header length\n\n    t = type.poolByteLength(destResult, field.val);\n    // istanbul ignore if\n    if (t.err) {\n      return t;\n    }\n    length += t.length;\n  }\n  return destResult.reset(null, length);\n};\nTStructRW.prototype.poolWriteInto = function poolWriteInto(destResult, struct, buffer, offset) {\n  var t;\n  for (var i = 0; i < struct.fields.length; i++) {\n    var field = struct.fields[i];\n    var type = this.ttypes[field.typeid];\n    if (!type) {\n      return destResult.reset(errors.InvalidTypeidError({\n        typeid: field.typeid,\n        what: 'field::type'\n      }));\n    }\n    t = bufrw.Int8.poolWriteInto(destResult, field.typeid, buffer, offset);\n    // istanbul ignore if\n    if (t.err) {\n      return t;\n    }\n    offset = t.offset;\n    t = bufrw.Int16BE.poolWriteInto(destResult, field.id, buffer, offset);\n    // istanbul ignore if\n    if (t.err) {\n      return t;\n    }\n    offset = t.offset;\n    t = type.poolWriteInto(destResult, field.val, buffer, offset);\n    // istanbul ignore if\n    if (t.err) {\n      return t;\n    }\n    offset = t.offset;\n  }\n  t = bufrw.Int8.poolWriteInto(destResult, TYPE.STOP, buffer, offset);\n  // istanbul ignore if\n  if (t.err) {\n    return t;\n  }\n  offset = t.offset;\n  return destResult.reset(null, offset);\n};\nTStructRW.prototype.poolReadFrom = function poolReadFrom(destResult, buffer, offset) {\n  /* eslint no-constant-condition:[0] */\n  var struct = new TStruct();\n  var t;\n  while (true) {\n    t = bufrw.Int8.poolReadFrom(destResult, buffer, offset);\n    // istanbul ignore if\n    if (t.err) {\n      return t;\n    }\n    offset = t.offset;\n    var typeid = t.value;\n    if (typeid === TYPE.STOP) {\n      break;\n    }\n    var type = this.ttypes[typeid];\n    if (!type) {\n      return destResult.reset(errors.InvalidTypeidError({\n        typeid: typeid,\n        what: 'field::type'\n      }), offset);\n    }\n    t = bufrw.Int16BE.readFrom(buffer, offset);\n    // istanbul ignore if\n    if (t.err) {\n      return t;\n    }\n    offset = t.offset;\n    var id = t.value;\n    t = type.poolReadFrom(destResult, buffer, offset);\n    // istanbul ignore if\n    if (t.err) {\n      return t;\n    }\n    offset = t.offset;\n    var val = t.value;\n    struct.fields.push(TField(typeid, id, val));\n  }\n  return destResult.reset(null, offset, struct);\n};\nmodule.exports.TStruct = TStruct;\nmodule.exports.TField = TField;\nmodule.exports.TStructRW = TStructRW;","map":{"version":3,"names":["bufrw","require","TYPE","inherits","errors","TField","typeid","id","val","TStruct","fields","TStructRW","opts","ttypes","Base","prototype","poolByteLength","destResult","struct","length","t","i","field","type","reset","InvalidTypeidError","what","err","poolWriteInto","buffer","offset","Int8","Int16BE","STOP","poolReadFrom","value","readFrom","push","module","exports"],"sources":["/home/bvpelt/Develop/openteltest/node_modules/thriftrw/tstruct.js"],"sourcesContent":["// Copyright (c) 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint max-statements:[0, 99] */\n'use strict';\n\nvar bufrw = require('bufrw');\nvar TYPE = require('./TYPE');\nvar inherits = require('util').inherits;\nvar errors = require('./errors');\n\nfunction TField(typeid, id, val) {\n    if (!(this instanceof TField)) {\n        return new TField(typeid, id, val);\n    }\n    this.typeid = typeid;\n    this.id = id;\n    this.val = val;\n}\n\nfunction TStruct(fields) {\n    if (!(this instanceof TStruct)) {\n        return new TStruct(fields);\n    }\n    this.fields = fields || [];\n}\n\nfunction TStructRW(opts) {\n    if (!(this instanceof TStructRW)) {\n        return new TStructRW(opts);\n    }\n    this.ttypes = opts.ttypes;\n}\ninherits(TStructRW, bufrw.Base);\n\nTStructRW.prototype.poolByteLength = function poolByteLength(destResult, struct) {\n    var length = 1; // STOP byte\n    var t;\n    for (var i = 0; i < struct.fields.length; i++) {\n        var field = struct.fields[i];\n        var type = this.ttypes[field.typeid];\n        if (!type) {\n            return destResult.reset(errors.InvalidTypeidError({\n                typeid: field.typeid, what: 'field::type'\n            }));\n        }\n\n        length += 3; // field header length\n\n        t = type.poolByteLength(destResult, field.val);\n        // istanbul ignore if\n        if (t.err) {\n            return t;\n        }\n        length += t.length;\n    }\n    return destResult.reset(null, length);\n};\n\nTStructRW.prototype.poolWriteInto = function poolWriteInto(destResult, struct, buffer, offset) {\n    var t;\n    for (var i = 0; i < struct.fields.length; i++) {\n        var field = struct.fields[i];\n        var type = this.ttypes[field.typeid];\n        if (!type) {\n            return destResult.reset(errors.InvalidTypeidError({\n                typeid: field.typeid, what: 'field::type'\n            }));\n        }\n\n        t = bufrw.Int8.poolWriteInto(destResult, field.typeid, buffer, offset);\n        // istanbul ignore if\n        if (t.err) {\n            return t;\n        }\n        offset = t.offset;\n\n        t = bufrw.Int16BE.poolWriteInto(destResult, field.id, buffer, offset);\n        // istanbul ignore if\n        if (t.err) {\n            return t;\n        }\n        offset = t.offset;\n\n        t = type.poolWriteInto(destResult, field.val, buffer, offset);\n        // istanbul ignore if\n        if (t.err) {\n            return t;\n        }\n        offset = t.offset;\n    }\n    t = bufrw.Int8.poolWriteInto(destResult, TYPE.STOP, buffer, offset);\n    // istanbul ignore if\n    if (t.err) {\n        return t;\n    }\n    offset = t.offset;\n    return destResult.reset(null, offset);\n};\n\nTStructRW.prototype.poolReadFrom = function poolReadFrom(destResult, buffer, offset) {\n    /* eslint no-constant-condition:[0] */\n    var struct = new TStruct();\n    var t;\n    while (true) {\n        t = bufrw.Int8.poolReadFrom(destResult, buffer, offset);\n        // istanbul ignore if\n        if (t.err) {\n            return t;\n        }\n        offset = t.offset;\n        var typeid = t.value;\n        if (typeid === TYPE.STOP) {\n            break;\n        }\n        var type = this.ttypes[typeid];\n        if (!type) {\n            return destResult.reset(errors.InvalidTypeidError({\n                typeid: typeid,\n                what: 'field::type'\n            }), offset);\n        }\n\n        t = bufrw.Int16BE.readFrom(buffer, offset);\n        // istanbul ignore if\n        if (t.err) {\n            return t;\n        }\n        offset = t.offset;\n        var id = t.value;\n\n        t = type.poolReadFrom(destResult, buffer, offset);\n        // istanbul ignore if\n        if (t.err) {\n            return t;\n        }\n        offset = t.offset;\n        var val = t.value;\n        struct.fields.push(TField(typeid, id, val));\n    }\n    return destResult.reset(null, offset, struct);\n};\n\nmodule.exports.TStruct = TStruct;\nmodule.exports.TField = TField;\nmodule.exports.TStructRW = TStructRW;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}